<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LinXunFeng‘s Blog</title>
  <icon>http://linxunfeng.top/images/others/profile/avatar.jpg</icon>
  
  <link href="http://linxunfeng.top/atom.xml" rel="self"/>
  
  <link href="http://linxunfeng.top/"/>
  <updated>2021-01-31T14:26:32.813Z</updated>
  <id>http://linxunfeng.top/</id>
  
  <author>
    <name>LinXunFeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker - Dockerfile的使用</title>
    <link href="http://linxunfeng.top/2021/01/31/pages/05278d/"/>
    <id>http://linxunfeng.top/2021/01/31/pages/05278d/</id>
    <published>2021-01-31T14:23:49.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Dockerfile: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p><p>应用: 将部署过程中涉及到的所有步骤全部写入到 <code>Dockerfile</code> 中，到时只需要执行 <code>Dockerfile</code> 就可以自动完成相应的操作</p></blockquote><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="编辑Dockerfile"><a href="#编辑Dockerfile" class="headerlink" title="编辑Dockerfile"></a>编辑Dockerfile</h3><p>在当前目录下创建 <code>Dockerfile</code> 并进行编辑<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><br>操作：启动 <code>ubuntu</code> 镜像，在启动起来后去更新 <code>ubuntu</code> 容器下的软件资源<br>内容如下<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># From: 启动运行一个镜像资源</span></span><br><span class="line"><span class="keyword">From</span> ubuntu</span><br><span class="line"><span class="comment"># Run: 在启动起来的容器中执行指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br></pre></td></tr></table></figure></p><h3 id="运行Dockerfile"><a href="#运行Dockerfile" class="headerlink" title="运行Dockerfile"></a>运行Dockerfile</h3><p>构建镜像命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t [镜像名]:[版本号] [Dockerfile所在目录]</span><br></pre></td></tr></table></figure><br>指定在当前目录下去查找 <code>Dockerfile</code> 文件，并将 <code>Dockerfile</code> 自动化处理后的（更新了软件资源）容器打成名为 <code>lxf</code> 的镜像资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t lxf .</span><br></pre></td></tr></table></figure><p>执行效果：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145009.png" alt=""><br>待执行完成后，当前拥有的镜像资源就多出了 <code>lxf</code> 这一个，可以看到 <code>lxf</code> 这个镜像的大小是要比 <code>ubuntu</code> 的镜像要大一点的<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145041.png" alt=""></p><h2 id="基础指令详解"><a href="#基础指令详解" class="headerlink" title="基础指令详解"></a>基础指令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><br>说明：</p><ul><li><code>FROM</code> 是 <code>Dockerfile</code> 里的第一条而且只能是除了首行注释之外的第一条指令</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell模式</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> &lt;<span class="built_in">command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exec模式</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></span><br></pre></td></tr></table></figure><br>说明：</p><ul><li>表示当前镜像构建时候运行的命令</li></ul><p>注释：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># shell 模式：类似于 /bin/bash -c command </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exec 模式：类似于 RUN ["/bin/bash", "-c", "command"] </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"echo"</span>, <span class="string">"hello"</span>]</span></span><br></pre></td></tr></table></figure></p><p>执行多条指令</p><ul><li><p>一条条指令写</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> world</span></span><br></pre></td></tr></table></figure></li><li><p>将指令用 <code>&amp;&amp;</code> 连接起来</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello &amp;&amp; <span class="built_in">echo</span> world</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure><br>说明：</p><ul><li>指定该 <code>Dockerfile</code> 文件的维护者信息</li></ul><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><blockquote><p>设置容器对外开放的端口</p></blockquote><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><br>解释：</p><ul><li>设置 <code>Docker</code> 容器对外暴露的端口号， <code>Docker</code> 为了安全，不会自动对外打开端口，如果需要外部提供访问，还需要启动容器时增加 <code>-p</code> 或者 <code>-P</code> 参数对容器的端口进行分配。</li></ul><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><blockquote><p>设置容器在启动后去执行一个命令</p></blockquote><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exec 模式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>,<span class="string">"param2"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell模式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure><br>解释：</p><ul><li>每个 <code>Dockerfile</code> 中只能有一个 <code>ENTRYPOINT</code> ，当指定多个时，只有最后一个起效。</li></ul><p><code>EXPOSE</code> 和 <code>ENTRYPOINT</code> 结合使用的例子，可以全文看完后再回到这里看该例子<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用django镜像资源</span></span><br><span class="line"><span class="keyword">From</span> django</span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home</span></span><br><span class="line"><span class="comment"># 创建一个名为lxf的django项目</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> django-admin startproject lxf</span></span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home/lxf</span></span><br><span class="line"><span class="comment"># 对外开放8000端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"><span class="comment"># 容器启动后，将django服务开启，并指定端口号为8000</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> python3 manage.py runserver 0.0.0.0:8000</span></span><br></pre></td></tr></table></figure><br>执行构建镜像命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t lxf .</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145109.png" alt=""><br>现在我们将构建好的 <code>lxf</code> 容器运行起来，并随机分配端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -P lxf</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145121.png" alt=""><br>可以看到， <code>Docker</code> 为我们随机分配了 <code>55001</code> 端口映射到容器的 <code>8000</code> 端口，并且可以正常访问到容器的 <code>django</code> 服务<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145133.png" alt=""></p><h2 id="文件指令详解"><a href="#文件指令详解" class="headerlink" title="文件指令详解"></a>文件指令详解</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]</span></span><br></pre></td></tr></table></figure><br>说明：</p><ul><li>将指定的 <code>&lt;src&gt;</code> 文件复制到容器文件系统中的 <code>&lt;dest&gt;</code> </li><li><code>src</code> 指的是宿主机，<code>dest</code>  指的是容器</li><li>如果源文件是个压缩文件，则 <code>Docker</code> 会自动帮解压到指定的容器中(无论目标是文件还是目录，都会当成目录处理)。</li></ul><p>如：将宿主机下的 <code>./data</code> 目录下的所有文件(夹)，全部复制到容器的 <code>/home</code> 目录下<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./data /home</span></span><br></pre></td></tr></table></figure><br>注：目录本身即 <code>data</code> 目录并不会复制到容器中，只复制 <code>data</code> 目录下的文件(夹)，如果想连同 <code>data</code> 文件夹也复制过去，可以修改为如下指令<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./data /home/data</span></span><br></pre></td></tr></table></figure></p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]</span></span><br></pre></td></tr></table></figure><br>解释：</p><ul><li>单纯复制文件场景， <code>Docker</code> 推荐使用 <code>COPY</code> </li><li>如果源文件是个压缩文件， <code>Docker</code> 会直接将压缩文件复制进容器内，不会像 <code>ADD</code> 那样先解压再复制</li></ul><p>注： <code>COPY</code> 与 <code>ADD</code> 基本上是一样的，只是面对源文件是压缩文件时处理方式不同而已， <code>ADD</code> 会先解压再将解压后的内容复制到容器， <code>COPY</code> 不会进行解压，而是直接将压缩包复制过去</p><h2 id="环境指令详解"><a href="#环境指令详解" class="headerlink" title="环境指令详解"></a>环境指令详解</h2><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><blockquote><p>设置环境变量</p></blockquote><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><br>解释：</p><ul><li>设置环境变量，可以在 <code>RUN</code> 之前使用，然后 <code>RUN</code> 命令时调用，容器启动时这些环境变量都会被指定</li></ul><p>如：设置了环境变量 <code>name</code> ，并赋值为 <code>lxf</code> ，使用 <code>RUN</code> 命令打印 <code>name</code> 变量的值，可以成功打印出来<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name=lxf</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$name</span> <span class="comment"># 会打印出lxf</span></span></span><br></pre></td></tr></table></figure><br>并且，当进入容器后也可以正常打印出该变量的值<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@5721971f92e4:/# echo $name</span><br><span class="line">lxf</span><br></pre></td></tr></table></figure></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><blockquote><p>切换目录</p></blockquote><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure><br>解释：</p><ul><li>切换目录，为后续的 <code>RUN</code> 、 <code>CMD</code> 、 <code>ENTRYPOINT</code> 指令配置工作目录。 </li><li>相当于 <code>cd</code> 命令，可以使用多个 <code>WORKDIR</code> 指令进行多次切换，后续命令如果参数是相对路径，则会基于之前命令指定的路径</li><li>如果我们指定切换到一个不存在的目录， <code>Docker</code> 会帮我们自动创建相应的目录</li></ul><p>举例：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><br>最终路径为 <code>/a/b/c</code> </p><p>如果我们想要容器被运行起来时，自动进入到 <code>/home</code> ，可以按如下指令设置<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home</span></span><br></pre></td></tr></table></figure><br>执行 <code>Dockerfile</code> 构建镜像完成后运行起来，此时容器便会自动进入到 <code>/home</code> 目录<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145219.png" alt=""><br>对比一下之前没有设置使用过 <code>WORKDIR</code> ，运行起来的容器，会默认进入到根目录<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145231.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Dockerfile: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。&lt;/p&gt;
&lt;p&gt;应用: 将部署过程中涉及到的所有步骤全部写入到 &lt;code&gt;Dockerfile&lt;/code&gt; 中，到时只需要执行 &lt;code&gt;Do</summary>
      
    
    
    
    <category term="Docker" scheme="http://linxunfeng.top/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://linxunfeng.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 网络管理</title>
    <link href="http://linxunfeng.top/2021/01/31/pages/337d0f/"/>
    <id>http://linxunfeng.top/2021/01/31/pages/337d0f/</id>
    <published>2021-01-31T14:23:39.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131150136.jpeg" alt=""></p><blockquote><p>默认情况下，容器和宿主机之间网络是隔离的 </p></blockquote><p>现在启动了一个 <code>nginx</code> 容器<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143943.png" alt=""><br>如图所示 <code>nginx</code> 使用了 <code>80</code> 端口，但是我们去浏览器里访问 <code>localhost:80</code> 是无法访问到 <code>nginx</code> 服务的<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143955.png" alt=""><br>这个时候可以通过端口映射的方式，将容器中的端口，映射到宿主机的某个端口上，从而使我们能够通过宿主机的 <code>ip+端口</code> 的方式来访问容器里的内容</p><h2 id="随机端口映射"><a href="#随机端口映射" class="headerlink" title="随机端口映射"></a>随机端口映射</h2><blockquote><p><code>-P</code> ：自动绑定所有对外提供服务的容器端口，映射的端口会从没有使用的端口池中自动随机选择，如果连续启动多个容器的话，则下一个容器的端口默认是当前容器的端口号+1</p></blockquote><p>命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P [镜像名称]</span><br></pre></td></tr></table></figure><br>在刚才的命令基本上加 <code>-P</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -P --name lxfnginx nginx</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144009.png" alt=""><br>这样宿主机的 <code>55000</code> 端口就映射到了窗口的 <code>80</code> 端口，访问也是成功的。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144026.png" alt=""></p><h2 id="指定端口映射"><a href="#指定端口映射" class="headerlink" title="指定端口映射"></a>指定端口映射</h2><p>命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p [宿主机ip]:[宿主机端口]:[容器端口] --name [容器名称] [镜像名称]</span><br></pre></td></tr></table></figure><br>将宿主机上的 <code>8000</code> 端口映射到 <code>nginx</code> 容器的 <code>80</code> 端口<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -p 8000:80 --name lxfnginx nginx</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144045.png" alt=""><br>再去访问 <code>localhost:8000</code> 时也是可以正常访问到的<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144059.png" alt=""></p><p><code>0.0.0.0</code> 表示地址全匹配，即 <code>127.0.0.1</code> 或者宿主机的局域网IP <code>192.168.1.x</code> 这种都可以访问到 <code>nginx</code> 服务，如果我们想指定绑定的 <code>IP</code> ，可以在映射端口前加上 <code>IP</code> 即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -p 192.168.1.234:8000:80 --name lxfnginx nginx</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144117.png" alt=""><br>虽然图中显示的是 <code>127.0.0.1:55000-&gt;80</code> ，但是经过测试</p><ul><li><code>192.168.1.234:8000</code> 是可以正常访问</li><li><code>127.0.0.1:55000</code> 和 <code>127.0.0.1:8000</code> 无法访问</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144134.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144148.png" alt=""></p><h2 id="多端口映射"><a href="#多端口映射" class="headerlink" title="多端口映射"></a>多端口映射</h2><p>命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p [宿主机端口1]:[容器端口1]  -p [宿主机端口2]:[容器端口2] --name [容器名称] [镜像名称]</span><br></pre></td></tr></table></figure><br>如下命令所示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 7000:443 -p 8000:80 --name lxfnginx nginx</span><br></pre></td></tr></table></figure></p><h2 id="共享网络"><a href="#共享网络" class="headerlink" title="共享网络"></a>共享网络</h2><blockquote><p>共享网络: 容器与宿主机共享网络信息</p></blockquote><p>默认情况下，容器的网络信息与宿主机是相互独立的，这样会有什么问题呢？</p><p>假如运行一个提供了 <code>django</code> 服务的容器，宿主机本地提供了 <code>MySql</code> 服务，此时容器想访问宿主机的数据库，是无法访问到的，这个时候容器就需要共享宿主机的网络</p><p>在启动容器时，加上 <code>--network=host</code> 即可共享网络，命令如下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --network=host lxf_django</span><br></pre></td></tr></table></figure><br>这样，容器与宿主机的网络就是共享的状态，此时的容器也就可以访问到宿主机的数据库了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131150136.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="Docker" scheme="http://linxunfeng.top/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://linxunfeng.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 数据管理</title>
    <link href="http://linxunfeng.top/2021/01/31/pages/867207/"/>
    <id>http://linxunfeng.top/2021/01/31/pages/867207/</id>
    <published>2021-01-31T14:23:29.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145525.jpeg" alt=""></p><h2 id="拷贝数据"><a href="#拷贝数据" class="headerlink" title="拷贝数据"></a>拷贝数据</h2><h3 id="宿主机文件-gt-容器内"><a href="#宿主机文件-gt-容器内" class="headerlink" title="宿主机文件 -&gt; 容器内"></a>宿主机文件 -&gt; 容器内</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名:容器内的目录路径</span><br></pre></td></tr></table></figure><p>如：把宿主机当前目录下的 <code>lxf.sh</code> 文件，拷贝到  <code>lxfubuntu1</code> 容器下的 <code>/data</code> 目录中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp lxf.sh lxfubuntu1:/data</span><br></pre></td></tr></table></figure></p><h3 id="容器内-gt-宿主机文件"><a href="#容器内-gt-宿主机文件" class="headerlink" title="容器内 -&gt; 宿主机文件"></a>容器内 -&gt; 宿主机文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器名:容器内需要拷贝的文件或目录 宿主机目录</span><br></pre></td></tr></table></figure><p>如：把 <code>lxfubuntu1</code> 容器中 <code>/data</code> 目录下的 <code>lxf.sh</code> 文件，拷贝到宿主机 <code>~/lxf/</code> 目录下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp lxfubuntu1:/data/lxf.sh ~/lxf/</span><br></pre></td></tr></table></figure></p><h2 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h2><blockquote><p>数据卷管理就是将容器的某个目录，映射到宿主机，作为数据存储同步的目录</p></blockquote><p>命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name [容器名字] -v [宿主机目录]:[容器目录] [镜像名称] [命令(可选)]</span><br></pre></td></tr></table></figure><br>下面进行操作示范：</p><p>在宿主机创建一个名为 <code>data</code> 的目录，这个名字可任意<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br></pre></td></tr></table></figure><br>将宿主机的 <code>data</code> 目录映射到容器中的 <code>/home</code> 目录<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/lxf/data:/home ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br><code>-v</code> ：挂载一个数据卷<br>接着，我在容器的 <code>/home</code> 目录下创建一个 <code>lxfdir</code> 目录<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143655.png" alt=""><br>此时，宿主机的 <code>data</code> 目录下也会同步多了一个 <code>lxfdir</code> 目录<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143708.png" alt=""></p><p>这个宿主机的 <code>data</code> 目录就叫数据卷。</p><p>除了宿主机与容器之间可以进行数据交互外，如果两个容器的目录都映射到同一个宿主机目录，那还可以让多个容器间进行数据共享。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><blockquote><p>数据卷容器也是一个容器，目的是专门用于提供数据卷给其它容器挂载，从而实现多个容器之间同步数据的更新。</p></blockquote><h3 id="创建数据卷模板容器"><a href="#创建数据卷模板容器" class="headerlink" title="创建数据卷模板容器"></a>创建数据卷模板容器</h3><p>命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create -v [容器数据卷目录] --name [容器名字] [镜像名称] [命令(可选)]</span><br></pre></td></tr></table></figure><br>对<code>ubuntu</code> 镜像做了文件映射，得到数据卷目录为 <code>/data</code> 的模板容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create -v /data ubuntu</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143736.png" alt=""><br>注意看该模板容器的状态是 <code>Created</code> ，即并没有运行，容器名为  <code>determined_nightingale</code>  </p><h3 id="基于数据卷模板创建容器"><a href="#基于数据卷模板创建容器" class="headerlink" title="基于数据卷模板创建容器"></a>基于数据卷模板创建容器</h3><p>命令:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [数据卷容器id/name] -tid --name [容器名字] [镜像名称] [命令(可选)]</span><br></pre></td></tr></table></figure><br>创建 <code>lxfubuntu1</code> 容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from determined_nightingale --name lxfubuntu1 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143750.png" alt=""><br>在容器的根目录下，会基于上述模板创建了一个名为 <code>data</code> 的目录（原 <code>ubuntu</code> 镜像中是没有的）</p><p>我们再创建一个 <code>lxfubuntu2</code> 容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from determined_nightingale --name lxfubuntu2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143805.png" alt=""><br>此时，我们在 <code>lxfubuntu1</code> 的 <code>data</code> 目录下创建一个名为 <code>lxf</code> 的目录， <code>lxfubuntu2</code> 的 <code>data</code> 目录中也会同步到相同的数据<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143817.png" alt=""><br>这样，只要我们是基于数据卷模板容器创建出来的容器，就可以得到一个数据共享的 <code>data</code> 目录，在该 <code>data</code> 目录中对文件的操作，都可以同步到各个由该模板容器创建出来的容器中。</p><h3 id="与宿主机同步文件"><a href="#与宿主机同步文件" class="headerlink" title="与宿主机同步文件"></a>与宿主机同步文件</h3><blockquote><p> 数据卷容器可以实现多个容器的数据同步，但是数据是保存在数据卷内，并没有保存到宿主机的文件目录中。</p><p>如果想将宿主机的文件同步到各个容器，可以使用 <code>docker cp</code> 将宿主机下的文件拷贝到数据卷容器即可，反之亦然</p></blockquote><p>如：把宿主机当前目录下的 <code>lxf.sh</code> 文件，拷贝到数据卷容器 <code>determined_nightingale</code> 中 <code>/data</code> 目录下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp lxf.sh determined_nightingale:/data</span><br></pre></td></tr></table></figure><br>如：把数据卷容器 <code>determined_nightingale</code> 中 <code>/data</code> 目录下的 <code>lxf.sh</code> 文件，拷贝到宿主机 <code>~/lxf</code> 目录下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp determined_nightingale:/data/lxf.txt ~/lxf</span><br></pre></td></tr></table></figure><br>是不是有人要问了，如果我基于数据卷模板创建容器时，顺带设置数据卷呢？，命令如下所示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v ~/lxf/data:/data --volumes-from determined_nightingale --name lxfubuntu3 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br>很遗憾，只有数据卷配置生效，数据卷容器配置不生效～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145525.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="Docker" scheme="http://linxunfeng.top/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://linxunfeng.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 私有仓库Registry</title>
    <link href="http://linxunfeng.top/2021/01/31/pages/bfa843/"/>
    <id>http://linxunfeng.top/2021/01/31/pages/bfa843/</id>
    <published>2021-01-31T14:23:19.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143241.jpeg" alt=""></p><blockquote><p>私有仓库: 在本地（局域网）搭建的一个类似公共仓库的东西，我们可以将镜像提交到私有仓库中，供局域网内的其它人拉取使用。<br>本文以 <code>Registry</code> 为例，并在提供私有仓库的主机上操作</p></blockquote><h2 id="拉取私有仓库镜像"><a href="#拉取私有仓库镜像" class="headerlink" title="拉取私有仓库镜像"></a>拉取私有仓库镜像</h2><p>请先确保你当前拥有的镜像有 <code>registry</code><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143259.png" alt=""><br>如果没有，可以先拉取下来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull registry</span><br></pre></td></tr></table></figure><h2 id="设置私有仓库地址"><a href="#设置私有仓库地址" class="headerlink" title="设置私有仓库地址"></a>设置私有仓库地址</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>修改 <code>insecure-registries</code> 的值，提供私有仓库的主机的ip地址和端口<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "insecure-registries":[</span><br><span class="line">    <span class="string">"192.168.1.234:5000"</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Mac软件版<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143315.png" alt=""><br><strong>修改后重新启动 <code>docker</code> 服务</strong></p><h2 id="运行私有仓库镜像资源"><a href="#运行私有仓库镜像资源" class="headerlink" title="运行私有仓库镜像资源"></a>运行私有仓库镜像资源</h2><p>将 <code>registry</code> 镜像生成一个容器并运行起来<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p 5000:5000 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个是容器使用的端口，第二个是本地端口，这里是本地端口映射到把容器的端口</span></span><br><span class="line">docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/lxf ❯ docker ps</span><br><span class="line">❯ docker ps</span><br><span class="line">CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS      NAMES</span><br><span class="line">f12ad7ae43ca   registry   "/entrypoint.sh /etc…"   9 minutes ago   Up 9 minutes   5000/tcp   nostalgic_elion</span><br></pre></td></tr></table></figure><br>此时你可以访问如下地址，如果看到 <code>{}</code> 就说明 <code>Registry</code> 运行正常<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.1.234:5000/v2/</span><br></pre></td></tr></table></figure></p><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><p>比如此时我要将 <code>ubuntu</code> 这个镜像上传到私有仓库<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给ubuntu镜像打一个tag，命名需为 私有仓库主机ip:端口/镜像名:[版本号,不加默认为latest]</span></span><br><span class="line">docker tag ubuntu:latest 192.168.1.234:5000/ubuntu:v0.1</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143336.png" alt=""><br>开始上传镜像至本地的私有仓库中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker push &lt;registry_ip&gt;:&lt;registry_port&gt;/&lt;image_name&gt;:&lt;image_tag&gt;</span></span><br><span class="line">docker push 192.168.1.234:5000/ubuntu:v0.1</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143349.png" alt=""></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>先将本地的 <code>v0.1</code> 删掉<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 192.168.1.234:5000/ubuntu:v0.1</span><br></pre></td></tr></table></figure><br>拉取私有仓库中 <code>ubuntu</code> 的 <code>0.1</code> 版本镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull &lt;registry_ip&gt;:&lt;registry_port&gt;/&lt;image_name&gt;:&lt;image_tag&gt;</span></span><br><span class="line">docker pull 192.168.1.234:5000/ubuntu:v0.1</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143403.png" alt=""></p><h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p><code>Registry</code> 不支持通过 <code>docker search</code> 这种方式去搜索镜像，会报 <code>404</code> 的错误<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143415.png" alt=""><br>需要使用 <code>V2 API</code> 去查询</p><h3 id="列出仓库中所有的镜像"><a href="#列出仓库中所有的镜像" class="headerlink" title="列出仓库中所有的镜像"></a>列出仓库中所有的镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 192.168.1.234:5000/v2/_catalog</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143430.png" alt=""></p><h3 id="列出指定镜像的所有标签"><a href="#列出指定镜像的所有标签" class="headerlink" title="列出指定镜像的所有标签"></a>列出指定镜像的所有标签</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl -X GET http://&lt;registry_ip&gt;:&lt;registry_port&gt;/v2/&lt;image_name&gt;/tags/list</span></span><br><span class="line">curl 192.168.1.234:5000/v2/lxf/tags/list</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143447.png" alt=""></p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>查找指定标签的镜像的 <code>digest</code> ，再根据这个 <code>digest</code> 来删除，以删除 <code>lxf:0.2</code> 镜像为例</p><p>先执行命令找到该镜像的 <code>digest</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --silent -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -X GET  http://192.168.1.234:5000/v2/lxf/manifests/0.2 2&gt;&amp;1 | grep Docker-Content-Digest | awk '&#123;print ($3)&#125;'</span><br></pre></td></tr></table></figure><br>得到输出值<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241</span><br></pre></td></tr></table></figure><br>根据 <code>digest</code> 来删除镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --silent -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -X DELETE http://192.168.1.234:5000/v2/lxf/manifests/sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143500.png" alt=""><br>这个时候只是删除镜像的元数据，并没有真正从硬盘上删除镜像，需要执行垃圾回收才行。</p><h3 id="删除失败"><a href="#删除失败" class="headerlink" title="删除失败"></a>删除失败</h3><p>遇到 <code>405 UNSUPPORTED</code> 错误<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143512.png" alt=""></p><p>需要在运行 <code>Registry</code> 容器时设置<code>REGISTRY_STORAGE_DELETE_ENABLED</code> 为 <code>true</code> </p><p>举例<br><code>docker-compose.yaml</code>：设置环境变量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">    <span class="attr">REGISTRY_STORAGE_DELETE_ENABLED:</span> <span class="string">"true"</span></span><br></pre></td></tr></table></figure><p><code>docker run</code>：添加参数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -e REGISTRY_STORAGE_DELETE_ENABLED=<span class="string">"true"</span></span></span><br><span class="line">docker run -d -p 5000:5000 -e REGISTRY_STORAGE_DELETE_ENABLED="true" registry</span><br></pre></td></tr></table></figure></p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote><p>执行垃圾回收，上述删除的镜像才会真正从硬盘上移除</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it registry的容器名 /bin/registry garbage-collect /etc/docker/registry/config.yml</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143530.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143241.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="Docker" scheme="http://linxunfeng.top/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://linxunfeng.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 操作容器</title>
    <link href="http://linxunfeng.top/2021/01/31/pages/861244/"/>
    <id>http://linxunfeng.top/2021/01/31/pages/861244/</id>
    <published>2021-01-31T14:22:18.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142731.jpeg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142751.png" alt=""></p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>这里我使用 <code>ubuntu</code> 镜像，创建一个名为 <code>lxfubuntu</code> 的容器，并运行进入容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run -it --name [容器名] [镜像名] /bin/bash</span></span><br><span class="line"></span><br><span class="line">docker run -it --name lxfubuntu ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br>命令参数详解：</p><ul><li><code>--name</code> : 定义容器名称，如果不使用，则会随机产生一个名字</li><li><code>-i</code> : 让容器的标准输入保持打开</li><li><code>-t</code> : 让 <code>docker</code> 分配一个伪终端，并绑定到窗口的标准输入上</li><li><code>-d</code> : 以守护进程的方式运行容器，不占用终端</li><li><code>/bin/bash</code> : 执行一个命令</li></ul><p>如图，执行后即可进入容器中<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142815.png" alt=""></p><p>如果想创建并以守护进程的方式运行容器，可以使用 <code>-d</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name lxfubuntu1 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142828.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker start [container_id]</span></span><br><span class="line"></span><br><span class="line">docker start c97abc3f151a</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>如果我们想进入上述提及的以守护进程方式运行的容器中，可以使用 <code>docker exec</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it lxfubuntu1 /bin/bash</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142848.png" alt=""><br>如果在此时退出该守护进程的容器时，该容器依旧在后台运行</p><h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><p>两种方式</p><ul><li>方法一： 终端输入 <code>exit</code> 后回车</li><li>方法二： <code>Ctrl + D</code> </li></ul><p>如果容器是以守护进程的方式运行，在进入容器后退出，不停止容器的运行，即依旧在后台运行，否则将在容器退出时顺带停止容器</p><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker stop [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker stop lxfubuntu1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker stop c97abc3f151a</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143004.png" alt=""></p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker start [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker start lxfubuntu1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker start c97abc3f151a</span><br></pre></td></tr></table></figure><h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker restart [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker restart lxfubuntu1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker restart c97abc3f151a</span><br></pre></td></tr></table></figure><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><p>查看正在运行的容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></p><p>查看所有的容器，包括已经停止的容器<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">docker container ls --all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker ps --all</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143019.png" alt=""></p><p>如果只是想查看容器的ID，可以使用参数 <code>-q</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143032.png" alt=""></p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker [container] rm [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker container rm lxfubuntu</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker rm lxfubuntu1</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143045.png" alt=""></p><p>如果删除一个正在运行的容器，需要加 <code>-f</code><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143103.png" alt=""></p><p>结合上述查看容器中 <code>-q</code> 的功能，可以实现批量删除容器的功能<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker ps -aq 获取所有的容器id</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure></p><h2 id="查看容器详情"><a href="#查看容器详情" class="headerlink" title="查看容器详情"></a>查看容器详情</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker inspect [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker inspect lxfubuntu1</span><br></pre></td></tr></table></figure><h2 id="查看容器状态"><a href="#查看容器状态" class="headerlink" title="查看容器状态"></a>查看容器状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker container stats [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker container stats lxfubuntu1</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143123.png" alt=""></p><h2 id="打包容器为新的镜像资源"><a href="#打包容器为新的镜像资源" class="headerlink" title="打包容器为新的镜像资源"></a>打包容器为新的镜像资源</h2><blockquote><p>容器在安装了各种各样的服务后，将该容器打包为镜像资源，接着将该镜像资源进行打包，最后再发给其它人使用</p></blockquote><p>将 <code>lxfubuntu1</code> 这个容器打包成名为 <code>my_image</code> 的镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker commit 容器名 镜像资源名</span></span><br><span class="line">docker commit lxfubuntu1 my_image</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143137.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142731.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="Docker" scheme="http://linxunfeng.top/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://linxunfeng.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 操作镜像资源</title>
    <link href="http://linxunfeng.top/2021/01/24/pages/084bf9/"/>
    <id>http://linxunfeng.top/2021/01/24/pages/084bf9/</id>
    <published>2021-01-24T22:38:10.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224049.jpeg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224119.png" alt=""></p><h2 id="搜索镜像资源"><a href="#搜索镜像资源" class="headerlink" title="搜索镜像资源"></a>搜索镜像资源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224150.png" alt=""><br>一般选择 <code>STARS</code> 数最大的</p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>比如拉取上提及的 <code>nginx</code> 镜像<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull nginx</span><br></pre></td></tr></table></figure><br>命令执行后就开始对镜像进行拉取了<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224211.png" alt=""></p><h2 id="查看当前拥有的镜像"><a href="#查看当前拥有的镜像" class="headerlink" title="查看当前拥有的镜像"></a>查看当前拥有的镜像</h2><blockquote><p>镜像ID: 镜像的唯一标识，如果镜像ID相同，则说明是同一个镜像</p><p>TAG: 用来区分不同的发行版本，如果不指定具体标记，则默认使用latest来标记信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224239.png" alt=""></p><h2 id="查看镜像的详情信息"><a href="#查看镜像的详情信息" class="headerlink" title="查看镜像的详情信息"></a>查看镜像的详情信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker image inspect 镜像名</span></span><br><span class="line">docker image inspect ubuntu</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224256.png" alt=""></p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>完整写法<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm ubuntu</span><br></pre></td></tr></table></figure><br>简洁写法<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi ubuntu</span><br></pre></td></tr></table></figure><br>除了可以根据镜像名来删除外，也可以使用镜像ID，如使用上述的 <code>ubuntu</code> 镜像ID<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi f643c72bc252</span><br></pre></td></tr></table></figure><br>如果我们对同一个镜像打了多个 <code>tag</code> ，导致同一个镜像ID存在多个镜像名称，那此时可以使用 <code>name:tag</code> 的格式来删除镜像，如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker rmi ubuntu_lxf:v1.0</span></span><br></pre></td></tr></table></figure></p><h2 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker tag 当前镜像名:镜像版本 新的镜像名:新的版本</span></span><br><span class="line">docker tag ubuntu:latest ubuntu_lxf:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker tag ubuntu:latest ubuntu_lxf:v1.0</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224315.png" alt=""><br>注：</p><ul><li><code>ubuntu</code> 和 <code>ubuntu_lxf</code> 的 <code>IMAGE_ID</code> 是相同的</li><li>结合删除镜像的命令就可以实现镜像重命名功能</li></ul><h2 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h2><blockquote><p>docker save 会保存镜像的所有历史记录和元数据信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker save -o 包文件 镜像</span></span><br><span class="line">docker save -o ubuntu.tar ubuntu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker save 镜像1 ... 镜像n &gt; 包文件</span></span><br><span class="line">docker save ubuntu nginx &gt; lxf_images.tar</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224337.png" alt=""></p><h2 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h2><p>先删除 <code>ubuntu</code> 镜像<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224351.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker load -i 镜像包名</span></span><br><span class="line">docker load -i ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker load &lt; 镜像包名</span></span><br><span class="line">docker load &lt; ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker load --input 镜像包名</span></span><br><span class="line">docker load --input ubuntu.tar</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224416.png" alt=""><br>可以看到， <code>ubuntu</code> 镜像已经成功导入进来了</p><h2 id="查看镜像历史"><a href="#查看镜像历史" class="headerlink" title="查看镜像历史"></a>查看镜像历史</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker image <span class="built_in">history</span> 镜像名</span></span><br><span class="line"></span><br><span class="line">docker image history ubuntu</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224432.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224049.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="Docker" scheme="http://linxunfeng.top/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://linxunfeng.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker - 安装、加速和基本使用</title>
    <link href="http://linxunfeng.top/2021/01/24/pages/2ffb7f/"/>
    <id>http://linxunfeng.top/2021/01/24/pages/2ffb7f/</id>
    <published>2021-01-24T21:52:14.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Docker 容器是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何安装了docker引擎的服务器上</p></blockquote><p>本文主要以 <code>Mac</code> 平台为例</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="方式一-Homebrew"><a href="#方式一-Homebrew" class="headerlink" title="方式一: Homebrew"></a>方式一: Homebrew</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install docker</span><br></pre></td></tr></table></figure><h3 id="方式二-桌面程序"><a href="#方式二-桌面程序" class="headerlink" title="方式二: 桌面程序"></a>方式二: 桌面程序</h3><blockquote><p>我使用该方式</p></blockquote><p>访问 <a href="https://www.docker.com/get-started，在" target="_blank" rel="noopener">https://www.docker.com/get-started，在</a> <code>Docker Desktop</code> 下选择你当前系统对应的软件进行下载安装</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124215528.png" alt=""></p><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><h4 id="Daocloud"><a href="#Daocloud" class="headerlink" title="Daocloud"></a>Daocloud</h4><blockquote><p>实测，速度不咋地</p></blockquote><p>打开 <a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">daocloud.io</a> 网站，注册并登录，点击加速器按钮，或者直接打开 <a href="https://www.daocloud.io/mirror，打开的页面上会显示与你账号相关的加速地址" target="_blank" rel="noopener">https://www.daocloud.io/mirror，打开的页面上会显示与你账号相关的加速地址</a></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124215606.png" alt=""></p><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><blockquote><p>实测，速度杠杠的，推荐使用</p></blockquote><table><thead><tr><th>镜像</th><th>地址</th></tr></thead><tbody><tr><td>Docker中国区官方镜像</td><td><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></td></tr><tr><td>网易</td><td><a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a></td></tr><tr><td>ustc</td><td><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>该部分内容取自 <code>daocloud</code></p></blockquote><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;xxx.m.daocloud.io</span><br></pre></td></tr></table></figure><p>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。</p><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p>Docker For Mac</p><p>右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中加入下面的镜像地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.m.daocloud.io</span><br></pre></td></tr></table></figure><p>点击 Apply &amp; Restart 按钮使设置生效。</p><p>Docker Toolbox 等配置方法请参考<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox" target="_blank" rel="noopener">帮助文档</a>。</p><p>我自己的版本是 <code>3.1.0(51484)</code> ，与上述的不太一致。</p><p>如图所示，切换到 <code>Docker Engine</code> 下，在右侧所示的 <code>JSON</code> 内容中添加 <code>registry-mirrors</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;registry-mirrors&quot;: [&quot;你的加速器地址&quot;]</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124215627.png" alt=""></p><p>最后点击 <code>Apply&amp;Restart</code> 按钮即可。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>Docker For Windows</p><p>在桌面右下角状态栏中右键 docker 图标，修改在 Docker Daemon 标签页中的 json ，把下面的地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.m.daocloud.io</span><br></pre></td></tr></table></figure><p>加到” registry-mirrors”的数组里。点击 Apply 。</p><p>Docker Toolbox 等配置方法请参考<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox" target="_blank" rel="noopener">帮助文档</a>。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker version 20.10.2, build 2291f61</span><br></pre></td></tr></table></figure><h3 id="查看Docker信息"><a href="#查看Docker信息" class="headerlink" title="查看Docker信息"></a>查看Docker信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>可以使用该命名查看当前的镜像地址数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Registry: https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;</span><br><span class="line">Labels:</span><br><span class="line">Experimental: true</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0&#x2F;8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https:&#x2F;&#x2F;registry.docker-cn.com&#x2F;</span><br><span class="line"> http:&#x2F;&#x2F;hub-mirror.c.163.com&#x2F;</span><br><span class="line"> https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&#x2F;</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Docker 容器是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何安装了docker引擎的服务器上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文主要以 &lt;code&gt;Mac&lt;/code&gt;</summary>
      
    
    
    
    <category term="Docker" scheme="http://linxunfeng.top/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://linxunfeng.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Flutter - 低版本在iOS14上遇到的问题与解决方案</title>
    <link href="http://linxunfeng.top/2020/09/29/Flutter/Flutter%20-%20%E4%BD%8E%E7%89%88%E6%9C%AC%E5%9C%A8iOS14%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://linxunfeng.top/2020/09/29/Flutter/Flutter%20-%20%E4%BD%8E%E7%89%88%E6%9C%AC%E5%9C%A8iOS14%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-09-29T00:00:00.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>近期将测试机升级至 iOS14 ，测试使用 Flutter混合开发 的线上 APP，没发现什么问题，但是使用 Xcode 安装APP 的场景下，断开 Xcode 后再运行却闪退了。</p><p>+<a id="more"></a></p><The rest of contents | 余下全文><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>近期将测试机升级至 <code>iOS14</code> ，测试使用 <code>Flutter混合开发</code> 的线上 <code>APP</code>，没发现什么问题，但是使用 <code>Xcode</code> 安装<code>APP</code>的场景下，断开 <code>Xcode</code> 后再运行却闪退了。</p><p>公司的 <code>APP</code> 测试结果如下：</p><table><thead><tr><th>APP来源</th><th>是否闪退</th><th>模式</th></tr></thead><tbody><tr><td>线上</td><td>否</td><td>release</td></tr><tr><td>蒲公英</td><td>是</td><td>debug</td></tr><tr><td>Xcode</td><td>是（断开 <code>Xcode</code> 后再打开 <code>APP</code> ）</td><td>debug</td></tr></tbody></table><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>闪退的原因是因为 <code>Flutter SDK</code>,  <code>Flutter</code> 官方的更新速度也是快，对 <code>iOS14</code> 进行了说明：  <a href="https://flutter.dev/docs/development/ios-14" target="_blank" rel="noopener">Flutter官网说明链接</a></p><p>大致意思就是说，如果我们在 <code>iOS14</code> 的真机上安装了 <code>debug模式</code> 编译出来的 <code>flutter</code> 应用，那么在断开编译安装连接后，将无法从桌面上打开该应用程序。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>再次是使用 <code>Xcode</code> 或 <code>flutter run</code> 来运行。</li><li>设置 <code>Flutter</code> 模块的编译模式为 <code>profile</code> 或 <code>release</code></li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li>该闪退的情况只发生在真机，并且在模拟器运行的时候， <code>Flutter</code> 模块的编译模式需要为 <code>debug</code>， 如果设置了 <code>release</code>，编译将会报错。</li><li>官方指出如果是 <code>纯Flutter项目</code> 可以直接使用 <code>master channel</code> 的 <code>Flutter版本</code> 秒杀这个问题，但对混合开发并没有该说明，加上我们是使用闲鱼的 <code>flutter_boost</code> 实现的混合开发，限制了 <code>Flutter</code> 的版本，所以我也就没有去实践该方案对我们是否可行</li></ol><h2 id="二、尝试解决"><a href="#二、尝试解决" class="headerlink" title="二、尝试解决"></a>二、尝试解决</h2><p>根据自己的实际情况，我选择了上述的第二个解决方案。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>用 <code>Xcode</code> 打开工程项目，在 <code>Build Settings</code> 的最下方找到 <code>User-Defined</code>，点击 <code>+</code> 按钮，添加一个键为 <code>FLUTTER_BUILD_MODE</code> ，值为 <code>release</code> 的配置。</p><p><img src= "/img/loading.gif" data-src="/images/2020/09/Flutter-低版本在iOS14上遇到的问题与解决方案/01.png" alt=""></p><p><img src= "/img/loading.gif" data-src="/images/2020/09/Flutter-低版本在iOS14上遇到的问题与解决方案/03.png" alt=""></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>再次运行到真机上，断开 <code>Xcode</code> 运行也不会崩溃了</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>真机的问题看似是解决了，但是会有问题</p><p>问题一：<code>release</code> 或 <code>profile</code> 模式下，<code>Flutter</code> 使用的是 <code>AOT</code>，一些功能不能使用，如：代码断点调试，热重载</p><p>问题二：上面也提到了，模拟器只能运行在 <code>debug</code> 模式下，而我们无法避免会在真机和模拟器之间反复切换运行，每次切换就需要手动调整 <code>FLUTTER_BUILD_MODE</code> 的值，十分麻烦</p><p>那有什么好的办法解决上面遇到的问题呢？</p><h2 id="三、优化方案"><a href="#三、优化方案" class="headerlink" title="三、优化方案"></a>三、优化方案</h2><p>其实，真机上的 <code>APP</code> 在断开 <code>Xcode</code> 后无法运行，这个对我们开发者来说不是什么问题，问题是给到测试人员就必须要可以打开才行，包括蒲公英上的包，所以为了节省这些不必要的时间，我们需要自己动手撸一个帮助我们切换 <code>Flutter编译模式</code> 的脚本。</p><p>在修改 <code>FLUTTER_BUILD_MODE</code> 的值时，我从 <code>git</code> 中发现，实际上是修改了 <code>项目.xcodeproj</code>，那目前有什么工具可以帮助我们修改 <code>xcodeproj</code> 文件呢？</p><p>这里我找到了<a href="https://github.com/kronenthaler/mod-pbxproj" target="_blank" rel="noopener">mod-pbxproj</a>，安装和使用在该库的 <code>wiki</code> 上写的很清楚，这里就不再赘述了，直接上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pbxproj <span class="keyword">import</span> XcodeProject</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    argv = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment"># 处理flutter_build_mode</span></span><br><span class="line">    flutter_build_mode = (<span class="literal">False</span>, <span class="string">"release"</span>)</span><br><span class="line">    <span class="comment"># target名称</span></span><br><span class="line">    target_name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(argv, <span class="string">"p:m:t:"</span>, [<span class="string">"path=, mode=, target="</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">        print(<span class="string">'switch_flutter_build_mode.py -p "plist文件路径" -m "模式(release|debug)" -t "target名称"'</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> [<span class="string">"-p"</span>, <span class="string">"--path"</span>]:</span><br><span class="line">            project_path = arg</span><br><span class="line">            <span class="keyword">if</span> len(project_path) == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'请输入项目的地址'</span>)</span><br><span class="line">                sys.exit(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> [<span class="string">"-m"</span>, <span class="string">"--mode"</span>]:</span><br><span class="line">            flutter_build_mode = (<span class="literal">True</span>, arg <span class="keyword">if</span> len(arg) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">"release"</span>)</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> [<span class="string">"-t"</span>, <span class="string">"--target"</span>]:</span><br><span class="line">            target_name = arg</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理flutter</span></span><br><span class="line">    <span class="keyword">if</span> flutter_build_mode[<span class="number">0</span>]:</span><br><span class="line">        fileName = project_path.split(<span class="string">"/"</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fileName.endswith(<span class="string">"xcodeproj"</span>):</span><br><span class="line">            print(<span class="string">"请使用-p指定.xcodeproj文件的路径"</span>)</span><br><span class="line">            sys.exit(<span class="number">3</span>)</span><br><span class="line">        project = XcodeProject.load(project_path + <span class="string">'/project.pbxproj'</span>)</span><br><span class="line">        <span class="comment"># 设置 User-Defined (如果target_name是None，则每个target都会设置flag)</span></span><br><span class="line">        project.set_flags(<span class="string">'FLUTTER_BUILD_MODE'</span>, flutter_build_mode[<span class="number">1</span>], target_name)</span><br><span class="line">        project.save()</span><br></pre></td></tr></table></figure><p>使用也很简单，终端直接输入如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python switch_flutter_build_mode.py -p 'xxx/项目.xcodeproj' -t target名称 -m release</span><br></pre></td></tr></table></figure><p>各参数说明</p><table><thead><tr><th>参数</th><th>用途</th></tr></thead><tbody><tr><td>-p</td><td><code>xcodeproj</code> 文件的路径</td></tr><tr><td>-t</td><td><code>target</code> 名称</td></tr><tr><td>-m</td><td>编译模式 ( <code>release</code>、<code>debug</code>、<code>profile</code> )</td></tr></tbody></table><p>PS: 脚本基于 <code>Python3</code> </p><p>我们是使用 <code>Jenkins</code> 进行打包并自动上传至蒲公英的，所以只需要在 <code>Jenkins</code> 中配置打包前调用该脚本即可。</p><p>最后再结合 <a href="http://fitztrev.github.io/shuttle/" target="_blank" rel="noopener">Shuttle</a> 这个软件，就可以实现以界面的方式去切换编译模式了</p><p><img src= "/img/loading.gif" data-src="/images/2020/09/Flutter-低版本在iOS14上遇到的问题与解决方案/02.png" alt=""></p><h2 id="四、最后说两句"><a href="#四、最后说两句" class="headerlink" title="四、最后说两句"></a>四、最后说两句</h2><p>本文是基于 <code>Flutter混合开发</code> 进行说明的，如果有什么不对或不足的地方，欢迎指正，感谢大家的阅读</p>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;近期将测试机升级至 iOS14 ，测试使用 Flutter混合开发 的线上 APP，没发现什么问题，但是使用 Xcode 安装APP 的场景下，断开 Xcode 后再运行却闪退了。&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="Flutter" scheme="http://linxunfeng.top/categories/Flutter/"/>
    
    
    <category term="Dart" scheme="http://linxunfeng.top/tags/Dart/"/>
    
    <category term="Flutter" scheme="http://linxunfeng.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>分享 - Flutter打造好用的打印工具类</title>
    <link href="http://linxunfeng.top/2020/09/11/Share/%E5%88%86%E4%BA%AB%20-%20Flutter%E6%89%93%E9%80%A0%E5%A5%BD%E7%94%A8%E7%9A%84%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://linxunfeng.top/2020/09/11/Share/%E5%88%86%E4%BA%AB%20-%20Flutter%E6%89%93%E9%80%A0%E5%A5%BD%E7%94%A8%E7%9A%84%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-09-11T00:00:00.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。</p><p>+<a id="more"></a></p><The rest of contents | 余下全文><h2 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h2><p>做 <code>iOS</code> 开发的同学都知道，我们在平时开发过程中，经常会用到非常实用的自定义打印功能，方便我们快速定位是在哪个控制器，哪一行代码。</p><p> 在 <code>OC</code> 和 <code>Swift</code> 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，这里以 <code>Swift</code> 的打印为例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LogType</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> error = <span class="string">"❤️ ERROR"</span></span><br><span class="line">    <span class="keyword">case</span> warning = <span class="string">"💛 WARNING"</span></span><br><span class="line">    <span class="keyword">case</span> info = <span class="string">"💙 INFO"</span></span><br><span class="line">    <span class="keyword">case</span> debug = <span class="string">"💚 DEBUG"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = <span class="type">Logger</span>.shared</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Logger</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> logDateFormatter: <span class="type">DateFormatter</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> f = <span class="type">DateFormatter</span>()</span><br><span class="line">        f.dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span></span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">error</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">        file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">        function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">        line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="type">LXFLog</span>(message, type: .error, file : file, function: function, line: line)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">warning</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">        file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">        function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">        line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="type">LXFLog</span>(message, type: .warning, file : file, function: function, line: line)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">info</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">        file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">        function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">        line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="type">LXFLog</span>(message, type: .info, file : file, function: function, line: line)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">debug</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">        file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">        function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">        line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="type">LXFLog</span>(message, type: .debug, file : file, function: function, line: line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK:- 自定义打印方法</span></span><br><span class="line"><span class="comment">// target -&gt; Build Settings 搜索 Other Swift Flags</span></span><br><span class="line"><span class="comment">// 设置Debug 添加 -D DEBUG</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LXFLog</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">    type: LogType,</span></span></span><br><span class="line"><span class="function"><span class="params">    file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">    function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">    line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">    <span class="keyword">let</span> time = <span class="type">Logger</span>.logDateFormatter.string(from: <span class="type">Date</span>())</span><br><span class="line">    <span class="keyword">let</span> fileName = (file.description <span class="keyword">as</span> <span class="type">NSString</span>).lastPathComponent</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(time) \(type.rawValue) \(fileName):(\(line))-\(message)"</span>)</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用及打印结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">"models count -- \(models.count)"</span>)</span><br><span class="line">log.warning(<span class="string">"models count -- \(models.count)"</span>)</span><br><span class="line">log.info(<span class="string">"models count -- \(models.count)"</span>)</span><br><span class="line">log.error(<span class="string">"models count -- \(models.count)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">💚 DEBUG XXXViewController.swift:(79)-models count -- 10</span></span><br><span class="line"><span class="comment">💛 WARNING XXXViewController.swift:(80)-models count -- 10</span></span><br><span class="line"><span class="comment">💙 INFO XXXViewController.swift:(81)-models count -- 10</span></span><br><span class="line"><span class="comment">❤️ ERROR XXXViewController.swift:(82)-models count -- 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>OC</code> 和 <code>Swift</code> 的预处理宏对应表</p><table><thead><tr><th>OC</th><th>Swift</th><th></th></tr></thead><tbody><tr><td>__FILE__</td><td>#file</td><td>打印当前文件路径</td></tr><tr><td>__LINE__</td><td>#line</td><td>打印当前行号，整数</td></tr><tr><td>__FUNCTION__</td><td>#function</td><td>打印当前函数或方法</td></tr></tbody></table><p>但是在 <code>Dart</code> 中并没有提供这些功能，但是这个功能对我们来说确实又非常需要，那有什么办法实现它呢？</p><center><br>  <span style="font-size:300px; text-alignment:center">🤔</span><br></center><p>我们回想在开发过程中，是不是发现只要一不小心抛异常，就可以看到类似如下的打印内容，而且还能清楚的知道异常是在哪个文件和哪一行的代码造成的。</p><p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/抛异常.png" alt=""></p><blockquote><p>所以如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。</p></blockquote><h2 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h2><p>在 <code>dart:core</code> 中提供了 <code>堆栈跟踪(StackTrace)</code>，可以通过 <code>StackTrace.current</code> 取到当前的堆栈信息，打印如下图所示，会发现这不好拿到我们想要的信息。</p><p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/StackTrace.png" alt=""></p><p>这里我用到了官方开发的一个包 <a href="https://pub.dev/packages/stack_trace" target="_blank" rel="noopener">stack_trace</a>，它可以将堆栈信息变得更多人性化，并方便我们查看堆栈信息和获取想要的数据。</p><p><strong>ps: <code>stack_trace</code> 在 <code>Flutter</code> 环境下直接导包即可使用，而在纯 <code>Dart</code> 下需要将其添加为依赖于<code>pubspec.yaml</code>中。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">stack_trace:</span> <span class="string">^1.9.3</span></span><br></pre></td></tr></table></figure><p>那下面我们来试试 <a href="https://pub.dev/packages/stack_trace" target="_blank" rel="noopener">stack_trace</a> 的威力吧<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:stack_trace/stack_trace.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 StackTrace 对象转换成 Chain 对象</span></span><br><span class="line"><span class="comment">// 当然，这里也可以直接用 Chain.current();</span></span><br><span class="line"><span class="comment">// final chain = Chain.current();</span></span><br><span class="line"><span class="keyword">final</span> chain = Chain.forTrace(StackTrace.current);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chain);</span><br></pre></td></tr></table></figure></p><p>打印内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flutter: package:flutter_test1/main.dart <span class="number">79</span>:<span class="number">17</span>       _MyHomePageState.test_print</span><br><span class="line">package:flutter_test1/main.dart <span class="number">38</span>:<span class="number">5</span>                 _MyHomePageState._incrementCounter</span><br><span class="line">package:flutter/src/material/ink_well.dart <span class="number">779</span>:<span class="number">19</span>    _InkResponseState._handleTap</span><br><span class="line">package:flutter/src/material/ink_well.dart <span class="number">862</span>:<span class="number">36</span>    _InkResponseState.build.&lt;fn&gt;</span><br><span class="line">package:flutter/src/gestures/recognizer.dart <span class="number">182</span>:<span class="number">24</span>  GestureRecognizer.invokeCallback</span><br><span class="line">package:flutter/src/gestures/tap.dart <span class="number">504</span>:<span class="number">11</span>         TapGestureRecognizer.handleTapUp</span><br><span class="line">package:flutter/src/gestures/tap.dart <span class="number">282</span>:<span class="number">5</span>          BaseTapGestureRecognizer._checkUp</span><br><span class="line">package:flutter/src/gestures/tap.dart <span class="number">254</span>:<span class="number">7</span>          BaseTapGestureRecognizer.acceptGesture</span><br><span class="line">package:flutter/src/gestures/arena.dart <span class="number">156</span>:<span class="number">27</span>       GestureArenaManager.sweep</span><br><span class="line">package:flutter/src/gestures/binding.dart <span class="number">222</span>:<span class="number">20</span>     GestureBinding.handleEvent</span><br><span class="line">package:flutter/src/gestures/binding.dart <span class="number">198</span>:<span class="number">22</span>     GestureBinding.dispatchEvent</span><br><span class="line">package:flutter/src/gestures/binding.dart <span class="number">156</span>:<span class="number">7</span>      GestureBinding._handle&lt;…&gt;</span><br></pre></td></tr></table></figure><p>工具代码雏形：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:stack_trace/stack_trace.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 StackTrace 对象转换成 Chain 对象</span></span><br><span class="line"><span class="comment">// 当然，这里也可以直接用 Chain.current();</span></span><br><span class="line"><span class="keyword">final</span> chain = Chain.forTrace(StackTrace.current);</span><br><span class="line"><span class="comment">// 拿出其中一条信息</span></span><br><span class="line"><span class="keyword">final</span> frames = chain.toTrace().frames;</span><br><span class="line"><span class="keyword">final</span> frame = frames[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"所在文件：<span class="subst">$&#123;frame.uri&#125;</span> 所在行 <span class="subst">$&#123;frame.line&#125;</span> 所在列 <span class="subst">$&#123;frame.column&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// flutter: 所在文件：package:flutterlog/main.dart 所在行 55 所在列 23</span></span><br></pre></td></tr></table></figure><p><code>Frame</code> 类的属性</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A single stack frame. Each frame points to a precise location in Dart code.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">The URI of the file in which the code is located.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This URI will usually have the scheme <span class="code">`dart`</span>, <span class="code">`file`</span>, <span class="code">`http`</span>, or <span class="code">`https`</span>.</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Uri</span> uri;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The line number on which the code location is located.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This can be null, indicating that the line number is unknown or</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">unimportant.</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> line;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// <span class="markdown">The name of the member in which the code location occurs.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Anonymous closures are represented as <span class="code">`&lt;fn&gt;`</span> in this member string.</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> member;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>uri</code> : 获取代码所在文件的路径</li><li><code>line</code> : 获取代码所在行</li><li><code>member</code> : 获取所在方法</li></ul><p>打印看一下 :</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uri</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;frame.uri.toString()&#125;</span>"</span>);  <span class="comment">// package:flutter_test1/main.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// member</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;frame.member&#125;</span>"</span>); <span class="comment">// _MyHomePageState.scheduleAsync.&lt;fn&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// line</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;frame.line&#125;</span>"</span>); <span class="comment">// 97</span></span><br></pre></td></tr></table></figure><h2 id="三、呈上代码"><a href="#三、呈上代码" class="headerlink" title="三、呈上代码"></a>三、呈上代码</h2><p>下面我做了一点封装，直接拿走即可使用，完整的代码和示例请到GitHub上<a href="https://github.com/LinXunFeng/flutter_log" target="_blank" rel="noopener">【查看】</a>。</p><p>代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> FLogMode &#123;</span><br><span class="line">  debug,    <span class="comment">// 💚 DEBUG</span></span><br><span class="line">  warning,  <span class="comment">// 💛 WARNING</span></span><br><span class="line">  info,     <span class="comment">// 💙 INFO</span></span><br><span class="line">  error,    <span class="comment">// ❤️ ERROR</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FLog(<span class="built_in">dynamic</span> msg, &#123; FLogMode mode = FLogMode.debug &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kReleaseMode) &#123; <span class="comment">// release模式不打印</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> chain = Chain.current(); <span class="comment">// Chain.forTrace(StackTrace.current);</span></span><br><span class="line">  <span class="comment">// 将 core 和 flutter 包的堆栈合起来（即相关数据只剩其中一条）</span></span><br><span class="line">  chain = chain.foldFrames((frame) =&gt; frame.isCore || frame.package == <span class="string">"flutter"</span>);</span><br><span class="line">  <span class="comment">// 取出所有信息帧</span></span><br><span class="line">  <span class="keyword">final</span> frames = chain.toTrace().frames;</span><br><span class="line">  <span class="comment">// 找到当前函数的信息帧</span></span><br><span class="line">  <span class="keyword">final</span> idx = frames.indexWhere((element) =&gt; element.member == <span class="string">"FLog"</span>);</span><br><span class="line">  <span class="keyword">if</span> (idx == <span class="number">-1</span> || idx+<span class="number">1</span> &gt;= frames.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用当前函数的函数信息帧</span></span><br><span class="line">  <span class="keyword">final</span> frame = frames[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> modeStr = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">switch</span>(mode) &#123;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.debug:</span><br><span class="line">      modeStr = <span class="string">"💚 DEBUG"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.warning:</span><br><span class="line">      modeStr = <span class="string">"💛 WARNING"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.info:</span><br><span class="line">      modeStr = <span class="string">"💙 INFO"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.error:</span><br><span class="line">      modeStr = <span class="string">"❤️ ERROR"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$modeStr</span> <span class="subst">$&#123;frame.uri.toString().split(<span class="string">"/"</span>).last&#125;</span>(<span class="subst">$&#123;frame.line&#125;</span>) - <span class="subst">$msg</span> "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用FLog</span></span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mode：打印模式（默认值为debug）</span></span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>, mode: FLogMode.debug);</span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>, mode: FLogMode.warning);</span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>, mode: FLogMode.info);</span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>, mode: FLogMode.error);</span><br></pre></td></tr></table></figure><p>打印效果如下所示：</p><p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/打印效果.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="Share" scheme="http://linxunfeng.top/categories/Share/"/>
    
    
    <category term="Dart" scheme="http://linxunfeng.top/tags/Dart/"/>
    
    <category term="Flutter" scheme="http://linxunfeng.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>解决 Could not find &#39;faraday&#39; ...  gem(s) (Gem::LoadError)</title>
    <link href="http://linxunfeng.top/2020/08/29/iOS/%E8%A7%A3%E5%86%B3%20Could%20not%20find%20faraday%20...%20%20gem(s)%20(Gem%20LoadError)/"/>
    <id>http://linxunfeng.top/2020/08/29/iOS/%E8%A7%A3%E5%86%B3%20Could%20not%20find%20faraday%20...%20%20gem(s)%20(Gem%20LoadError)/</id>
    <published>2020-08-29T17:27:00.000Z</published>
    <updated>2021-01-31T14:26:32.817Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>`to_specs’: Could not find ‘faraday’ (&gt;= 0.7.4) among 77 total gem(s) (Gem::LoadError)</p><p>+<a id="more"></a></p><The rest of contents | 余下全文><h2 id="一、遇到的问题"><a href="#一、遇到的问题" class="headerlink" title="一、遇到的问题"></a>一、遇到的问题</h2><p>报错内容如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/dependency.rb:319:in `to_specs': Could not find 'faraday' (&gt;= 0.7.4) among 77 total gem(s) (Gem::LoadError)</span><br><span class="line">Checked in 'GEM_PATH=/Users/lxf/.fastlane/bin/bundle/bin:/Users/lxf/.fastlane/bin/bundle/lib/ruby/gems/2.2.0', execute `gem env` for more information</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1439:in `block in activate_dependencies'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `each'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `activate_dependencies'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1410:in `activate'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1442:in `block in activate_dependencies'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `each'</span><br><span class="line">from /Users/xxx/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `activate_dependencies'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1410:in `activate'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems.rb:196:in `rescue in try_activate'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems.rb:193:in `try_activate'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:125:in `rescue in require'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:40:in `require'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/gems/fastlane-2.28.3/bin/fastlane:9:in `&lt;top (required)&gt;'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/bin/fastlane:22:in `load'</span><br><span class="line">from /Users/lxf/.fastlane/bin/bundle/bin/fastlane:22:in `&lt;main&gt;'</span><br></pre></td></tr></table></figure></p><p>在执行 <code>fastlane</code> 命令时遇到了上面那个错误</p><h2 id="二、解决方案："><a href="#二、解决方案：" class="headerlink" title="二、解决方案："></a>二、解决方案：</h2><p>执行如下几行命令即可，解决方案出自: <a href="https://github.com/fastlane/fastlane/issues/15740#issuecomment-560277535" target="_blank" rel="noopener">链接</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rf $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/gems/faraday-0.*</span><br><span class="line">rm -rf $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/specifications/faraday-0.*</span><br><span class="line">gem install faraday -v 0.17.0 --install-dir $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0</span><br></pre></td></tr></table></figure></p><p>接着再执行 <code>fastlane</code> 命令试试看吧~</p>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;`to_specs’: Could not find ‘faraday’ (&amp;gt;= 0.7.4) among 77 total gem(s) (Gem::LoadError)&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="iOS" scheme="http://linxunfeng.top/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://linxunfeng.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Flutter - 解决混合开发iOS脚本打包遇到的问题</title>
    <link href="http://linxunfeng.top/2020/08/12/Flutter/Flutter%20-%20%E8%A7%A3%E5%86%B3%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://linxunfeng.top/2020/08/12/Flutter/Flutter%20-%20%E8%A7%A3%E5%86%B3%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-12T00:00:00.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>使用Xcode手动打包是正常的，但是使用脚本打包会报错</p><p>+<a id="more"></a></p><The rest of contents | 余下全文><p>使用 <code>Xcode</code> 手动打包是正常的，但是使用脚本打包会报错，错误如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The following build commands failed:</span><br><span class="line">PhaseScriptExecution [CP-User]\ Run\ Flutter\ Build\ Script .../Script-C3A097A8FE12FF5F875B057C.sh</span><br><span class="line"></span><br><span class="line">flutter build ios --release</span><br><span class="line">then re-run Archive from Xcode.</span><br><span class="line">Command PhaseScriptExecution failed with a nonzero exit code</span><br></pre></td></tr></table></figure><h2 id="定位错误"><a href="#定位错误" class="headerlink" title="定位错误"></a>定位错误</h2><p><img src= "/img/loading.gif" data-src="/images/2020/08/Flutter-解决混合开发iOS脚本打包遇到的问题/01.png" alt=""></p><p>到 <code>Flutter</code> 环境目录下，按图上所示地址找到 <code>xcode_backend.sh</code>，也可以直接看 <a href="https://github.com/flutter/flutter/blob/bcc42901ad6bb3ec644be225b5f9cd998852e0ef/packages/flutter_tools/bin/xcode_backend.sh#L90-L101" target="_blank" rel="noopener">官方脚本链接</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Archive builds (ACTION=install) should always run <span class="keyword">in</span> release mode.</span></span><br><span class="line">if [[ "$ACTION" == "install" &amp;&amp; "$build_mode" != "release" ]]; then</span><br><span class="line">  EchoError "========================================================================"</span><br><span class="line">  EchoError "ERROR: Flutter archive builds must be run in Release mode."</span><br><span class="line">  EchoError ""</span><br><span class="line">  EchoError "To correct, ensure FLUTTER_BUILD_MODE is set to release or run:"</span><br><span class="line">  EchoError "flutter build ios --release"</span><br><span class="line">  EchoError ""</span><br><span class="line">  EchoError "then re-run Archive from Xcode."</span><br><span class="line">  EchoError "========================================================================"</span><br><span class="line">  exit -1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>可以看到，官方脚本的说明里面给出两个解决方案</p><blockquote><p>方案一：直接设置 <code>FLUTTER_BUILD_MODE</code> 为 <code>release</code></p><p>方案二：先运行 <code>flutter build ios --release</code> ，再使用 <code>Xcode</code> 去打包</p></blockquote><p>这里我们是用 <code>Jenkins</code> 脚本进行打包，所以方案二不适用，方案一更加方便些</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置Flutter的编译模式为release</span></span><br><span class="line">export FLUTTER_BUILD_MODE=release</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行原有项目的打包脚本</span></span><br><span class="line">./script/build_iOS.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;使用Xcode手动打包是正常的，但是使用脚本打包会报错&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="Flutter" scheme="http://linxunfeng.top/categories/Flutter/"/>
    
    
    <category term="Dart" scheme="http://linxunfeng.top/tags/Dart/"/>
    
    <category term="Flutter" scheme="http://linxunfeng.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter - 混合开发</title>
    <link href="http://linxunfeng.top/2020/07/12/Flutter/Flutter%20-%20%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>http://linxunfeng.top/2020/07/12/Flutter/Flutter%20-%20%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/</id>
    <published>2020-07-12T00:00:00.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>目前大多数公司都有自己开发多年的项目，不可能直接用 <code>Flutter</code> 从头开发一套，那样不实现，除非是小项目，因此只能是在原有的基础上用 <code>Flutter</code> 来开发新业务或重构旧业务，而这里就需要用到 <code>Flutter</code> 的 <code>混合开发</code></p><p>+<a id="more"></a></p><The rest of contents | 余下全文><blockquote><p>目前大多数公司都有自己开发多年的项目，不可能直接用 <code>Flutter</code> 从头开发一套，那样不实现，除非是小项目，因此只能是在原有的基础上用 <code>Flutter</code> 来开发新业务或重构旧业务，而这里就需要用到 <code>Flutter</code> 的 <code>混合开发</code></p></blockquote><h3 id="一、创建Flutter模块"><a href="#一、创建Flutter模块" class="headerlink" title="一、创建Flutter模块"></a>一、创建Flutter模块</h3><p>使用混合开发就不能像之前一样直接上来就创建一个 <code>Flutter</code> 项目，而是要使用 <code>Flutter模板</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> flutter_module_lxf 可以随便你命名</span></span><br><span class="line">flutter create --template module flutter_module_lxf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --template 可以替换为 -t</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> flutter create -t module flutter_module_lxf</span></span><br></pre></td></tr></table></figure><p>创建出来的 <code>Flutter</code> 模块依然是可以像之前创建的<code>Flutter项目</code> 一样打开和运行的。 </p><p>目录下有也有 <code>ios</code> 和 <code>android</code> 目录，只不过前面加了个点 ，成了点目录。</p><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS01.png" alt=""></p><h2 id="二、iOS"><a href="#二、iOS" class="headerlink" title="二、iOS"></a>二、iOS</h2><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><blockquote><p>通过 <code>Cocoapods</code> ，将 <code>Flutter</code> 模块编译成一个库，再到原生项目中进行引入和使用即可</p></blockquote><p>在 <code>Podfile</code> 中添加两行配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定我们刚刚创建的 Flutter 模块的路径</span></span><br><span class="line">flutter_application_path = <span class="string">'../flutter_module_lxf'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接脚本文件的路径: .ios/Flutter/podhelper.rb</span></span><br><span class="line">load File.join(flutter_application_path, <span class="string">'.ios'</span>, <span class="string">'Flutter'</span>, <span class="string">'podhelper.rb'</span>)</span><br></pre></td></tr></table></figure><p>在每个需要引用 <code>Flutter</code> 的 <code>Target</code> 下，都需要添加一行配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install_all_flutter_pods(flutter_application_path)</span><br></pre></td></tr></table></figure><p>添加后如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flutter_application_path = <span class="string">'../flutter_module_lxf'</span></span><br><span class="line">load File.join(flutter_application_path, <span class="string">'.ios'</span>, <span class="string">'Flutter'</span>, <span class="string">'podhelper.rb'</span>)</span><br><span class="line"></span><br><span class="line">use_frameworks!</span><br><span class="line">target <span class="string">'LXFFlutterHybridDemo'</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">  install_all_flutter_pods(flutter_application_path)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>添加完成后，执行一次 <code>pod install</code></p><p>混合开发混合开发<img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS02.png" alt=""></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>两个步骤</p><ol><li>获取 Flutter引擎 <code>FlutterEngine</code></li><li>通过 <code>FlutterEngine</code> 创建 <code>FlutterViewController</code></li></ol></blockquote><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>AppDelegate</code> 类中声明一个 <code>FlutterEngine</code> 变量，在 <code>didFinishLaunchingWithOptions</code> 方法中启动 <code>Flutter引擎</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Flutter</span><br><span class="line"></span><br><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建 Flutter引擎</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> flutterEngine = <span class="type">FlutterEngine</span>(name: <span class="string">"lxf"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动 Flutter引擎</span></span><br><span class="line">        flutterEngine.run()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>ViewController</code> 中添加一个按钮，点击弹出 <code>Flutter模块</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> btn = <span class="type">UIButton</span>(type: .custom)</span><br><span class="line">  btn.frame = <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">200</span>, width: <span class="number">200</span>, height: <span class="number">44</span>)</span><br><span class="line">  btn.backgroundColor = .black</span><br><span class="line">  btn.addTarget(<span class="keyword">self</span>, action: #selector(showFlutterVc), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">  btn.setTitle(<span class="string">"弹出Flutter模块"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">  <span class="keyword">self</span>.view.addSubview(btn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">showFlutterVc</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建FlutterViewController</span></span><br><span class="line">  <span class="comment">// 这里的 engine 可以传 nil，Flutter会帮我们自动创建一个引擎，但是性能较差</span></span><br><span class="line">  <span class="keyword">let</span> flutterVc = <span class="type">FlutterViewController</span>(engine: fetchFlutterEngine(), nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">self</span>.present(flutterVc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchFlutterEngine</span><span class="params">()</span></span> -&gt; <span class="type">FlutterEngine</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">UIApplication</span>.shared.delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span>).flutterEngine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS04.jpg" alt=""></p><p>如果遇到报 <code>Command PhaseScriptExecution failed with a nonzero exit code</code> 错误，如下图所示：</p><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS03.png" alt=""></p><p>请先用 <code>Android Studio</code> 或 <code>VSCode</code> 打开 <code>Flutter模块</code> 项目并运行到iOS设备上，让其帮我们对iOS项目进行一些初始化配置。成功运行后就可以关闭 <code>Flutter模块</code> 项目的运行了，接着再用 <code>Xcode</code> 打开原生项目运行即可。</p><h4 id="修改初始路由"><a href="#修改初始路由" class="headerlink" title="修改初始路由"></a>修改初始路由</h4><p>官方文档里面提到，修改初始路由，需要在 <code>Flutter引擎</code> 在 <code>run</code> 之前，通过 <code>invokeMethod</code> 调用 <code>setInitialRoute</code> 方法进行设置，代码如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改初始路由</span></span><br><span class="line">flutterEngine.navigationChannel.invokeMethod(<span class="string">"setInitialRoute"</span>, arguments: <span class="string">"/other"</span>)</span><br><span class="line"><span class="comment">// 启动 Flutter引擎</span></span><br><span class="line">flutterEngine.run()</span><br></pre></td></tr></table></figure><p>但是，我发现这样写并没有起任何作用，在 <code>Flutter</code> 的官方 <code>issue</code> 上也有人提到这个问题： <a href="https://github.com/flutter/flutter/issues/59895" target="_blank" rel="noopener">【setInitialRoute is broken for iOS add-to-app #59895】</a>，目前只能官方进行修复和调整 <code>API</code></p><p>临时可以使用如下方式实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flutterVc = <span class="type">FlutterViewController</span>(project: <span class="type">FlutterDartProject</span>(), nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">flutterVc.setInitialRoute(<span class="string">"/other"</span>)</span><br><span class="line"><span class="keyword">self</span>.present(flutterVc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>虽然这么写可以实现这个功能，但是会有明显的类似卡顿的现象，因为使用这种方式去创建 <code>FlutterViewController</code> 之前，会隐式创建和启动一个 <code>FlutterEngine</code>，而我们弹出 <code>FlutterViewController</code> 时 <code>FlutterEngine</code> 还没加载完毕，所以我们会看到先弹出了一个透明的界面，再显示 <code>/other</code> 路由对应的界面视图。</p><h4 id="使用-FlutterAppDelegate"><a href="#使用-FlutterAppDelegate" class="headerlink" title="使用 FlutterAppDelegate"></a>使用 FlutterAppDelegate</h4><p>使用 <code>FlutterAppDelegate</code>这个不是必要的操作，但是如果你想让 <code>Flutter模块</code> 也能使用原生的功能的话，建议使用</p><blockquote><p> 原生功能</p><ul><li>处理 <code>openURL</code> 的回调</li><li>列表视图在点击状态栏后滚到顶部</li></ul></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">FlutterAppDelegate</span></span></span><br></pre></td></tr></table></figure><p>更具体的使用，请阅读 <a href="https://flutter.dev/docs/development/add-to-app/ios/add-flutter-screen?tab=no-engine-vc-swift-tab#using-the-flutterappdelegate" target="_blank" rel="noopener">官方文档</a></p><h2 id="三、Android"><a href="#三、Android" class="headerlink" title="三、Android"></a>三、Android</h2><p>修改安卓项目 根目录下的 <code>settings.gradle</code> 文件 </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line"></span><br><span class="line">include <span class="string">':app'</span>                                    <span class="comment">// assumed existing content</span></span><br><span class="line">setBinding(<span class="keyword">new</span> Binding([<span class="string">gradle:</span> <span class="keyword">this</span>]))                                <span class="comment">// new</span></span><br><span class="line">evaluate(<span class="keyword">new</span> File(                                                     <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                              <span class="comment">// new</span></span><br><span class="line">  <span class="comment">// 这里的 flutter_module_lxf 请修改为你自己创建的Flutter模板目录名称</span></span><br><span class="line">  <span class="string">'flutter_module_lxf/.android/include_flutter.groovy'</span>                 <span class="comment">// new</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS09.png" alt=""></p><p>修改安卓项目 <code>app</code> 目录下的 <code>build.gradle</code> 文件 </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/build.gradle</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置flutter依赖</span></span><br><span class="line">  implementation project(<span class="string">':flutter'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在编译的时候遇到如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Default interface methods are only supported starting with Android N (--min-api 24): void androidx.lifecycle.DefaultLifecycleObserver.onCreate(androidx.lifecycle.LifecycleOwner)</span><br></pre></td></tr></table></figure><p>请确认是否指定了使用 <code>Java 8</code> 进行编译 <a href="https://flutter.dev/docs/development/add-to-app/android/project-setup#java-8-requirement" target="_blank" rel="noopener">【官方文档 -  Java 8 requirement】</a></p><p>修改安卓项目  <code>app</code> 目录下的 <code>build.gradle</code> 文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;build.gradle</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">      sourceCompatibility 1.8</span><br><span class="line">      targetCompatibility 1.8</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS08.png" alt=""></p><p>修改 <code>app/src/main/AndroidManifest.xml</code> 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// app/src/main/AndroidManifest.xml</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">"io.flutter.embedding.android.FlutterActivity"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:hardwareAccelerated</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:windowSoftInputMode</span>=<span class="string">"adjustResize"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS10.png" alt=""></p><p>添加一个按钮，点击弹出 <code>Flutter模块</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  activity_main.xml  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/btn"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"弹出Flutter模块"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"#000000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">"#ffffff"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">"btnClick"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btnClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    startActivity(</span><br><span class="line">        FlutterActivity.createDefaultIntent(<span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、调试与热重载"><a href="#四、调试与热重载" class="headerlink" title="四、调试与热重载"></a>四、调试与热重载</h2><blockquote><p>由于当前我们是使用原生开发工具(如：Xcode)来运行项目，每次修改我们的<br> <code>Flutter模块</code> 的代码，也就需要重新运行才能看到效果，不像之前按下 <code>Cmd + s</code> 就能进行热重载。这样 <code>Flutter模块</code> 的开发效率极其低下，那有没有办法可以让我们像之前开发 <code>Flutter</code> 项目时那样进行 <code>热重载</code> 呢？答案是有的</p></blockquote><p><code>Flutter</code> 官方提供了 <code>flutter attach</code> ，以辅助我们开发，到终端下执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter attach</span><br></pre></td></tr></table></figure><p>如果当前有多个设备，会提示我们需要指定 <code>attach</code> 哪个设备</p><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS05.png" alt=""></p><p>按要求加上指定参数即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter attach -d FE305309-9E79-418D-BA3F-7EFECF2980BC</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS06.png" alt=""></p><p>如图，这样就关联上了，你在 <code>dart</code> 文件里面对界面进行任何修改后，按 <code>r</code> 进行热重载，按 <code>R</code> 进行热启动。</p><p>如果你使用的是 <code>Android Studio</code>，可以直接选择对应的设备后，点击右边的 <code>Flutter Attach</code> 按钮，执行成功后就可以跟之前一样按 <code>Cmd + s</code> 进行热重载了。</p><p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS07.png" alt=""></p><h2 id="五、资料"><a href="#五、资料" class="headerlink" title="五、资料"></a>五、资料</h2><ul><li><p>GitHub</p><p><a href="https://github.com/LinXunFeng/LXFFlutterHybridDemo" target="_blank" rel="noopener">LXFFlutterHybridDemo</a></p></li><li><p>官方文档</p><p><a href="https://flutter.dev/docs/development/add-to-app" target="_blank" rel="noopener">add-to-app</a> | <a href="https://flutter.dev/docs/development/add-to-app/ios" target="_blank" rel="noopener">add-to-app/ios</a> | <a href="https://flutter.dev/docs/development/add-to-app/android" target="_blank" rel="noopener">add-to-app/android</a> |  <a href="https://flutter.dev/docs/development/add-to-app/debugging" target="_blank" rel="noopener">Debugging &amp; hot reload</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;目前大多数公司都有自己开发多年的项目，不可能直接用 &lt;code&gt;Flutter&lt;/code&gt; 从头开发一套，那样不实现，除非是小项目，因此只能是在原有的基础上用 &lt;code&gt;Flutter&lt;/code&gt; 来开发新业务或重构旧业务，而这里就需要用到 &lt;code&gt;Flutter&lt;/code&gt; 的 &lt;code&gt;混合开发&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="Flutter" scheme="http://linxunfeng.top/categories/Flutter/"/>
    
    
    <category term="Dart" scheme="http://linxunfeng.top/tags/Dart/"/>
    
    <category term="Flutter" scheme="http://linxunfeng.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter - 打印好用的Debug日志</title>
    <link href="http://linxunfeng.top/2020/06/26/Flutter/Flutter%20-%20%E6%89%93%E5%8D%B0%E5%A5%BD%E7%94%A8%E7%9A%84Debug%E6%97%A5%E5%BF%97/"/>
    <id>http://linxunfeng.top/2020/06/26/Flutter/Flutter%20-%20%E6%89%93%E5%8D%B0%E5%A5%BD%E7%94%A8%E7%9A%84Debug%E6%97%A5%E5%BF%97/</id>
    <published>2020-06-26T00:35:00.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>做 <code>iOS</code> 开发时这个功能很常用， 在 <code>OC</code> 和 <code>Swift</code> 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，但是在 <code>Dart</code> 中并不提供这些，那有什么办法实现它呢？</p><p>+<a id="more"></a></p><The rest of contents | 余下全文><h2 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h2><p>做 <code>iOS</code> 开发时这个功能很常用， 在 <code>OC</code> 和 <code>Swift</code> 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，但是在 <code>Dart</code> 中并不提供这些，那有什么办法实现它呢？</p><p>我们回想在开发过程中，是不是发现只要一不小心抛异常，就可以看到类似如下的打印内容，而且还能清楚的知道异常是在哪个文件和哪一行的代码造成的。</p><p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/抛异常.png" alt=""></p><blockquote><p>所以如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。</p></blockquote><h2 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h2><p>在 <code>dart:core</code> 中提供了 <code>堆栈跟踪(StackTrace)</code>，可以通过 <code>StackTrace.current</code> 取到当前的堆栈信息，打印如下图所示，会发现这不好拿到我们想要的信息。</p><p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/StackTrace.png" alt=""></p><p>这里我用到了官方开发的一个包 <a href="https://pub.dev/packages/stack_trace" target="_blank" rel="noopener">stack_trace</a>，它可以将堆栈信息变得更多人性化，并方便我们查看堆栈信息和获取想要的数据。</p><p><strong>ps: <code>stack_trace</code> 在 <code>Flutter</code> 环境下直接导包即可使用，而在纯 <code>Dart</code> 下需要将其添加为依赖于<code>pubspec.yaml</code>中。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">stack_trace:</span> <span class="string">^1.9.3</span></span><br></pre></td></tr></table></figure><p>那下面我们来试试 <a href="https://pub.dev/packages/stack_trace" target="_blank" rel="noopener">stack_trace</a> 的威力吧<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:stack_trace/stack_trace.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 StackTrace 对象转换成 Chain 对象</span></span><br><span class="line"><span class="comment">// 当然，这里也可以直接用 Chain.current();</span></span><br><span class="line"><span class="keyword">final</span> chain = Chain.forTrace(StackTrace.current);</span><br><span class="line"><span class="comment">// 拿出其中一条信息</span></span><br><span class="line"><span class="keyword">final</span> frames = chain.toTrace().frames;</span><br><span class="line"><span class="keyword">final</span> frame = frames[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"所在文件：<span class="subst">$&#123;frame.uri&#125;</span> 所在行 <span class="subst">$&#123;frame.line&#125;</span> 所在列 <span class="subst">$&#123;frame.column&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// flutter: 所在文件：package:flutterlog/main.dart 所在行 55 所在列 23</span></span><br></pre></td></tr></table></figure></p><h2 id="三、呈上代码"><a href="#三、呈上代码" class="headerlink" title="三、呈上代码"></a>三、呈上代码</h2><p>下面我做了一点封装，直接拿走即可使用，打印效果如下所示：</p><p>完整的代码和示例请到GitHub上<a href="https://github.com/LinXunFeng/flutter_log" target="_blank" rel="noopener">【查看】</a>。</p><p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/打印效果.png" alt=""></p><p>代码：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> FLogMode &#123;</span><br><span class="line">  debug,    <span class="comment">// 💚 DEBUG</span></span><br><span class="line">  warning,  <span class="comment">// 💛 WARNING</span></span><br><span class="line">  info,     <span class="comment">// 💙 INFO</span></span><br><span class="line">  error,    <span class="comment">// ❤️ ERROR</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FLog(<span class="built_in">dynamic</span> msg, &#123; FLogMode mode = FLogMode.debug &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kReleaseMode) &#123; <span class="comment">// release模式不打印</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> chain = Chain.current(); <span class="comment">// Chain.forTrace(StackTrace.current);</span></span><br><span class="line">  <span class="comment">// 将 core 和 flutter 包的堆栈合起来（即相关数据只剩其中一条）</span></span><br><span class="line">  chain = chain.foldFrames((frame) =&gt; frame.isCore || frame.package == <span class="string">"flutter"</span>);</span><br><span class="line">  <span class="comment">// 取出所有信息帧</span></span><br><span class="line">  <span class="keyword">final</span> frames = chain.toTrace().frames;</span><br><span class="line">  <span class="comment">// 找到当前函数的信息帧</span></span><br><span class="line">  <span class="keyword">final</span> idx = frames.indexWhere((element) =&gt; element.member == <span class="string">"FLog"</span>);</span><br><span class="line">  <span class="keyword">if</span> (idx == <span class="number">-1</span> || idx+<span class="number">1</span> &gt;= frames.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用当前函数的函数信息帧</span></span><br><span class="line">  <span class="keyword">final</span> frame = frames[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> modeStr = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">switch</span>(mode) &#123;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.debug:</span><br><span class="line">      modeStr = <span class="string">"💚 DEBUG"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.warning:</span><br><span class="line">      modeStr = <span class="string">"💛 WARNING"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.info:</span><br><span class="line">      modeStr = <span class="string">"💙 INFO"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.error:</span><br><span class="line">      modeStr = <span class="string">"❤️ ERROR"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$modeStr</span> <span class="subst">$&#123;frame.uri.toString().split(<span class="string">"/"</span>).last&#125;</span>(<span class="subst">$&#123;frame.line&#125;</span>) - <span class="subst">$msg</span> "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;做 &lt;code&gt;iOS&lt;/code&gt; 开发时这个功能很常用， 在 &lt;code&gt;OC&lt;/code&gt; 和 &lt;code&gt;Swift&lt;/code&gt; 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，但是在 &lt;code&gt;Dart&lt;/code&gt; 中并不提供这些，那有什么办法实现它呢？&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="Flutter" scheme="http://linxunfeng.top/categories/Flutter/"/>
    
    
    <category term="Dart" scheme="http://linxunfeng.top/tags/Dart/"/>
    
    <category term="Flutter" scheme="http://linxunfeng.top/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Dart - 抽象类的实例化</title>
    <link href="http://linxunfeng.top/2020/06/07/Flutter/Dart-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/"/>
    <id>http://linxunfeng.top/2020/06/07/Flutter/Dart-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</id>
    <published>2020-06-07T11:27:00.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>抽象类不能用于创建实例，但是有没有发现，<code>Dart</code> 提供的 <code>Map</code> 和 <code>List</code> 就是抽象类，却可以直接使用它们创建出一个实例对象</p><p>+<a id="more"></a></p><The rest of contents | 余下全文><h2 id="一、抽象类的使用"><a href="#一、抽象类的使用" class="headerlink" title="一、抽象类的使用"></a>一、抽象类的使用</h2><p><code>Dart</code> 抽象类可以只声明方法，也可以有具体的方法实现，但是不能直接用抽象类来创建实例，只能被继承使用或者充当接口。</p><p>定义一个抽象类 <code>Animal</code><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 仅声明eat方法</span></span><br><span class="line">  <span class="keyword">void</span> eat();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明方法，且有具体实现</span></span><br><span class="line">  <span class="keyword">void</span> sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继承使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"喵喵吃"</span>);</span><br><span class="line">    sleep();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以不实现 sleep 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>充当接口<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"吃"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必须实现 sleep 方法</span></span><br><span class="line">  <span class="keyword">void</span> sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'睡'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实例化<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> animal = Animal();</span><br><span class="line"><span class="comment">// 抽象类实例化会报错</span></span><br><span class="line"><span class="comment">// Error: The class 'Test' is abstract and can't be instantiated.</span></span><br></pre></td></tr></table></figure></p><blockquote><ul><li>抽象类不能实例化。</li><li>继承: 子类比较实现抽象方法，子类可以不重写抽象类中已实现的方法。</li><li>接口: 必须实现抽象类中声明的所有方法</li></ul></blockquote><h2 id="二、抽象类的实例化"><a href="#二、抽象类的实例化" class="headerlink" title="二、抽象类的实例化"></a>二、抽象类的实例化</h2><p>上面提到了抽象类不能用于创建实例，但是有没有发现，<code>Dart</code> 提供的 <code>Map</code> 和 <code>List</code> 就是抽象类，却可以直接使用它们创建出一个实例对象<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> list = <span class="built_in">List</span>();</span><br><span class="line"><span class="keyword">final</span> dict = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;();</span><br></pre></td></tr></table></figure><br>我们来看一下 <code>Map</code> 的源码：<br><img src= "/img/loading.gif" data-src="/images/2020/06/Dart-抽象类的实例化/Map源码.png" alt="Map源码"></p><p><code>Map</code> 的确是抽象类，不过此时我们也注意到了，在 <code>Map</code> 这个抽象类中，定义了一个工厂构造方法，<strong>这就是使抽象类可实例化的关键所在，因为工厂方法可以返回一个实例对象，但这个对象的类型不一定就是当前类!</strong></p><p>在这个地方，<code>Map</code> 的工厂方法并没有具体的实现，而只是在工厂构造方法前加了一个关键字 <code>external</code>。<br><code>external</code> 关键字可以让方法的声明与实现分离，即 可以由外部来帮我们完成具体的方法实现，那外部如何才能关联到该声明的方法呢？这里就需要用到注解 <code>@patch</code>，使外部的方法实现与该声明的方法绑定</p><blockquote><p><code>external</code> 可以分离方法的声明与实现<br><code>@patch</code> 关联某个类中用 <code>external</code> 修饰的方法的实现</p></blockquote><p>根据如下路径可以找到 <code>Map</code> 的具体实现源码<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/map_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="keyword">factory</span> <span class="built_in">Map</span>() =&gt; <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;();</span><br></pre></td></tr></table></figure></p><p>可以看到，这里使用了 <code>LinkedHashMap</code> 来实现 <code>Map</code> 。</p><p>我们再去看一下 <code>LinkedHashMap</code> 的实现源码，路径如下：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/collection/linked_hash_map.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">external</span> <span class="keyword">factory</span> LinkedHashMap(</span><br><span class="line">    &#123;<span class="built_in">bool</span> <span class="built_in">Function</span>(K, K)? equals,</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">Function</span>(K)? hashCode,</span><br><span class="line">    <span class="built_in">bool</span> <span class="built_in">Function</span>(<span class="built_in">dynamic</span>)? isValidKey&#125;);</span><br></pre></td></tr></table></figure><br>这里我们又发现 <code>LinkedHashMap</code> 也仅仅只是声明，找到具体实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/collection_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">factory</span> LinkedHashMap(</span><br><span class="line">      &#123;<span class="built_in">bool</span> equals(K key1, K key2)?,</span><br><span class="line">      <span class="built_in">int</span> hashCode(K key)?,</span><br><span class="line">      <span class="built_in">bool</span> isValidKey(potentialKey)?&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValidKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hashCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equals == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> _InternalLinkedHashMap&lt;K, V&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        hashCode = _defaultHashCode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (identical(identityHashCode, hashCode) &amp;&amp;</span><br><span class="line">            identical(identical, equals)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> _CompactLinkedIdentityHashMap&lt;K, V&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        equals ??= _defaultEquals;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hashCode ??= _defaultHashCode;</span><br><span class="line">      equals ??= _defaultEquals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _CompactLinkedCustomHashMap&lt;K, V&gt;(equals, hashCode, isValidKey);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>LinkedHashMap</code>的工厂构造方法返回的实例类型是 <code>_InternalLinkedHashMap</code> 或 <code>_CompactLinkedCustomHashMap</code> ，这里我们再看一下这两个类的实现源码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/compact_hash.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">"vm:entry-point"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InternalLinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">_HashVMBase</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span></span></span><br><span class="line"><span class="class">        <span class="title">MapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">_LinkedHashMapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">_HashBase</span>,</span></span><br><span class="line"><span class="class">        <span class="title">_OperatorEqualsAndHashCode</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  _InternalLinkedHashMap() &#123;</span><br><span class="line">    _index = <span class="keyword">new</span> Uint32List(_HashBase._INITIAL_INDEX_SIZE);</span><br><span class="line">    _hashMask = _HashBase._indexSizeToHashMask(_HashBase._INITIAL_INDEX_SIZE);</span><br><span class="line">    _data = <span class="keyword">new</span> <span class="built_in">List</span>.filled(_HashBase._INITIAL_INDEX_SIZE, <span class="keyword">null</span>);</span><br><span class="line">    _usedData = <span class="number">0</span>;</span><br><span class="line">    _deletedKeys = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CompactLinkedIdentityHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">_HashFieldBase</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span></span></span><br><span class="line"><span class="class">        <span class="title">MapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">_LinkedHashMapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">_HashBase</span>,</span></span><br><span class="line"><span class="class">        <span class="title">_IdenticalAndIdentityHashCode</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  _CompactLinkedIdentityHashMap() : <span class="keyword">super</span>(_HashBase._INITIAL_INDEX_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CompactLinkedCustomHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">_HashFieldBase</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">MapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">_LinkedHashMapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">_HashBase</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _equality;</span><br><span class="line">  <span class="keyword">final</span> _hasher;</span><br><span class="line">  <span class="keyword">final</span> _validKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(koda): Ask gbracha why I cannot have fields _equals/_hashCode.</span></span><br><span class="line">  <span class="built_in">int</span> _hashCode(e) =&gt; _hasher(e);</span><br><span class="line">  <span class="built_in">bool</span> _equals(e1, e2) =&gt; _equality(e1, e2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> containsKey(<span class="built_in">Object</span>? o) =&gt; _validKey(o) ? <span class="keyword">super</span>.containsKey(o) : <span class="keyword">false</span>;</span><br><span class="line">  V? <span class="keyword">operator</span> [](<span class="built_in">Object</span>? o) =&gt; _validKey(o) ? <span class="keyword">super</span>[o] : <span class="keyword">null</span>;</span><br><span class="line">  V? remove(<span class="built_in">Object</span>? o) =&gt; _validKey(o) ? <span class="keyword">super</span>.remove(o) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  _CompactLinkedCustomHashMap(<span class="keyword">this</span>._equality, <span class="keyword">this</span>._hasher, validKey)</span><br><span class="line">      : _validKey = (validKey != <span class="keyword">null</span>) ? validKey : <span class="keyword">new</span> _TypeTest&lt;K&gt;().test,</span><br><span class="line">        <span class="keyword">super</span>(_HashBase._INITIAL_INDEX_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都是一个普通的类，没有工厂构造方法，也就是说 <code>Map</code> 中的 <code>external factory Map();</code> 最终返回的最终实例类型为 <code>_InternalLinkedHashMap</code> 或 <code>_CompactLinkedCustomHashMap</code></p><p>我们可以做一个简单的验证<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> map = <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">print</span>(map.runtimeType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// _InternalLinkedHashMap&lt;dynamic, dynamic&gt;</span></span><br></pre></td></tr></table></figure></p><p>我们来试着来实例化一个抽象类吧<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> eat();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Animal() &#123;</span><br><span class="line">    <span class="keyword">return</span> Cat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"吃"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'睡'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> animal = Animal();</span><br><span class="line"><span class="built_in">print</span>(animal.runtimeType); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果: Cat</span></span><br></pre></td></tr></table></figure><p>可能会有同学要问了，这里用的是接口的方式，可以用继承的方式吗？<br><strong>很遗憾不行，因为在抽象类中定义了工厂构造方法后，在子类中不能定义除工厂构造方法外的其它构造方法了，会报错~</strong></p><p>总结一下：</p><blockquote><p>抽象类无法直接创建实例，但是可以通过实现工厂构造方法来间接实现抽象类的实例化！</p></blockquote><h2 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h2><p>那饶了这么一大圈，为什么不直接在声明的时候就给它实现了呢？🤔<br>这样做的好处就是：</p><blockquote><ul><li>复用同一套API的声明</li><li>可以针对不同的平台做不同的实现</li></ul></blockquote><p>而 <code>针对不同的平台做不同的实现</code> 这一点在下方给出的源码中可以看出</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/io/file_system_entity.dart</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">_FileSystemWatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> Stream&lt;FileSystemEvent&gt; _watch(</span><br><span class="line">      <span class="built_in">String</span> path, <span class="built_in">int</span> events, <span class="built_in">bool</span> recursive);</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">get</span> isSupported;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/_internal/vm/bin/file_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="keyword">static</span> Stream&lt;FileSystemEvent&gt; _watch(</span><br><span class="line">    <span class="built_in">String</span> path, <span class="built_in">int</span> events, <span class="built_in">bool</span> recursive) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isLinux) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _InotifyFileSystemWatcher(path, events, recursive)._stream;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isWindows) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Win32FileSystemWatcher(path, events, recursive)._stream;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isMacOS) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _FSEventStreamFileSystemWatcher(path, events, recursive)</span><br><span class="line">        ._stream;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> FileSystemException(</span><br><span class="line">      <span class="string">"File system watching is not supported on this platform"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;抽象类不能用于创建实例，但是有没有发现，&lt;code&gt;Dart&lt;/code&gt; 提供的 &lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;List&lt;/code&gt; 就是抽象类，却可以直接使用它们创建出一个实例对象&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="Flutter" scheme="http://linxunfeng.top/categories/Flutter/"/>
    
    
    <category term="Dart" scheme="http://linxunfeng.top/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>解决SecurityEnvSDK与SGMain的冲突问题</title>
    <link href="http://linxunfeng.top/2020/03/14/%E8%A7%A3%E5%86%B3SecurityEnvSDK%E4%B8%8ESGMain%E7%9A%84%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/"/>
    <id>http://linxunfeng.top/2020/03/14/%E8%A7%A3%E5%86%B3SecurityEnvSDK%E4%B8%8ESGMain%E7%9A%84%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-14T13:21:00.000Z</published>
    <updated>2021-01-31T14:26:32.817Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>报错是说有重复类，解决的办法比较简单粗暴，就是把在Xcode里全文搜索<br><code>-framework &quot;SecurityEnvSDK&quot;</code>，接着全文替换为空字符串就可以了。</p><p>+<a id="more"></a></p><The rest of contents | 余下全文><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在集成友盟统计和阿里百川之后项目报如下错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol '_OBJC_CLASS_$_tdvSFHFKeychainUtils' in:</span><br><span class="line">    /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o)</span><br><span class="line">    /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)</span><br><span class="line">duplicate symbol '_OBJC_METACLASS_$_tdvSFHFKeychainUtils' in:</span><br><span class="line">    /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o)</span><br><span class="line">    /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)</span><br><span class="line">duplicate symbol '_OBJC_CLASS_$_SGDataCollectionLock' in:</span><br><span class="line">    /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o)</span><br><span class="line">    /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)</span><br><span class="line">duplicate symbol '_OBJC_METACLASS_$_SGDataCollectionLock' in:</span><br><span class="line">    /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o)</span><br><span class="line">    /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)</span><br></pre></td></tr></table></figure><blockquote><p> 报错是说有重复类，解决的办法比较简单粗暴，就是把在Xcode里全文搜索<br> <code>-framework &quot;SecurityEnvSDK&quot;</code>，接着全文替换为空字符串就可以了。</p></blockquote><p>虽然解决这个问题的方式很简单，但是每次 <code>pod install</code> 后都要做一遍该操作，这就很无语了 。</p><p>那有什么办法可以让我们不用自己去做这个烦琐的事情呢？</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ol><li><p>首先要搞清楚，上面的操作原理是怎么回事？其它很简单，就是将下面这两个文件中 <code>OTHER_LDFLAGS</code> 所在行的内容里，把 <code>-framework &quot;SecurityEnvSDK&quot;</code> 置为空字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pods/Target Support Files/Pods-项目名/Pods-项目名.debug.xcconfig</span><br><span class="line">Pods/Target Support Files/Pods-项目名/Pods-项目名.release.xcconfig</span><br></pre></td></tr></table></figure></li><li><p>有什么办法可以让我们在适当的时候去执行这个置空字符串的操作？<br><code>Cocoapods</code> 提供了一个很好用的 <code>Hook</code> 就是 <code>post_install</code>，这个钩子的作用就是方便我们在执行 <code>pod install</code> 之后去做一些其它配置，这里我们就用它来搞事情。</p></li></ol><p><code>Podfile</code> 文件中使用的是 <code>ruby</code> 语言，<code>ruby</code> 执行终端命令的代码如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line"><span class="meta">  #</span><span class="bash"> <span class="built_in">command</span> = <span class="string">"echo 'hello world'"</span></span></span><br><span class="line">  command = "终端命令"</span><br><span class="line">  system(command)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>OK，现在开始搞事！</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在项目的目录，即与<code>Pods</code>平级目录中，新建一个文件，名为 <code>fix.py</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── ...</span><br><span class="line">├── Podfile</span><br><span class="line">├── Podfile.lock</span><br><span class="line">├── Pods</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── ...</span><br><span class="line">└── fix.py</span><br></pre></td></tr></table></figure><ol start="2"><li>在 <code>fix.py</code> 中粘贴如下内容<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys, os, getopt, codecs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_file_name</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""获取当前文件名称"""</span></span><br><span class="line">    <span class="keyword">return</span> os.path.split(__file__)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_all_str</span><span class="params">(file_path, for_str, to_str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    全文搜索替换或单行替换</span></span><br><span class="line"><span class="string">    :param file_path: 文件路径</span></span><br><span class="line"><span class="string">    :param for_str: 要被替换的内容</span></span><br><span class="line"><span class="string">    :param to_str: 替换之后的内容</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">        <span class="comment"># 文件不存在</span></span><br><span class="line">        print(<span class="string">'文件不存在'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    bak_file_path = file_path+<span class="string">".bak"</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(file_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f, codecs.open(bak_file_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_w:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"OTHER_LDFLAGS"</span> <span class="keyword">in</span> line <span class="keyword">and</span> for_str <span class="keyword">in</span> line:</span><br><span class="line">                line = line.replace(for_str, to_str)</span><br><span class="line">            f_w.write(line)</span><br><span class="line"></span><br><span class="line">    os.remove(file_path)</span><br><span class="line">    os.rename(bak_file_path, file_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">throwParamError</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"请正确输入命令： %s -p 项目名称"</span> % get_current_file_name())</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    project_name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(argv, <span class="string">"p:"</span>, [<span class="string">"project="</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">        throwParamError()</span><br><span class="line">    <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="comment"># print("opt -- ", opt)</span></span><br><span class="line">        <span class="comment"># print("arg -- ", arg)</span></span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> (<span class="string">'-p'</span>, <span class="string">'--project'</span>):</span><br><span class="line">            project_name = arg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(project_name):</span><br><span class="line">        throwParamError()</span><br><span class="line">    </span><br><span class="line">    path_str = <span class="string">"Pods/Target Support Files/Pods-%s/Pods-%s.%s.xcconfig"</span></span><br><span class="line">    xcconfig_debug_path = path_str % (project_name, project_name, <span class="string">"debug"</span>)</span><br><span class="line">    xcconfig_release_path = path_str % (project_name, project_name, <span class="string">"release"</span>)</span><br><span class="line">    <span class="comment"># print(xcconfig_debug_path)</span></span><br><span class="line">    <span class="comment"># print(xcconfig_release_path)</span></span><br><span class="line">    be_fixed_str = <span class="string">'-framework "SecurityEnvSDK"'</span></span><br><span class="line">    replace_all_str(xcconfig_debug_path,  be_fixed_str, <span class="string">''</span>)</span><br><span class="line">    replace_all_str(xcconfig_release_path,  be_fixed_str, <span class="string">''</span>)</span><br><span class="line">    print(<span class="string">"%s is fixed successfully"</span> %project_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main(sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></li><li>打开 <code>Podfile</code>，在内容最后添加如下内容<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">  <span class="comment"># 解决SecurityEnvSDK与SGMain的冲突问题</span></span><br><span class="line">  command = <span class="string">"python fix.py -p 项目名称"</span></span><br><span class="line">  system(command)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li>执行<code>pod install</code></li></ol><p>好了，现在开始就又可以继续愉快的搬砖了~</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>相关代码文件可以到这里下载，如果觉得不错，不妨给个 <code>Star</code> 鼓励一下<br><a href="https://github.com/LinXunFeng/fix_confict_SecurityEnvSDK_SGMain" target="_blank" rel="noopener">https://github.com/LinXunFeng/fix_confict_SecurityEnvSDK_SGMain</a></p>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;报错是说有重复类，解决的办法比较简单粗暴，就是把在Xcode里全文搜索&lt;br&gt;&lt;code&gt;-framework &amp;quot;SecurityEnvSDK&amp;quot;&lt;/code&gt;，接着全文替换为空字符串就可以了。&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="iOS" scheme="http://linxunfeng.top/categories/iOS/"/>
    
    
    <category term="Cocoapods" scheme="http://linxunfeng.top/tags/Cocoapods/"/>
    
    <category term="iOS" scheme="http://linxunfeng.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>解决Transporter一直卡正在验证的问题</title>
    <link href="http://linxunfeng.top/2020/03/12/%E8%A7%A3%E5%86%B3Transporter%E4%B8%80%E7%9B%B4%E5%8D%A1%E6%AD%A3%E5%9C%A8%E9%AA%8C%E8%AF%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://linxunfeng.top/2020/03/12/%E8%A7%A3%E5%86%B3Transporter%E4%B8%80%E7%9B%B4%E5%8D%A1%E6%AD%A3%E5%9C%A8%E9%AA%8C%E8%AF%81%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-12T22:16:00.000Z</published>
    <updated>2021-01-31T14:26:32.817Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>苹果的上传应用工具 <code>Transporter</code> 虽然挺好用，但是估计也不少人跟我一样遇到过这样的问题，就是一直卡在 <code>正在验证</code>，不采取点措施估计能一直卡下去~</p><p>+<a id="more"></a></p><The rest of contents | 余下全文><blockquote><p>苹果的上传应用工具 <code>Transporter</code> 虽然挺好用，但是估计也不少人跟我一样遇到过这样的问题，就是一直卡在 <code>正在验证</code>，不采取点措施估计能一直卡下去~</p></blockquote><p><img src= "/img/loading.gif" data-src="/images/2020/03/解决Transporter一直卡正在验证的问题/正在验证APP.jpg" alt="正在验证APP"></p><p>其实原因很简单，就是 <code>/User/当前登录用户/Library/Caches/com.apple.amp.itmstransporter</code> 这个目录里的文件不全，一直处于下载更新的状态。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>科学上网前提下，在终端下执行  <code>Transporter</code> 包内的 <code>iTMSTransporter</code>，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter</span><br></pre></td></tr></table></figure><br>因为国外服务器（<code>contentdelivery.itunes.apple.com:443</code>）对我们来说会很慢，所以这个过程最好弄下科学环境。</p><p>直到出现这个命令说明界面就可以了<br><img src= "/img/loading.gif" data-src="/images/2020/03/解决Transporter一直卡正在验证的问题/iTMSTransporter.png" alt=""></p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>适用人群</p><ul><li>没有科学环境</li><li>速度要求高的</li><li>比较懒的</li></ul><p>可以使用 <code>transporter_fix</code><br>GitHub地址：<a href="https://github.com/LinXunFeng/transporter_fix" target="_blank" rel="noopener">https://github.com/LinXunFeng/transporter_fix</a><br>执行文件下载地址：<a href="https://github.com/LinXunFeng/transporter_fix/releases" target="_blank" rel="noopener">点我下载</a>，下载后双击运行即可。</p><p><img src= "/img/loading.gif" data-src="/images/2020/03/解决Transporter一直卡正在验证的问题/transporter_fix.png" alt=""></p><p>比较懒的朋友看到这就可以了，要求速度快的就继续往下看</p><p><strong>重点</strong></p><ul><li><code>transporter_fix</code> 默认是从 <code>github</code> 上下载 <code>com.apple.amp.itmstransporter.zip</code> 到同目录级别的 <code>files</code> 目录下。</li><li>如果 <code>files</code> 目录下已存在 <code>com.apple.amp.itmstransporter.zip</code> ，则不会重新下载。</li></ul><p>所以，如果当前正常网络对 <code>github</code> 不给力，可以到<a href="https://www.lanzous.com/b0aqkmhpg" target="_blank" rel="noopener">这里</a>，找个离当前日期最近的压缩包，下载下来后改名为 <code>com.apple.amp.itmstransporter.zip</code>，存放 <code>files</code> 目录下即可</p><p><img src= "/img/loading.gif" data-src="/images/2020/03/解决Transporter一直卡正在验证的问题/itmstransporter压缩包存放位置.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;苹果的上传应用工具 &lt;code&gt;Transporter&lt;/code&gt; 虽然挺好用，但是估计也不少人跟我一样遇到过这样的问题，就是一直卡在 &lt;code&gt;正在验证&lt;/code&gt;，不采取点措施估计能一直卡下去~&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="iOS" scheme="http://linxunfeng.top/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://linxunfeng.top/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>FQ-Terminal下的代理工具ProxyChains-NG</title>
    <link href="http://linxunfeng.top/2019/01/01/Others/FQ-Terminal%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7ProxyChains-NG/"/>
    <id>http://linxunfeng.top/2019/01/01/Others/FQ-Terminal%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7ProxyChains-NG/</id>
    <published>2019-01-01T17:11:51.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <p>是不是你也遇到过，在 <code>Shadowsocks</code> 使用 <code>全局</code> 模式下，终端依旧无法 <code>ping</code> 通谷歌？这是因为 <code>Shadowsocks</code> 仅针对代理应用软件，但是一些终端下执行的命令是无法代理的。所以本篇就来介绍一下如何使你的终端也走代理进行访问。  </p><a id="more"></a><The rest of contents | 余下全文><blockquote><p>是不是你也遇到过，在 <code>Shadowsocks</code> 使用 <code>全局</code> 模式下，终端依旧无法 <code>ping</code> 通谷歌？这是因为 <code>Shadowsocks</code> 仅针对代理应用软件，但是一些终端下执行的命令是无法代理的。所以本篇就来介绍一下如何使你的终端也走代理进行访问。</p></blockquote><h2 id="方案一：终端下的all-proxy"><a href="#方案一：终端下的all-proxy" class="headerlink" title="方案一：终端下的all_proxy"></a>方案一：终端下的all_proxy</h2><blockquote><p>这里以 <code>zshrc</code> + <code>Shadowsocks</code> 为例</p><ul><li><p>打开 <code>Shadowsocks</code>，模式选为 <code>PAC自动模式</code> 或 <code>全局模式</code> </p></li><li><p>如果不是使用 <code>.zshrc</code> 就 编辑 <code>~/.bashrc</code>，下面的同理</p></li></ul></blockquote><h3 id="1、打开-zshrc"><a href="#1、打开-zshrc" class="headerlink" title="1、打开 .zshrc"></a>1、打开 <code>.zshrc</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="2、添加命令"><a href="#2、添加命令" class="headerlink" title="2、添加命令"></a>2、添加命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias proxy='export all_proxy=socks5://127.0.0.1:1086'</span><br><span class="line">alias unproxy='unset all_proxy'</span><br></pre></td></tr></table></figure><h3 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h3><p>先应用一下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>终端下敲入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxy</span><br></pre></td></tr></table></figure><p>这样就应用上代理了，使用 <code>curl</code> 获取一下 <code>cip.cc</code> 来查看当前所使用的 <code>ip</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl cip.cc</span><br></pre></td></tr></table></figure><p>如果不想使用代理了，就使用如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unproxy</span><br></pre></td></tr></table></figure><h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>这种方式我个人是亲测无效的，不知道是不是我人品问题，还是我的 MAC 有问题，有兴趣的小伙伴可以试试。</p><h2 id="方案二：ProxyChains-NG"><a href="#方案二：ProxyChains-NG" class="headerlink" title="方案二：ProxyChains-NG"></a>方案二：ProxyChains-NG</h2><p>proxychains-ng是proxychains的加强版，主要有以下功能和不足：</p><ul><li>支持http/https/socks4/socks5</li><li>支持认证</li><li>远端dns查询</li><li>多种代理模式</li><li>不支持udp/icmp转发</li><li>少部分程序和在后台运行的可能无法代理</li></ul><p>详情可见 <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">GitHub地址</a></p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>这里以 <code>MAC</code> + <code>homebrew</code> 为例，如果你还没有安装的话可以参考下方命令，详细可见官网 <a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">Homebrew</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将命令粘贴至终端并回车进行安装</span></span><br><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure><h3 id="关闭SIP"><a href="#关闭SIP" class="headerlink" title="关闭SIP"></a>关闭SIP</h3><p>macOS 10.11 后下由于开启了 SIP（System Integrity Protection） 会导致命令行下 proxychains-ng 代理的模式失效，如果你要使用 proxychains-ng 这种简单的方法，就需要先关闭 SIP。</p><p>具体的关闭方法如下：</p><ul><li>部分关闭 SIP</li></ul><blockquote><p>重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。<br>实用工具（Utilities）-&gt; 终端（Terminal）。<br>输入命令<code>csrutil enable --without debug</code>运行。<br>重启进入系统后，终端里输入 csrutil status，结果中如果有 Debugging Restrictions: disabled 则说明关闭成功。</p></blockquote><ul><li>完全关闭 SIP</li></ul><blockquote><p>重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。<br>实用工具（Utilities）-&gt; 终端（Terminal）。<br>输入命令<code>csrutil disable</code>运行。<br>重启进入系统后，终端里输入 csrutil status，结果中如果有 System Integrity Protection status:disabled. 则说明关闭成功。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install proxychains-ng</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用 Homebrew 安装完成后的配置文件路径为 <code>/usr/local/etc/proxychains.conf</code></p><p>打开它，找到 <code>[ProxyList]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">socks5  127.0.0.1 1086</span><br></pre></td></tr></table></figure><p>proxychains-ng支持多种代理模式,默认是选择 strict_chain。</p><ul><li>dynamic_chain ：动态模式,按照代理列表顺序自动选取可用代理</li><li>strict_chain ：严格模式,严格按照代理列表顺序使用代理，所有代理必须可用</li><li>round_robin_chain ：轮询模式，自动跳过不可用代理</li><li>random_chain ：随机模式,随机使用代理</li></ul><p>给proxychains4增加一个别名，在 ~/.zshrc或~/.bashrc末尾加入如下行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias pc='proxychains4'</span><br></pre></td></tr></table></figure><p>这样就可以使用 <code>pc</code> 来 指代 <code>proxychains4</code>，简化输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pc curl cip.cc</span><br></pre></td></tr></table></figure><p>如果你使用 <code>iTerm</code> 的话可以配置快捷键来实现前缀补全功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 iTerm -&gt; Preferences -&gt; Profiles -&gt; Keys 中，新建一个快捷键，例如 ⌥ + p ，Action 选择 Send Hex Code，键值为 0x1 0x70 0x63 0x20 0xd，保存生效。</span><br></pre></td></tr></table></figure><p>更多的Hex Code可以到 <a href="https://manytricks.com/keycodes/" target="_blank" rel="noopener">manytricks</a> 上查找。</p><p>使用场景：敲了一长串的命令后想使用代理功能时，就可以直接使用快捷键 <code>⌥ + p</code> ，这样就会自动在命令的最前面加上 <code>pc</code> </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 curl cip.cc</span><br><span class="line"></span><br><span class="line">// 如果你设置了别名的话可以使用 pc 指代 proxychains4</span><br><span class="line">pc curl cip.cc</span><br></pre></td></tr></table></figure><p>可以看到这就代理上了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IP: xxx.xxx.xxx.xxx</span><br><span class="line">地址: 美国  加利福尼亚州  洛杉矶</span><br><span class="line">运营商: it7.net</span><br><span class="line"></span><br><span class="line">数据二: 美国</span><br><span class="line"></span><br><span class="line">数据三: 美国加利福尼亚洛杉矶</span><br><span class="line"></span><br><span class="line">URL: http:&#x2F;&#x2F;www.cip.cc&#x2F;xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;p&gt;是不是你也遇到过，在 &lt;code&gt;Shadowsocks&lt;/code&gt; 使用 &lt;code&gt;全局&lt;/code&gt; 模式下，终端依旧无法 &lt;code&gt;ping&lt;/code&gt; 通谷歌？这是因为 &lt;code&gt;Shadowsocks&lt;/code&gt; 仅针对代理应用软件，但是一些终端下执行的命令是无法代理的。所以本篇就来介绍一下如何使你的终端也走代理进行访问。  &lt;/p&gt;</summary>
    
    
    
    <category term="Others" scheme="http://linxunfeng.top/categories/Others/"/>
    
    
    <category term="FQ" scheme="http://linxunfeng.top/tags/FQ/"/>
    
    <category term="Terminal" scheme="http://linxunfeng.top/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>Swift 掌控Moya的网络请求、数据解析与缓存</title>
    <link href="http://linxunfeng.top/2018/10/27/Swift-%E6%8E%8C%E6%8E%A7Moya%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
    <id>http://linxunfeng.top/2018/10/27/Swift-%E6%8E%8C%E6%8E%A7Moya%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BC%93%E5%AD%98/</id>
    <published>2018-10-27T23:41:37.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <ul><li><code>Moya</code> 在Swift开发中起着重要的网络交互作用，但是还有不如之处，比如网络不可用时，返回的 <code>Response</code> 为 <code>nil</code>，这时还得去解析相应的 <code>Error</code></li><li><code>Codable</code> 可以帮助我们快速的解析数据，但是一旦声明的属性类型与json中的不一致，将无法正常解析; 而且对于模型中自定义属性名的处理也十分繁琐</li></ul><p>+<a id="more"></a></p><The rest of contents | 余下全文><ul><li><code>Moya</code> 在Swift开发中起着重要的网络交互作用，但是还有不如之处，比如网络不可用时，返回的 <code>Response</code> 为 <code>nil</code>，这时还得去解析相应的 <code>Error</code></li><li><code>Codable</code> 可以帮助我们快速的解析数据，但是一旦声明的属性类型与json中的不一致，将无法正常解析; 而且对于模型中自定义属性名的处理也十分繁琐</li></ul><p>解决的方案有很多，不过我比较习惯使用 <code>MoyaMapper</code> ，不仅可以解决上述问题，还提供了多种<code>模型转换</code>、<code>数据互转</code>、<code>多种数据类型任意存储</code>的便捷方法。掌控Moya的网络请求、数据解析与缓存简直易如反掌。</p><blockquote><p><code>MoyaMapper</code>是基于Moya和SwiftyJSON封装的工具，以Moya的plugin的方式来实现间接解析，支持RxSwift</p><p> GitHub: <a href="https://github.com/MoyaMapper/MoyaMapper" target="_blank" rel="noopener">MoyaMapper</a></p><p>📖 详细的使用请查看手册 <a href="https://moyamapper.github.io/" target="_blank" rel="noopener">https://MoyaMapper.github.io</a></p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>支持<code>json</code> 转 <code>Model</code> 自动映射 与 自定义映射</li><li>无视 <code>json</code> 中值的类型，<code>Model</code> 中属性声明的是什么类型，它就是什么类型</li><li>支持 <code>Data</code> <code>字典</code> <code>JSON</code> <code>json字符串</code> <code>Model</code> 互转</li><li>插件方式，全方位保障<code>Moya.Response</code>，拒绝各种网络问题导致 <code>Response</code> 为 <code>nil</code>，将各式各样的原因导致的数据加载失败进行统一处理，开发者只需要关注 <code>Response</code></li><li>可选 - 支持数据随意缓存( <code>JSON</code> 、 <code>Number</code> 、<code>String</code>、 <code>Bool</code>、 <code>Moya.Response</code> )</li><li>可选 - 支持网络请求缓存</li></ul><h2 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h2><h5 id="一、插件注入"><a href="#一、插件注入" class="headerlink" title="一、插件注入"></a>一、插件注入</h5><p>附：<a href="https://moyamapper.github.io/plugin/" target="_blank" rel="noopener">插件 MoyaMapperPlugin 的详细使用</a></p><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/success-obj.png" alt=""></p><p>1、定义适用于项目接口的 <code>ModelableParameterType</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// statusCodeKey、tipStrKey、 modelKey 可以任意指定级别的路径，如： "error&gt;used"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetParameter</span> : <span class="title">ModelableParameterType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> successValue = <span class="string">"000"</span></span><br><span class="line">    <span class="keyword">var</span> statusCodeKey = <span class="string">"retStatus"</span></span><br><span class="line">    <span class="keyword">var</span> tipStrKey = <span class="string">"retMsg"</span></span><br><span class="line">    <span class="keyword">var</span> modelKey = <span class="string">"retBody"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在 <code>MoyaProvider</code> 中使用 <code>MoyaMapperPlugin</code> 插件，并指定 <code>ModelableParameterType</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lxfNetTool = <span class="type">MoyaProvider</span>&lt;<span class="type">LXFNetworkTool</span>&gt;(plugins: [<span class="type">MoyaMapperPlugin</span>(<span class="type">NetParameter</span>())])</span><br></pre></td></tr></table></figure><p>❗ 使用 <code>MoyaMapperPlugin</code> 插件是整个 <code>MoyaMapper</code>  的核心所在！</p><h5 id="二、Model声明"><a href="#二、Model声明" class="headerlink" title="二、Model声明"></a>二、Model声明</h5><blockquote><p><code>Model</code> 需遵守 <code>Modelable</code> 协议</p><ul><li><code>MoyaMapper</code> 支持模型自动映射 和 自定义映射</li><li>不需要考虑源json数据的真实类型，这里统一按 <code>Model</code> 中属性声明的类型进行转换</li></ul></blockquote><p>1、一般情况下如下写法即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompanyModel</span>: <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> catchPhrase : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、如果自定义映射，则可以实现方法 <code>mutating func mapping(_ json: JSON)</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompanyModel</span>: <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> catchPhrase : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="number">_</span> json: JSON)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = json[<span class="string">"nickname"</span>].stringValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、支持模型嵌套</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserModel</span>: <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> id : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> company : <span class="type">CompanyModel</span> = <span class="type">CompanyModel</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="三、Response-解析"><a href="#三、Response-解析" class="headerlink" title="三、Response 解析"></a>三、Response 解析</h5><blockquote><p>1、以下示例皆使用了 <code>MoyaMapperPlugin</code> ，所以不需要指定 <code>解析路径</code></p><p>2、如果没有使用 <code>MoyaMapperPlugin</code> 则需要指定 <code>解析路径</code>，否则无法正常解析</p><p>ps:  <code>解析路径</code> 可以使用 <code>a&gt;b</code> 这种形式来解决多级路径的问题</p></blockquote><p>解析方法如下列表所示</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">描述 (支持RxSwift)</th></tr></thead><tbody><tr><td style="text-align:center">toJSON</td><td style="text-align:left">Response 转 JSON ( <a href="https://moyamapper.github.io/core/toJSON/" target="_blank" rel="noopener">toJSON</a>   <a href="https://moyamapper.github.io/rx/toJSON/" target="_blank" rel="noopener">rx.toJSON</a>)</td></tr><tr><td style="text-align:center">fetchString</td><td style="text-align:left">获取指定路径的字符串( <a href="https://moyamapper.github.io/core/fetchString/" target="_blank" rel="noopener">fetchString</a>   <a href="https://moyamapper.github.io/rx/fetchString/" target="_blank" rel="noopener">rx.fetchString</a>)</td></tr><tr><td style="text-align:center">fetchJSONString</td><td style="text-align:left">获取指定路径的原始json字符串 ( <a href="https://moyamapper.github.io/core/fetchJSONString/" target="_blank" rel="noopener">fetchJSONString</a>   <a href="https://moyamapper.github.io/rx/fetchJSONString/" target="_blank" rel="noopener">rx.fetchJSONString</a> )</td></tr><tr><td style="text-align:center">mapResult</td><td style="text-align:left">Response -&gt; MoyaMapperResult   <code>(Bool, String)</code> ( <a href="https://moyamapper.github.io/core/mapResult/" target="_blank" rel="noopener">mapResult</a>   <a href="https://moyamapper.github.io/rx/mapResult/" target="_blank" rel="noopener">rx.mapResult</a> )</td></tr><tr><td style="text-align:center">mapObject</td><td style="text-align:left">Response -&gt; Model ( <a href="https://moyamapper.github.io/core/mapObject/" target="_blank" rel="noopener">mapObject</a>   <a href="https://moyamapper.github.io/rx/mapObject/" target="_blank" rel="noopener">rx.mapObject</a>)</td></tr><tr><td style="text-align:center">mapObjResult</td><td style="text-align:left">Response -&gt; (MoyaMapperResult, Model) ( <a href="https://moyamapper.github.io/core/mapObjResult/" target="_blank" rel="noopener">mapObjResult</a>   <a href="https://moyamapper.github.io/rx/mapObjResult/" target="_blank" rel="noopener">rx.mapObjResult</a>)</td></tr><tr><td style="text-align:center">mapArray</td><td style="text-align:left">Response -&gt; [Model] ( <a href="https://moyamapper.github.io/core/mapArray/" target="_blank" rel="noopener">mapArray</a>  <a href="https://moyamapper.github.io/rx/mapArray/" target="_blank" rel="noopener">rx.mapArray</a>)</td></tr><tr><td style="text-align:center">mapArrayResult</td><td style="text-align:left">Response -&gt; (MoyaMapperResult, [Model]) ( <a href="https://moyamapper.github.io/core/mapArrayResult/" target="_blank" rel="noopener">mapArrayResult</a>   <a href="https://moyamapper.github.io/rx/mapArrayResult/" target="_blank" rel="noopener">rx.mapArrayResult</a>)</td></tr></tbody></table><p>❗除了 <code>fetchJSONString</code> 的默认解析路径是<code>根路径</code>之外，其它方法的默认解析路径为插件对象中的 <code>modelKey</code></p><p>如果接口请求后 <code>json</code> 的数据结构与下图类似，则使用 <code>MoyaMapper</code> 是最合适不过了</p><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/success-obj.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal</span></span><br><span class="line"><span class="keyword">let</span> model = response.mapObject(<span class="type">MMModel</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"name -- \(model.name)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"github -- \(model.github)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印json</span></span><br><span class="line"><span class="built_in">print</span>(response.fetchJSONString())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx</span></span><br><span class="line">rxRequest.mapObject(<span class="type">MMModel</span>.<span class="keyword">self</span>)</span><br><span class="line">    .subscribe(onSuccess: &#123; (model) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"name -- \(model.name)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"github -- \(model.github)"</span>)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>附： <a href="https://moyamapper.github.io/core/fetchJSONString/" target="_blank" rel="noopener">fetchJSONString的详细使用</a></p><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/success-array.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal</span></span><br><span class="line"><span class="keyword">let</span> models = response.mapArray(<span class="type">MMModel</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> name = models[<span class="number">0</span>].name</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"count -- \(models.count)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"name -- \(name)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 json 模型数组中第一个的name</span></span><br><span class="line"><span class="built_in">print</span>(response.fetchString(keys: [<span class="number">0</span>, <span class="string">"name"</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx</span></span><br><span class="line">rxRequest.mapArray(<span class="type">MMModel</span>.<span class="keyword">self</span>)</span><br><span class="line">    .subscribe(onSuccess: &#123; models <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> name = models[<span class="number">0</span>].name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"count -- \(models.count)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"name -- \(name)"</span>)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>附：<a href="https://moyamapper.github.io/core/mapArray/" target="_blank" rel="noopener">mapArray的详细使用说明</a></p><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/fail.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal</span></span><br><span class="line"><span class="keyword">let</span> (isSuccess, tipStr) = response.mapResult()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"isSuccess -- \(isSuccess)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"tipStr -- \(tipStr)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx</span></span><br><span class="line">rxRequest.mapResult()</span><br><span class="line">    .subscribe(onSuccess: &#123; (isSuccess, tipStr) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"isSuccess -- \(isSuccess)"</span>) <span class="comment">// 是否为 "000"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"retMsg -- \(retMsg)"</span>) <span class="comment">// "缺少必要参数"</span></span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>附：<a href="https://moyamapper.github.io/core/mapResult/" target="_blank" rel="noopener">mapResult的详细使用说明</a></p><h2 id="统一处理网络请求结果"><a href="#统一处理网络请求结果" class="headerlink" title="统一处理网络请求结果"></a>统一处理网络请求结果</h2><blockquote><p>在APP的实际使用过程中，会遇到各种各样的网络请求结果，如:服务器挂了、手机无网络，此时 <code>Moya</code> 返回的 <code>Response</code> 为 nil，这样我们就不得不去判断 <code>Error</code>。但是使用 <code>MoyaMapperPlugin</code> 就可以让我们只关注 <code>Response</code></p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MoyaMapperPlugin 的初始化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">T</span>: <span class="type">ModelableParameterType</span>&gt;(</span><br><span class="line">    <span class="number">_</span> type: <span class="type">T</span>,</span><br><span class="line">    transformError: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type : <span class="type">ModelableParameterType</span>  用于定义字段路径，做为全局解析数据的依据</span><br><span class="line">transformError : <span class="type">Bool</span>  是否当网络请求失败时，自动转换请求结果，默认为 <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>当请求失败的时候，此时的 <code>result.response</code> 为 <code>nil</code>，根据<code>transformError</code>是否为<code>true</code> 判断是否创建一个自定义的 <code>response</code> 并返回出去。</li></ul><p>➡ 本来可以请求到的数据内容</p><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/success-obj.png" alt=""></p><p>➡ 现在关闭网络，再请求数据</p><ul><li><p>正常情况下，即不做任何不处理的时候， <code>Response</code> 为 <code>nil</code> </p></li><li><p>经过 <code>MoyaMapperPlugin</code> 处理的后可得到转换后的 <code>Response</code> ，如图</p></li></ul><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/plugin.png" alt=""></p><p>这里将请求失败进行了统一处理，无论是服务器还是自身网络的问题，<code>retStatus</code> 都为 MMStatusCode.loadFail，但是 errorDescription 会保持原来的样子并赋值给 <code>retMsg</code>。</p><blockquote><ul><li><code>retStatus</code> 值会从枚举 <code>MMStatusCode</code> 中取  <code>loadFail.rawValue</code> ，即 <code>700</code> </li><li>取 类型为 <code>ModelableParameterType</code>  的 <code>type</code> 中 <code>statusCodeKey</code> 所指定的值 为键名，<code>retMsg</code>也同理</li></ul></blockquote><p>ps: 这个时候可以通过判断 <code>retStatus</code> 或 <code>response.statusCode</code> 是否与 <code>MMStatusCode.loadFail.rawValue</code> 相同来判断是否显示加载失败的空白页占位图</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MMStatusCode</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> cache = <span class="number">230</span></span><br><span class="line">    <span class="keyword">case</span> loadFail = <span class="number">700</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举 <code>MMStatusCode</code> 中除了 <code>loadFail</code> ，还有 <code>cache</code>，我们已经知道 <code>loadFail</code> 在数据加载失败的时候会出现，那 <code>cache</code> 是在什么时候出来呢？不急，看下一节就知道了。</p><h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><h5 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 缓存</span><br><span class="line">@discardableResult</span><br><span class="line">MMCache.shared.cache&#96;XXX&#96;(value : XXX, key: String, cacheContainer: MMCache.CacheContainer &#x3D; .RAM)  -&gt; Bool</span><br><span class="line">&#x2F;&#x2F; 取舍</span><br><span class="line">MMCache.shared.fetch&#96;XXX&#96;Cache(key: String, cacheContainer: MMCache.CacheContainer &#x3D; .RAM)</span><br></pre></td></tr></table></figure><p>缓存成功会返回一个 <code>Bool</code> 值，这里可不接收</p><table><thead><tr><th>XXX 所支持类型</th><th></th></tr></thead><tbody><tr><td>Bool</td><td>-</td></tr><tr><td>Float</td><td>-</td></tr><tr><td>Double</td><td>-</td></tr><tr><td>String</td><td>-</td></tr><tr><td>JSON</td><td>-</td></tr><tr><td>Modelable</td><td>[Modelable]</td></tr><tr><td>Moya.Response</td><td>-</td></tr><tr><td>Int</td><td>UInt</td></tr><tr><td>Int8</td><td>UInt8</td></tr><tr><td>Int16</td><td>UInt16</td></tr><tr><td>Int32</td><td>UInt32</td></tr><tr><td>Int64</td><td>UInt64</td></tr></tbody></table><blockquote><p>其中，除了 <code>Moya.Response</code> 之外，其它类型皆是通过 <code>JSON</code> 来实现缓存</p></blockquote><p>所以，如果你想清除这些类型的缓存，只需要调用如下方法即可</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeJSONCache</span><span class="params">(<span class="number">_</span> key: String, cacheContainer: MMCache.CacheContainer = .RAM)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAllJSONCache</span><span class="params">(cacheContainer: MMCache.CacheContainer = .RAM)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>清除 <code>Moya.Response</code> 则使用如下两个方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeResponseCache</span><span class="params">(<span class="number">_</span> key: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAllResponseCache</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>再来看看MMCache.CacheContainer</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CacheContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RAM</span> <span class="comment">// 只缓存于内存的容器</span></span><br><span class="line">    <span class="keyword">case</span> hybrid <span class="comment">// 缓存于内存与磁盘的容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这两种容器互不相通，即 即使key相同，使用 <code>hybrid</code> 来缓存后，再通过 <code>RAM</code> 取值是取不到的。</p></blockquote><ul><li>RAM : 仅缓存于内存之中，缓存的数据在APP使用期间一直存在</li><li>hybrid ：缓存于内存与磁盘中，APP重启后也可以获取到数据</li></ul><h5 id="二、缓存网络请求"><a href="#二、缓存网络请求" class="headerlink" title="二、缓存网络请求"></a>二、缓存网络请求</h5><p>内部缓存过程：</p><ol><li>APP首次启动并进行网络请求，网络数据将缓存起来</li><li>APP再次启动并进行网络请求时，会先返回缓存的数据，等请求成功后再返回网络数据</li><li>其它情况只会加载网络数据</li><li>每次成功请求到数据后，都会对缓存的数据进行更新</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> target: Target, </span></span></span><br><span class="line"><span class="function"><span class="params">    cacheType: MMCache.CacheKeyType = .<span class="keyword">default</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    callbackQueue: DispatchQueue? = <span class="literal">nil</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    progress: Moya.ProgressBlock? = <span class="literal">nil</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    completion: @escaping Moya.Completion</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Cancellable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> target: Base.Target, </span></span></span><br><span class="line"><span class="function"><span class="params">    callbackQueue: DispatchQueue? = <span class="literal">nil</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    cacheType: MMCache.CacheKeyType = .<span class="keyword">default</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Response</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>实际上是对 <code>Moya</code> 请求后的 <code>Response</code> 进行缓存。 其实与 <code>Moya</code> 自带的方法相比较只多了一个参数 <code>cacheType: MMCache.CacheKeyType</code> ，定义着缓存中的 <code>key</code> ，默认为 <code>default</code> </p></blockquote><p>下面是 <code>MMCache.CacheKeyType</code> 的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> let cacheKey &#x3D; [method]baseURL&#x2F;path</span><br><span class="line"> </span><br><span class="line"> - default : cacheKey + &quot;?&quot; + parameters</span><br><span class="line"> - base : cacheKey</span><br><span class="line"> - custom : cacheKey + &quot;?&quot; + customKey</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum CacheKeyType &#123;</span><br><span class="line">    case &#96;default&#96;</span><br><span class="line">    case base</span><br><span class="line">    case custom(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你想缓存<code>多页</code>列表数据的<code>最新一页</code>数据，此时使用 <code>default</code> 是不合适的，因为 <code>default</code> 使用的 <code>key</code> 包含了 <code>pageIndex</code>，这样就达不到只缓存 <code>最新一页数据</code> 的目的， 所以这里应该使用 <code>base</code> 或者 <code>custom(String)</code> </p></blockquote><p>我们可以来试一下带缓存的请求</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * APP第一次启动并进行网络请求，网络数据将缓存起来</span></span><br><span class="line"><span class="comment"> * APP再次启动并进行网络请求时，会先加载缓存，再加载网络数据</span></span><br><span class="line"><span class="comment"> * 其它情况只会加载网络数据</span></span><br><span class="line"><span class="comment"> * 每次成功请求到数据都会进行数据更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lxfNetTool.rx.cacheRequest(.data(type: .all, size: <span class="number">10</span>, index: <span class="number">1</span>))</span><br><span class="line">    .subscribe(onNext: &#123; response <span class="keyword">in</span></span><br><span class="line">        log.debug(<span class="string">"statusCode -- \(response.statusCode)"</span>)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">let _ = lxfNetTool.cacheRequest(.data(type: .all, size: 10, index: 1)) &#123; result in</span></span><br><span class="line"><span class="comment">    guard let resp = result.value else &#123; return &#125;</span></span><br><span class="line"><span class="comment">    log.debug("statusCode -- \(resp.statusCode)")</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首次使用APP</span><br><span class="line">statusCode -- 200</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关闭并重新打开APP，再请求一下</span><br><span class="line">statusCode -- 230</span><br><span class="line">statusCode -- 200</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后再请求一下</span><br><span class="line">statusCode -- 200</span><br></pre></td></tr></table></figure><p>这里的 <code>230</code> 就是 <code>MMStatusCode.cache.rawValue</code></p><h2 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h2><ul><li>默认安装</li></ul><p>MoyaMapper默认只安装Core下的文件<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'MoyaMapper'</span></span><br></pre></td></tr></table></figure></p><ul><li><p>RxSwift拓展</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'MoyaMapper/Rx'</span></span><br></pre></td></tr></table></figure></li><li><p>缓存拓展</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'MoyaMapper/MMCache'</span></span><br></pre></td></tr></table></figure></li><li><p>Rx缓存</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'MoyaMapper/RxCache'</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Moya&lt;/code&gt; 在Swift开发中起着重要的网络交互作用，但是还有不如之处，比如网络不可用时，返回的 &lt;code&gt;Response&lt;/code&gt; 为 &lt;code&gt;nil&lt;/code&gt;，这时还得去解析相应的 &lt;code&gt;Error&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Codable&lt;/code&gt; 可以帮助我们快速的解析数据，但是一旦声明的属性类型与json中的不一致，将无法正常解析; 而且对于模型中自定义属性名的处理也十分繁琐&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="iOS" scheme="http://linxunfeng.top/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://linxunfeng.top/tags/iOS/"/>
    
    <category term="Swift" scheme="http://linxunfeng.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 优雅的适配大小</title>
    <link href="http://linxunfeng.top/2018/10/24/Swift-%E4%BC%98%E9%9B%85%E7%9A%84%E9%80%82%E9%85%8D%E5%A4%A7%E5%B0%8F/"/>
    <id>http://linxunfeng.top/2018/10/24/Swift-%E4%BC%98%E9%9B%85%E7%9A%84%E9%80%82%E9%85%8D%E5%A4%A7%E5%B0%8F/</id>
    <published>2018-10-24T20:44:50.000Z</published>
    <updated>2021-01-31T14:26:32.813Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <blockquote><p>在日常开发中常常会对设备进行一定的适配，为了方便在多个项目里统一管理和使用，所以封装并开源了<code>SwiftyFitsize</code>这个库，可用于适配视图及字体大小，同时也支持 xib 和 storyboard</p></blockquote><p>GitHub: <a href="https://github.com/LinXunFeng/SwiftyFitsize" target="_blank" rel="noopener">SwiftyFitsize</a></p><p>+<a id="more"></a></p><The rest of contents | 余下全文><blockquote><p>在日常开发中常常会对设备进行一定的适配，为了方便在多个项目里统一管理和使用，所以封装并开源了<code>SwiftyFitsize</code>这个库，可用于适配视图及字体大小，同时也支持 xib 和 storyboard</p></blockquote><p>GitHub: <a href="https://github.com/LinXunFeng/SwiftyFitsize" target="_blank" rel="noopener">SwiftyFitsize</a></p><p>最终的效果如下图所示</p><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-优雅的适配大小/exhibition.png" alt="效果图"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Cocoapods安装，或手动拖入项目<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SwiftyFitsize&#39;</span><br></pre></td></tr></table></figure></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>SwiftyFitsize</code>在默认状况下所使用的参照宽度为<code>iphone6</code>的<code>375</code><br>如果设计图所选用设备的宽度与默认值不同，可以在<code>AppDelegate</code>下初始化所参照的宽度</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SwiftyFitsize</span>.reference(width: <span class="number">414</span>)</span><br></pre></td></tr></table></figure><p>下面列出一些设备对应的分辨率，方便查找</p><table><thead><tr><th>设备</th><th>逻辑分辨率(point)</th><th>设备分辨率(pixel)</th></tr></thead><tbody><tr><td>SE</td><td>320x568</td><td>640x1136</td></tr><tr><td>6(S)／7／8</td><td>375x667</td><td>750x1334</td></tr><tr><td>6(S)+／7+／8+</td><td>414x736</td><td>1080x1920</td></tr><tr><td>X(S)</td><td>375x812</td><td>1125x2436</td></tr><tr><td>XR</td><td>414x896</td><td>828x1792</td></tr><tr><td>XS Max</td><td>414x896</td><td>1242x2688</td></tr></tbody></table><p>使用也是非常方便的，只需要在<code>Number</code>、<code>UIFont</code>、<code>CGPoint</code>、<code>CGSize</code>、<code>UIEdgeInsetsMake</code>这些类型的值后面加上<code>~</code>即可<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>~</span><br><span class="line"><span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)~</span><br><span class="line"><span class="type">CGPoint</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)~</span><br><span class="line"><span class="type">CGSize</span>(width: <span class="number">100</span>, height: <span class="number">100</span>)~</span><br><span class="line"><span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)~</span><br><span class="line"><span class="type">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)~</span><br></pre></td></tr></table></figure></p><h5 id="xib-storyboard-字体适配"><a href="#xib-storyboard-字体适配" class="headerlink" title="xib / storyboard 字体适配"></a>xib / storyboard 字体适配</h5><p>支持控件 <code>UILabel</code> <code>UIButton</code> <code>UITextView</code> <code>UITextField</code></p><p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/SwiftyFitsize/raw/master/Screenshots/xib-font.png" alt="xib-font"></p><h5 id="xib-storyboard-约束适配"><a href="#xib-storyboard-约束适配" class="headerlink" title="xib / storyboard 约束适配"></a>xib / storyboard 约束适配</h5><p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/SwiftyFitsize/raw/master/Screenshots/xib-constraint.png" alt="xib-font"></p><p>##### </p><p>注：<code>~</code>请不要相互嵌套使用，如</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CGPoint</span>(x: <span class="number">10</span>~, y: <span class="number">10</span>~)~</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;blockquote&gt;
&lt;p&gt;在日常开发中常常会对设备进行一定的适配，为了方便在多个项目里统一管理和使用，所以封装并开源了&lt;code&gt;SwiftyFitsize&lt;/code&gt;这个库，可用于适配视图及字体大小，同时也支持 xib 和 storyboard&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/LinXunFeng/SwiftyFitsize&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SwiftyFitsize&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="iOS" scheme="http://linxunfeng.top/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://linxunfeng.top/tags/iOS/"/>
    
    <category term="Swift" scheme="http://linxunfeng.top/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS-面向协议封装全屏旋转功能</title>
    <link href="http://linxunfeng.top/2018/09/15/iOS-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E5%B0%81%E8%A3%85%E5%85%A8%E5%B1%8F%E6%97%8B%E8%BD%AC%E5%8A%9F%E8%83%BD/"/>
    <id>http://linxunfeng.top/2018/09/15/iOS-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E5%B0%81%E8%A3%85%E5%85%A8%E5%B1%8F%E6%97%8B%E8%BD%AC%E5%8A%9F%E8%83%BD/</id>
    <published>2018-09-15T18:05:45.000Z</published>
    <updated>2021-01-31T14:26:32.817Z</updated>
    
    <content type="html"><![CDATA[<Excerpt in index | 首页摘要> <blockquote><p>关于使用面向协议来封装功能的实战可以参考我上篇文章 <a href="/2018/04/07/iOS-面向协议方式封装空白页功能/">【iOS-面向协议方式封装空白页功能】</a>，这里就不再赘述，我们直接进入使用阶段吧。<br>本篇文章只有一个目的，那就是只要遵守协议，一行代码随意切换全屏～</p></blockquote><p>如果对面向协议有疑问的同学可以看下我之前的两篇文章</p><p><a href="/2017/09/12/iOS-Swift-面向协议编程（一）/">iOS - Swift 面向协议编程（一）</a> </p><p><a href="/2017/09/12/iOS-Swift-面向协议编程（二）/">iOS - Swift 面向协议编程（二）</a></p><p>+<a id="more"></a></p><The rest of contents | 余下全文><blockquote><p>关于使用面向协议来封装功能的实战可以参考我上篇文章 <a href="/2018/04/07/iOS-面向协议方式封装空白页功能/">【iOS-面向协议方式封装空白页功能】</a>，这里就不再赘述，我们直接进入使用阶段吧。<br>本篇文章只有一个目的，那就是只要遵守协议，一行代码随意切换全屏～</p></blockquote><p>如果对面向协议有疑问的同学可以看下我之前的两篇文章</p><p><a href="/2017/09/12/iOS-Swift-面向协议编程（一）/">iOS - Swift 面向协议编程（一）</a> </p><p><a href="/2017/09/12/iOS-Swift-面向协议编程（二）/">iOS - Swift 面向协议编程（二）</a></p><h2 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h2><table><thead><tr><th>Name</th><th>Link</th></tr></thead><tbody><tr><td>GitHub</td><td><a href="https://github.com/LinXunFeng/LXFProtocolTool" target="_blank" rel="noopener">LXFProtocolTool</a></td></tr><tr><td>Wiki</td><td><a href="https://github.com/LinXunFeng/LXFProtocolTool/wiki" target="_blank" rel="noopener">Wiki首页</a></td></tr><tr><td>本文 Demo</td><td><a href="https://github.com/LinXunFeng/LXFProtocolTool/tree/master/Example/LXFProtocolTool/Demo/LXFFullScreenable" target="_blank" rel="noopener">LXFFullScreenable</a></td></tr></tbody></table><p>使用Cocoapods的方式来安装即可</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'LXFProtocolTool/FullScreenable'</span></span><br></pre></td></tr></table></figure><h2 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h2><p>在AppDelegate中实现如下方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?)</span></span> -&gt; <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIApplication</span>.shared.lxf.currentVcOrientationMask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、使用案例"><a href="#二、使用案例" class="headerlink" title="二、使用案例"></a>二、使用案例</h2><blockquote><p>方法与属性的调用都需要命名空间加上 <code>lxf</code>，如<code>isFullScreen</code> -&gt; <code>lxf.isFullScreen</code></p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isFullScreen : 获取当前遵守协议者是否为全屏状态</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    isEnter: Bool? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    specifiedView: UIView? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    superView: UIView? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: <span class="params">(<span class="params">(<span class="number">_</span> isFullScreen: Bool)</span></span></span></span>-&gt;<span class="type">Void</span>)? = <span class="literal">nil</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><table><thead><tr><th>Name</th><th>Type</th><th>Desc</th></tr></thead><tbody><tr><td>isEnter</td><td><code>Bool?</code></td><td>是否进入全屏</td></tr><tr><td>specifiedView</td><td><code>UIView?</code></td><td>指定即将全屏的视图</td></tr><tr><td>superView</td><td><code>UIView?</code></td><td>作为退出全屏后specifiedView的父视图</td></tr><tr><td>config</td><td><code>FullScreenableConfig?</code></td><td>配置</td></tr><tr><td>completed</td><td><code>((_ isFullScreen: Bool)-&gt;Void)?</code></td><td>进入/退出 全屏后的回调</td></tr></tbody></table><blockquote><p>当<code>switchFullScreen</code>的调用者为<code>UIView</code>时，如果<code>specifiedView</code>为<code>nil</code>会自动填写，<code>superView</code>也是如此</p></blockquote><blockquote><p><code>switchFullScreen</code>方法不推荐直接使用，不过当遵守协议者为<code>UIViewController</code>时，可以通过使用默认参数来切换屏幕方向<code>lxf.switchFullScreen()</code></p></blockquote><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/09/iOS-面向协议封装全屏旋转功能/lxf_FullScreenable_1.gif" alt="lxf_FullScreenable_1"></p><p>以下分两种情况说明</p><h3 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enterFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    specifiedView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: FullScreenableCompleteType? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    superView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: FullScreenableCompleteType? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>以上两个方法是对<code>switchFullScreen</code>的抽离，使调用时对参数的传递更加清晰</p></blockquote><p>1、遵守协议 <code>FullScreenable</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LXFFullScreenableController</span>: <span class="title">UIViewController</span>, <span class="title">FullScreenable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>2、指定视图进入全屏<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxf.enterFullScreen(specifiedView: cyanView)</span><br></pre></td></tr></table></figure></p><p>3、指定视图退出全屏，并添加到当前控制器的<code>view</code>上<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxf.exitFullScreen(superView: <span class="keyword">self</span>.view)</span><br></pre></td></tr></table></figure></p><h4 id="🔥自动进入-退出全屏"><a href="#🔥自动进入-退出全屏" class="headerlink" title="🔥自动进入|退出全屏"></a>🔥自动进入|退出全屏</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    specifiedView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">    superView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><ul><li>控制器可以调用该方法来注册自动进入或退出全屏，各控制器之间互不影响。</li><li><code>view</code>手动进入全屏会屏蔽当前控制器的自动全屏功能，退出方可恢复</li></ul><h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enterFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    specifiedView: UIView? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: FullScreenableCompleteType? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    superView: UIView? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: FullScreenableCompleteType? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>以上两个方法是对<code>switchFullScreen</code>的抽离，使调用时对参数的传递更加清晰</p></blockquote><p>1、遵守协议 <code>FullScreenable</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LXFFullScreenView</span>: <span class="title">UIButton</span>, <span class="title">FullScreenable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cyanView = <span class="type">LXFFullScreenView</span>()</span><br></pre></td></tr></table></figure><p>2、进入全屏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyanView.lxf.enterFullScreen()</span><br></pre></td></tr></table></figure><p>3、退出全屏<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyanView.lxf.exitFullScreen()</span><br></pre></td></tr></table></figure></p><blockquote><p>这里是对遵守了<code>FullScreenable</code>协议的视图进入全屏切换，由于代码内部已经经过自动视图填写，所以直接调用相应的方法即可，当然也可以自己指定<code>specifiedView</code>和<code>superView</code></p></blockquote><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/09/iOS-面向协议封装全屏旋转功能/lxf_FullScreenable_2.gif" alt="lxf_FullScreenable_2"></p><h2 id="三、FullScreenableConfig说明"><a href="#三、FullScreenableConfig说明" class="headerlink" title="三、FullScreenableConfig说明"></a>三、FullScreenableConfig说明</h2><blockquote><p>上述的方法都有一个<code>config</code>参数，默认为nil，即为默认配置</p></blockquote><p>相关属性说明<br>| Name                       | Type                     | Desc                           | Default        |<br>| ————————– | ———————— | —————————— | ————– |<br>| animateDuration            | <code>Double</code>                 | 进入/退出 全屏时的旋转动画时间 | 0.25           |<br>| enterFullScreenOrientation | <code>UIInterfaceOrientation</code> | 进入全屏时的初始方向           | landscapeRight |</p><p>这里我们把动画时间设置为<code>1s</code>，初始方向为<code>左</code>后来看看效果<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FullScreenableConfig</span>(</span><br><span class="line">    animateDuration: <span class="number">1</span>,</span><br><span class="line">    enterFullScreenOrientation : .landscapeLeft</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cyanView.lxf.enterFullScreen(config: diyConfig)</span><br><span class="line">cyanView.lxf.exitFullScreen(config: diyConfig)</span><br></pre></td></tr></table></figure></p><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/09/iOS-面向协议封装全屏旋转功能/lxf_FullScreenable_3.gif" alt="lxf_FullScreenable_3"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里相关的说明已罗列完毕，有什么不清楚的可以下载<a href="https://github.com/LinXunFeng/LXFProtocolTool/tree/master/Example/LXFProtocolTool/Demo/LXFFullScreenable" target="_blank" rel="noopener">Demo</a>看看，或者在文章下方留言提问</p><p><a href="https://github.com/LinXunFeng/LXFProtocolTool" target="_blank" rel="noopener">LXFProtocolTool</a> 主要是通过协议的方式来方便快捷地实现一些的实用功能，除了本文提及的全屏旋转功能外还有其它实用功能的封装，具体内容可以到 <a href="https://github.com/LinXunFeng/LXFProtocolTool/wiki" target="_blank" rel="noopener">Wiki首页</a>  查找。如果你有什么想实现的功能也可以提出来，喜欢的就给个Star鼓励下我吧 🚀 🚀 🚀，感谢支持！</p>]]></content>
    
    
    <summary type="html">&lt;Excerpt in index | 首页摘要&gt; 

&lt;blockquote&gt;
&lt;p&gt;关于使用面向协议来封装功能的实战可以参考我上篇文章 &lt;a href=&quot;/2018/04/07/iOS-面向协议方式封装空白页功能/&quot;&gt;【iOS-面向协议方式封装空白页功能】&lt;/a&gt;，这里就不再赘述，我们直接进入使用阶段吧。&lt;br&gt;本篇文章只有一个目的，那就是只要遵守协议，一行代码随意切换全屏～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果对面向协议有疑问的同学可以看下我之前的两篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2017/09/12/iOS-Swift-面向协议编程（一）/&quot;&gt;iOS - Swift 面向协议编程（一）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2017/09/12/iOS-Swift-面向协议编程（二）/&quot;&gt;iOS - Swift 面向协议编程（二）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;+</summary>
    
    
    
    <category term="iOS" scheme="http://linxunfeng.top/categories/iOS/"/>
    
    
    <category term="iOS" scheme="http://linxunfeng.top/tags/iOS/"/>
    
    <category term="Swift" scheme="http://linxunfeng.top/tags/Swift/"/>
    
  </entry>
  
</feed>
