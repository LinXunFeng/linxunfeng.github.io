{"meta":{"title":"LinXunFeng‘s Blog","subtitle":null,"description":null,"author":"LinXunFeng","url":"http://linxunfeng.top"},"pages":[{"title":"","date":"2021-03-03T04:54:43.564Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"baidu_verify_9LgZ2AlWYS.html","permalink":"http://linxunfeng.top/baidu_verify_9LgZ2AlWYS.html","excerpt":"","text":"9LgZ2AlWYS"},{"title":"","date":"2021-03-03T04:54:43.564Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"googleb87ab619c549d502.html","permalink":"http://linxunfeng.top/googleb87ab619c549d502.html","excerpt":"","text":"google-site-verification: googleb87ab619c549d502.html"},{"title":"404 Not Found：该页无法显示","date":"2021-03-03T04:54:43.560Z","updated":"2021-03-03T04:54:43.560Z","comments":false,"path":"/404.html","permalink":"http://linxunfeng.top/404.html","excerpt":"","text":""},{"title":"关于作者","date":"2017-09-12T00:31:09.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"about/index.html","permalink":"http://linxunfeng.top/about/index.html","excerpt":"","text":"联系如有意向合作者，请\b联系我 邮箱：linxunfeng@yeah.net 坐标： \b深圳"},{"title":"分类","date":"2020-07-30T22:59:46.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"categories/index.html","permalink":"http://linxunfeng.top/categories/index.html","excerpt":"","text":""},{"title":"友情鏈接","date":"2020-07-30T22:54:31.000Z","updated":"2021-03-03T04:54:43.712Z","comments":true,"path":"link/index.html","permalink":"http://linxunfeng.top/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-09-12T00:35:26.000Z","updated":"2021-03-03T04:54:43.712Z","comments":true,"path":"tags/index.html","permalink":"http://linxunfeng.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker - Dockerfile的使用","slug":"/pages/05278d/","date":"2021-01-31T14:23:49.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2021/01/31//pages/05278d//","link":"","permalink":"http://linxunfeng.top/2021/01/31/pages/05278d/","excerpt":"","text":"Dockerfile: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 应用: 将部署过程中涉及到的所有步骤全部写入到 Dockerfile 中，到时只需要执行 Dockerfile 就可以自动完成相应的操作 快速入门编辑Dockerfile在当前目录下创建 Dockerfile 并进行编辑1vim Dockerfile操作：启动 ubuntu 镜像，在启动起来后去更新 ubuntu 容器下的软件资源内容如下1234# From: 启动运行一个镜像资源From ubuntu# Run: 在启动起来的容器中执行指令RUN apt-get update 运行Dockerfile构建镜像命令1docker build -t [镜像名]:[版本号] [Dockerfile所在目录]指定在当前目录下去查找 Dockerfile 文件，并将 Dockerfile 自动化处理后的（更新了软件资源）容器打成名为 lxf 的镜像资源 1docker build -t lxf . 执行效果：待执行完成后，当前拥有的镜像资源就多出了 lxf 这一个，可以看到 lxf 这个镜像的大小是要比 ubuntu 的镜像要大一点的 基础指令详解FROM格式：12FROM &lt;image&gt;FROM &lt;image&gt;:&lt;tag&gt;说明： FROM 是 Dockerfile 里的第一条而且只能是除了首行注释之外的第一条指令 RUN格式：12345# shell模式RUN &lt;command&gt;# exec模式RUN [\"executable\", \"param1\", \"param2\"]说明： 表示当前镜像构建时候运行的命令 注释：12345# shell 模式：类似于 /bin/bash -c command RUN echo hello # exec 模式：类似于 RUN [\"/bin/bash\", \"-c\", \"command\"] RUN [\"echo\", \"hello\"] 执行多条指令 一条条指令写 12RUN echo helloRUN echo world 将指令用 &amp;&amp; 连接起来 1RUN echo hello &amp;&amp; echo world MAINTAINER格式：1MAINTAINER &lt;name&gt;说明： 指定该 Dockerfile 文件的维护者信息 EXPOSE 设置容器对外开放的端口 格式：1EXPOSE &lt;port&gt; [&lt;port&gt;...]解释： 设置 Docker 容器对外暴露的端口号， Docker 为了安全，不会自动对外打开端口，如果需要外部提供访问，还需要启动容器时增加 -p 或者 -P 参数对容器的端口进行分配。 ENTRYPOINT 设置容器在启动后去执行一个命令 格式：12345# exec 模式ENTRYPOINT [\"executable\", \"param1\",\"param2\"]# shell模式ENTRYPOINT command param1 param2解释： 每个 Dockerfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效。 EXPOSE 和 ENTRYPOINT 结合使用的例子，可以全文看完后再回到这里看该例子123456789101112# 使用django镜像资源From django# 切换目录WORKDIR /home# 创建一个名为lxf的django项目RUN django-admin startproject lxf# 切换目录WORKDIR /home/lxf# 对外开放8000端口EXPOSE 8000# 容器启动后，将django服务开启，并指定端口号为8000ENTRYPOINT python3 manage.py runserver 0.0.0.0:8000执行构建镜像命令1docker build -t lxf .现在我们将构建好的 lxf 容器运行起来，并随机分配端口 1docker run -dit -P lxf 可以看到， Docker 为我们随机分配了 55001 端口映射到容器的 8000 端口，并且可以正常访问到容器的 django 服务 文件指令详解ADD格式：12ADD &lt;src&gt;... &lt;dest&gt;ADD [\"&lt;src&gt;\",... \"&lt;dest&gt;\"]说明： 将指定的 &lt;src&gt; 文件复制到容器文件系统中的 &lt;dest&gt; src 指的是宿主机，dest 指的是容器 如果源文件是个压缩文件，则 Docker 会自动帮解压到指定的容器中(无论目标是文件还是目录，都会当成目录处理)。 如：将宿主机下的 ./data 目录下的所有文件(夹)，全部复制到容器的 /home 目录下12From ubuntuADD ./data /home注：目录本身即 data 目录并不会复制到容器中，只复制 data 目录下的文件(夹)，如果想连同 data 文件夹也复制过去，可以修改为如下指令12From ubuntuADD ./data /home/data COPY格式：12COPY &lt;src&gt;... &lt;dest&gt;COPY [\"&lt;src&gt;\",... \"&lt;dest&gt;\"]解释： 单纯复制文件场景， Docker 推荐使用 COPY 如果源文件是个压缩文件， Docker 会直接将压缩文件复制进容器内，不会像 ADD 那样先解压再复制 注： COPY 与 ADD 基本上是一样的，只是面对源文件是压缩文件时处理方式不同而已， ADD 会先解压再将解压后的内容复制到容器， COPY 不会进行解压，而是直接将压缩包复制过去 环境指令详解ENV 设置环境变量 格式：12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ...解释： 设置环境变量，可以在 RUN 之前使用，然后 RUN 命令时调用，容器启动时这些环境变量都会被指定 如：设置了环境变量 name ，并赋值为 lxf ，使用 RUN 命令打印 name 变量的值，可以成功打印出来12ENV name=lxfRUN echo $name # 会打印出lxf并且，当进入容器后也可以正常打印出该变量的值12root@5721971f92e4:/# echo $namelxf WORKDIR 切换目录 格式：1WORKDIR /path/to/workdir解释： 切换目录，为后续的 RUN 、 CMD 、 ENTRYPOINT 指令配置工作目录。 相当于 cd 命令，可以使用多个 WORKDIR 指令进行多次切换，后续命令如果参数是相对路径，则会基于之前命令指定的路径 如果我们指定切换到一个不存在的目录， Docker 会帮我们自动创建相应的目录 举例：1234WORKDIR /aWORKDIR bWORKDIR cRUN pwd最终路径为 /a/b/c 如果我们想要容器被运行起来时，自动进入到 /home ，可以按如下指令设置12From ubuntuWORKDIR /home执行 Dockerfile 构建镜像完成后运行起来，此时容器便会自动进入到 /home 目录对比一下之前没有设置使用过 WORKDIR ，运行起来的容器，会默认进入到根目录","categories":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/tags/Docker/"}]},{"title":"Docker - 网络管理","slug":"/pages/337d0f/","date":"2021-01-31T14:23:39.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2021/01/31//pages/337d0f//","link":"","permalink":"http://linxunfeng.top/2021/01/31/pages/337d0f/","excerpt":"","text":"默认情况下，容器和宿主机之间网络是隔离的 现在启动了一个 nginx 容器如图所示 nginx 使用了 80 端口，但是我们去浏览器里访问 localhost:80 是无法访问到 nginx 服务的这个时候可以通过端口映射的方式，将容器中的端口，映射到宿主机的某个端口上，从而使我们能够通过宿主机的 ip+端口 的方式来访问容器里的内容 随机端口映射 -P ：自动绑定所有对外提供服务的容器端口，映射的端口会从没有使用的端口池中自动随机选择，如果连续启动多个容器的话，则下一个容器的端口默认是当前容器的端口号+1 命令1docker run -d -P [镜像名称]在刚才的命令基本上加 -P1docker run -dit -P --name lxfnginx nginx这样宿主机的 55000 端口就映射到了窗口的 80 端口，访问也是成功的。 指定端口映射命令1docker run -d -p [宿主机ip]:[宿主机端口]:[容器端口] --name [容器名称] [镜像名称]将宿主机上的 8000 端口映射到 nginx 容器的 80 端口1docker run -dit -p 8000:80 --name lxfnginx nginx再去访问 localhost:8000 时也是可以正常访问到的 0.0.0.0 表示地址全匹配，即 127.0.0.1 或者宿主机的局域网IP 192.168.1.x 这种都可以访问到 nginx 服务，如果我们想指定绑定的 IP ，可以在映射端口前加上 IP 即可 1docker run -dit -p 192.168.1.234:8000:80 --name lxfnginx nginx 虽然图中显示的是 127.0.0.1:55000-&gt;80 ，但是经过测试 192.168.1.234:8000 是可以正常访问 127.0.0.1:55000 和 127.0.0.1:8000 无法访问 多端口映射命令1docker run -d -p [宿主机端口1]:[容器端口1] -p [宿主机端口2]:[容器端口2] --name [容器名称] [镜像名称]如下命令所示1docker run -d -p 7000:443 -p 8000:80 --name lxfnginx nginx 共享网络 共享网络: 容器与宿主机共享网络信息 默认情况下，容器的网络信息与宿主机是相互独立的，这样会有什么问题呢？ 假如运行一个提供了 django 服务的容器，宿主机本地提供了 MySql 服务，此时容器想访问宿主机的数据库，是无法访问到的，这个时候容器就需要共享宿主机的网络 在启动容器时，加上 --network=host 即可共享网络，命令如下1docker run -dit --network=host lxf_django这样，容器与宿主机的网络就是共享的状态，此时的容器也就可以访问到宿主机的数据库了","categories":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/tags/Docker/"}]},{"title":"Docker - 数据管理","slug":"/pages/867207/","date":"2021-01-31T14:23:29.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2021/01/31//pages/867207//","link":"","permalink":"http://linxunfeng.top/2021/01/31/pages/867207/","excerpt":"","text":"拷贝数据宿主机文件 -&gt; 容器内1docker cp 需要拷贝的文件或目录 容器名:容器内的目录路径 如：把宿主机当前目录下的 lxf.sh 文件，拷贝到 lxfubuntu1 容器下的 /data 目录中1docker cp lxf.sh lxfubuntu1:/data 容器内 -&gt; 宿主机文件1docker cp 容器名:容器内需要拷贝的文件或目录 宿主机目录 如：把 lxfubuntu1 容器中 /data 目录下的 lxf.sh 文件，拷贝到宿主机 ~/lxf/ 目录下1docker cp lxfubuntu1:/data/lxf.sh ~/lxf/ 数据卷管理 数据卷管理就是将容器的某个目录，映射到宿主机，作为数据存储同步的目录 命令：1docker run -itd --name [容器名字] -v [宿主机目录]:[容器目录] [镜像名称] [命令(可选)]下面进行操作示范： 在宿主机创建一个名为 data 的目录，这个名字可任意1mkdir data将宿主机的 data 目录映射到容器中的 /home 目录1docker run -it -v ~/lxf/data:/home ubuntu /bin/bash-v ：挂载一个数据卷接着，我在容器的 /home 目录下创建一个 lxfdir 目录此时，宿主机的 data 目录下也会同步多了一个 lxfdir 目录 这个宿主机的 data 目录就叫数据卷。 除了宿主机与容器之间可以进行数据交互外，如果两个容器的目录都映射到同一个宿主机目录，那还可以让多个容器间进行数据共享。 数据卷容器 数据卷容器也是一个容器，目的是专门用于提供数据卷给其它容器挂载，从而实现多个容器之间同步数据的更新。 创建数据卷模板容器命令：1docker create -v [容器数据卷目录] --name [容器名字] [镜像名称] [命令(可选)]对ubuntu 镜像做了文件映射，得到数据卷目录为 /data 的模板容器1docker create -v /data ubuntu注意看该模板容器的状态是 Created ，即并没有运行，容器名为 determined_nightingale 基于数据卷模板创建容器命令:1docker run --volumes-from [数据卷容器id/name] -tid --name [容器名字] [镜像名称] [命令(可选)]创建 lxfubuntu1 容器1docker run -it --volumes-from determined_nightingale --name lxfubuntu1 ubuntu /bin/bash在容器的根目录下，会基于上述模板创建了一个名为 data 的目录（原 ubuntu 镜像中是没有的） 我们再创建一个 lxfubuntu2 容器1docker run -it --volumes-from determined_nightingale --name lxfubuntu2 ubuntu /bin/bash此时，我们在 lxfubuntu1 的 data 目录下创建一个名为 lxf 的目录， lxfubuntu2 的 data 目录中也会同步到相同的数据这样，只要我们是基于数据卷模板容器创建出来的容器，就可以得到一个数据共享的 data 目录，在该 data 目录中对文件的操作，都可以同步到各个由该模板容器创建出来的容器中。 与宿主机同步文件 数据卷容器可以实现多个容器的数据同步，但是数据是保存在数据卷内，并没有保存到宿主机的文件目录中。 如果想将宿主机的文件同步到各个容器，可以使用 docker cp 将宿主机下的文件拷贝到数据卷容器即可，反之亦然 如：把宿主机当前目录下的 lxf.sh 文件，拷贝到数据卷容器 determined_nightingale 中 /data 目录下1docker cp lxf.sh determined_nightingale:/data如：把数据卷容器 determined_nightingale 中 /data 目录下的 lxf.sh 文件，拷贝到宿主机 ~/lxf 目录下1docker cp determined_nightingale:/data/lxf.txt ~/lxf是不是有人要问了，如果我基于数据卷模板创建容器时，顺带设置数据卷呢？，命令如下所示1docker run -it -v ~/lxf/data:/data --volumes-from determined_nightingale --name lxfubuntu3 ubuntu /bin/bash很遗憾，只有数据卷配置生效，数据卷容器配置不生效～","categories":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/tags/Docker/"}]},{"title":"Docker - 私有仓库Registry","slug":"/pages/bfa843/","date":"2021-01-31T14:23:19.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2021/01/31//pages/bfa843//","link":"","permalink":"http://linxunfeng.top/2021/01/31/pages/bfa843/","excerpt":"","text":"私有仓库: 在本地（局域网）搭建的一个类似公共仓库的东西，我们可以将镜像提交到私有仓库中，供局域网内的其它人拉取使用。本文以 Registry 为例，并在提供私有仓库的主机上操作 拉取私有仓库镜像请先确保你当前拥有的镜像有 registry如果没有，可以先拉取下来 1docker image pull registry 设置私有仓库地址1vim /etc/docker/daemon.json 修改 insecure-registries 的值，提供私有仓库的主机的ip地址和端口1234567&#123; ... \"insecure-registries\":[ \"192.168.1.234:5000\" ], ...&#125;Mac软件版修改后重新启动 docker 服务 运行私有仓库镜像资源将 registry 镜像生成一个容器并运行起来123# -p 5000:5000 # 第一个是容器使用的端口，第二个是本地端口，这里是本地端口映射到把容器的端口docker run -d -p 5000:5000 registry1234~/lxf ❯ docker ps❯ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESf12ad7ae43ca registry \"/entrypoint.sh /etc…\" 9 minutes ago Up 9 minutes 5000/tcp nostalgic_elion此时你可以访问如下地址，如果看到 {} 就说明 Registry 运行正常1http://192.168.1.234:5000/v2/ 上传镜像比如此时我要将 ubuntu 这个镜像上传到私有仓库12# 给ubuntu镜像打一个tag，命名需为 私有仓库主机ip:端口/镜像名:[版本号,不加默认为latest]docker tag ubuntu:latest 192.168.1.234:5000/ubuntu:v0.1开始上传镜像至本地的私有仓库中 12# docker push &lt;registry_ip&gt;:&lt;registry_port&gt;/&lt;image_name&gt;:&lt;image_tag&gt;docker push 192.168.1.234:5000/ubuntu:v0.1 拉取镜像先将本地的 v0.1 删掉1docker rmi 192.168.1.234:5000/ubuntu:v0.1拉取私有仓库中 ubuntu 的 0.1 版本镜像12# docker pull &lt;registry_ip&gt;:&lt;registry_port&gt;/&lt;image_name&gt;:&lt;image_tag&gt;docker pull 192.168.1.234:5000/ubuntu:v0.1 搜索镜像Registry 不支持通过 docker search 这种方式去搜索镜像，会报 404 的错误需要使用 V2 API 去查询 列出仓库中所有的镜像1curl 192.168.1.234:5000/v2/_catalog 列出指定镜像的所有标签12# curl -X GET http://&lt;registry_ip&gt;:&lt;registry_port&gt;/v2/&lt;image_name&gt;/tags/listcurl 192.168.1.234:5000/v2/lxf/tags/list 删除镜像查找指定标签的镜像的 digest ，再根据这个 digest 来删除，以删除 lxf:0.2 镜像为例 先执行命令找到该镜像的 digest1curl -v --silent -H \"Accept: application/vnd.docker.distribution.manifest.v2+json\" -X GET http://192.168.1.234:5000/v2/lxf/manifests/0.2 2&gt;&amp;1 | grep Docker-Content-Digest | awk '&#123;print ($3)&#125;'得到输出值1sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241根据 digest 来删除镜像1curl -v --silent -H \"Accept: application/vnd.docker.distribution.manifest.v2+json\" -X DELETE http://192.168.1.234:5000/v2/lxf/manifests/sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241这个时候只是删除镜像的元数据，并没有真正从硬盘上删除镜像，需要执行垃圾回收才行。 删除失败遇到 405 UNSUPPORTED 错误 需要在运行 Registry 容器时设置REGISTRY_STORAGE_DELETE_ENABLED 为 true 举例 docker-compose.yaml：设置环境变量 12environment: REGISTRY_STORAGE_DELETE_ENABLED: \"true\" docker run：添加参数12# -e REGISTRY_STORAGE_DELETE_ENABLED=\"true\"docker run -d -p 5000:5000 -e REGISTRY_STORAGE_DELETE_ENABLED=\"true\" registry 垃圾回收 执行垃圾回收，上述删除的镜像才会真正从硬盘上移除 1docker exec -it registry的容器名 /bin/registry garbage-collect /etc/docker/registry/config.yml","categories":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/tags/Docker/"}]},{"title":"Docker - 操作容器","slug":"/pages/861244/","date":"2021-01-31T14:22:18.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2021/01/31//pages/861244//","link":"","permalink":"http://linxunfeng.top/2021/01/31/pages/861244/","excerpt":"","text":"运行容器这里我使用 ubuntu 镜像，创建一个名为 lxfubuntu 的容器，并运行进入容器123# docker run -it --name [容器名] [镜像名] /bin/bashdocker run -it --name lxfubuntu ubuntu /bin/bash命令参数详解： --name : 定义容器名称，如果不使用，则会随机产生一个名字 -i : 让容器的标准输入保持打开 -t : 让 docker 分配一个伪终端，并绑定到窗口的标准输入上 -d : 以守护进程的方式运行容器，不占用终端 /bin/bash : 执行一个命令 如图，执行后即可进入容器中 如果想创建并以守护进程的方式运行容器，可以使用 -d1docker run -dit --name lxfubuntu1 ubuntu /bin/bash 123# docker start [container_id]docker start c97abc3f151a 进入容器如果我们想进入上述提及的以守护进程方式运行的容器中，可以使用 docker exec1docker exec -it lxfubuntu1 /bin/bash如果在此时退出该守护进程的容器时，该容器依旧在后台运行 退出容器两种方式 方法一： 终端输入 exit 后回车 方法二： Ctrl + D 如果容器是以守护进程的方式运行，在进入容器后退出，不停止容器的运行，即依旧在后台运行，否则将在容器退出时顺带停止容器 停止容器12345# docker stop [container_id|container_name]docker stop lxfubuntu1# 或docker stop c97abc3f151a 启动容器12345# docker start [container_id|container_name]docker start lxfubuntu1# 或docker start c97abc3f151a 重启容器12345# docker restart [container_id|container_name]docker restart lxfubuntu1# 或docker restart c97abc3f151a 查看容器查看正在运行的容器123docker container ls# 或docker ps 查看所有的容器，包括已经停止的容器12345docker container ls -adocker container ls --all# 或docker ps -adocker ps --all 如果只是想查看容器的ID，可以使用参数 -q1docker ps -aq 删除容器12345# docker [container] rm [container_id|container_name]docker container rm lxfubuntu# 或docker rm lxfubuntu1 如果删除一个正在运行的容器，需要加 -f 结合上述查看容器中 -q 的功能，可以实现批量删除容器的功能12# docker ps -aq 获取所有的容器iddocker rm -f $(docker ps -aq) 查看容器详情123# docker inspect [container_id|container_name]docker inspect lxfubuntu1 查看容器状态123# docker container stats [container_id|container_name]docker container stats lxfubuntu1 打包容器为新的镜像资源 容器在安装了各种各样的服务后，将该容器打包为镜像资源，接着将该镜像资源进行打包，最后再发给其它人使用 将 lxfubuntu1 这个容器打包成名为 my_image 的镜像12# docker commit 容器名 镜像资源名docker commit lxfubuntu1 my_image","categories":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/tags/Docker/"}]},{"title":"Docker - 操作镜像资源","slug":"/pages/084bf9/","date":"2021-01-24T22:38:10.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2021/01/24//pages/084bf9//","link":"","permalink":"http://linxunfeng.top/2021/01/24/pages/084bf9/","excerpt":"","text":"搜索镜像资源1docker search nginx 一般选择 STARS 数最大的 拉取镜像比如拉取上提及的 nginx 镜像1docker image pull nginx命令执行后就开始对镜像进行拉取了 查看当前拥有的镜像 镜像ID: 镜像的唯一标识，如果镜像ID相同，则说明是同一个镜像 TAG: 用来区分不同的发行版本，如果不指定具体标记，则默认使用latest来标记信息 123docker image ls# 或docker images 查看镜像的详情信息12# docker image inspect 镜像名docker image inspect ubuntu 删除镜像完整写法1docker image rm ubuntu简洁写法1docker rmi ubuntu除了可以根据镜像名来删除外，也可以使用镜像ID，如使用上述的 ubuntu 镜像ID1docker rmi f643c72bc252如果我们对同一个镜像打了多个 tag ，导致同一个镜像ID存在多个镜像名称，那此时可以使用 name:tag 的格式来删除镜像，如：123docker rmi ubuntu:latest# docker rmi ubuntu_lxf:v1.0 镜像标签1234# docker tag 当前镜像名:镜像版本 新的镜像名:新的版本docker tag ubuntu:latest ubuntu_lxf:latest# docker tag ubuntu:latest ubuntu_lxf:v1.0 注： ubuntu 和 ubuntu_lxf 的 IMAGE_ID 是相同的 结合删除镜像的命令就可以实现镜像重命名功能 导出镜像 docker save 会保存镜像的所有历史记录和元数据信息 12345# docker save -o 包文件 镜像docker save -o ubuntu.tar ubuntu# docker save 镜像1 ... 镜像n &gt; 包文件docker save ubuntu nginx &gt; lxf_images.tar 导入镜像先删除 ubuntu 镜像 12345678# docker load -i 镜像包名docker load -i ubuntu.tar# docker load &lt; 镜像包名docker load &lt; ubuntu.tar# docker load --input 镜像包名docker load --input ubuntu.tar 可以看到， ubuntu 镜像已经成功导入进来了 查看镜像历史123# docker image history 镜像名docker image history ubuntu","categories":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/tags/Docker/"}]},{"title":"Docker - 安装、加速和基本使用","slug":"/pages/2ffb7f/","date":"2021-01-24T21:52:14.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2021/01/24//pages/2ffb7f//","link":"","permalink":"http://linxunfeng.top/2021/01/24/pages/2ffb7f/","excerpt":"","text":"Docker 容器是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何安装了docker引擎的服务器上 本文主要以 Mac 平台为例 安装方式一: Homebrew1brew cask install docker 方式二: 桌面程序 我使用该方式 访问 https://www.docker.com/get-started，在 Docker Desktop 下选择你当前系统对应的软件进行下载安装 镜像加速镜像Daocloud 实测，速度不咋地 打开 daocloud.io 网站，注册并登录，点击加速器按钮，或者直接打开 https://www.daocloud.io/mirror，打开的页面上会显示与你账号相关的加速地址 其它 实测，速度杠杠的，推荐使用 镜像 地址 Docker中国区官方镜像 https://registry.docker-cn.com 网易 http://hub-mirror.c.163.com ustc https://docker.mirrors.ustc.edu.cn 1234567&#123; &quot;registry-mirrors&quot;: [ &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;, &quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;, &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot; ]&#125; 配置 该部分内容取自 daocloud Linux1curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;xxx.m.daocloud.io 该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。 macOSDocker For Mac 右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中加入下面的镜像地址: 1http:&#x2F;&#x2F;xxx.m.daocloud.io 点击 Apply &amp; Restart 按钮使设置生效。 Docker Toolbox 等配置方法请参考帮助文档。 我自己的版本是 3.1.0(51484) ，与上述的不太一致。 如图所示，切换到 Docker Engine 下，在右侧所示的 JSON 内容中添加 registry-mirrors 1&quot;registry-mirrors&quot;: [&quot;你的加速器地址&quot;] 最后点击 Apply&amp;Restart 按钮即可。 WindowsDocker For Windows 在桌面右下角状态栏中右键 docker 图标，修改在 Docker Daemon 标签页中的 json ，把下面的地址: 1http:&#x2F;&#x2F;xxx.m.daocloud.io 加到” registry-mirrors”的数组里。点击 Apply 。 Docker Toolbox 等配置方法请参考帮助文档。 基本使用查看版本1docker -v 输出结果 1Docker version 20.10.2, build 2291f61 查看Docker信息1docker info 可以使用该命名查看当前的镜像地址数组 123456789101112...Registry: https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;Labels:Experimental: trueInsecure Registries: 127.0.0.0&#x2F;8Registry Mirrors: https:&#x2F;&#x2F;registry.docker-cn.com&#x2F; http:&#x2F;&#x2F;hub-mirror.c.163.com&#x2F; https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&#x2F;Live Restore Enabled: false...","categories":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://linxunfeng.top/tags/Docker/"}]},{"title":"Flutter - 低版本在iOS14上遇到的问题与解决方案","slug":"Flutter/Flutter - 低版本在iOS14上遇到的问题与解决方案","date":"2020-09-29T00:00:00.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2020/09/29/Flutter/Flutter - 低版本在iOS14上遇到的问题与解决方案/","link":"","permalink":"http://linxunfeng.top/2020/09/29/Flutter/Flutter%20-%20%E4%BD%8E%E7%89%88%E6%9C%AC%E5%9C%A8iOS14%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"近期将测试机升级至 iOS14 ，测试使用 Flutter混合开发 的线上 APP，没发现什么问题，但是使用 Xcode 安装APP 的场景下，断开 Xcode 后再运行却闪退了。 +","text":"近期将测试机升级至 iOS14 ，测试使用 Flutter混合开发 的线上 APP，没发现什么问题，但是使用 Xcode 安装APP 的场景下，断开 Xcode 后再运行却闪退了。 + 一、概述近期将测试机升级至 iOS14 ，测试使用 Flutter混合开发 的线上 APP，没发现什么问题，但是使用 Xcode 安装APP的场景下，断开 Xcode 后再运行却闪退了。 公司的 APP 测试结果如下： APP来源 是否闪退 模式 线上 否 release 蒲公英 是 debug Xcode 是（断开 Xcode 后再打开 APP ） debug 问题原因闪退的原因是因为 Flutter SDK, Flutter 官方的更新速度也是快，对 iOS14 进行了说明： Flutter官网说明链接 大致意思就是说，如果我们在 iOS14 的真机上安装了 debug模式 编译出来的 flutter 应用，那么在断开编译安装连接后，将无法从桌面上打开该应用程序。 解决方案 再次是使用 Xcode 或 flutter run 来运行。 设置 Flutter 模块的编译模式为 profile 或 release 补充说明 该闪退的情况只发生在真机，并且在模拟器运行的时候， Flutter 模块的编译模式需要为 debug， 如果设置了 release，编译将会报错。 官方指出如果是 纯Flutter项目 可以直接使用 master channel 的 Flutter版本 秒杀这个问题，但对混合开发并没有该说明，加上我们是使用闲鱼的 flutter_boost 实现的混合开发，限制了 Flutter 的版本，所以我也就没有去实践该方案对我们是否可行 二、尝试解决根据自己的实际情况，我选择了上述的第二个解决方案。 配置用 Xcode 打开工程项目，在 Build Settings 的最下方找到 User-Defined，点击 + 按钮，添加一个键为 FLUTTER_BUILD_MODE ，值为 release 的配置。 运行再次运行到真机上，断开 Xcode 运行也不会崩溃了 问题真机的问题看似是解决了，但是会有问题 问题一：release 或 profile 模式下，Flutter 使用的是 AOT，一些功能不能使用，如：代码断点调试，热重载 问题二：上面也提到了，模拟器只能运行在 debug 模式下，而我们无法避免会在真机和模拟器之间反复切换运行，每次切换就需要手动调整 FLUTTER_BUILD_MODE 的值，十分麻烦 那有什么好的办法解决上面遇到的问题呢？ 三、优化方案其实，真机上的 APP 在断开 Xcode 后无法运行，这个对我们开发者来说不是什么问题，问题是给到测试人员就必须要可以打开才行，包括蒲公英上的包，所以为了节省这些不必要的时间，我们需要自己动手撸一个帮助我们切换 Flutter编译模式 的脚本。 在修改 FLUTTER_BUILD_MODE 的值时，我从 git 中发现，实际上是修改了 项目.xcodeproj，那目前有什么工具可以帮助我们修改 xcodeproj 文件呢？ 这里我找到了mod-pbxproj，安装和使用在该库的 wiki 上写的很清楚，这里就不再赘述了，直接上代码 1234567891011121314151617181920212223242526272829303132333435363738import getoptimport sysfrom pbxproj import XcodeProjectif __name__ == \"__main__\": argv = sys.argv[1:] # 处理flutter_build_mode flutter_build_mode = (False, \"release\") # target名称 target_name = None try: opts, args = getopt.getopt(argv, \"p:m:t:\", [\"path=, mode=, target=\"]) except getopt.GetoptError: print('switch_flutter_build_mode.py -p \"plist文件路径\" -m \"模式(release|debug)\" -t \"target名称\"') sys.exit(1) for opt, arg in opts: if opt in [\"-p\", \"--path\"]: project_path = arg if len(project_path) == 0: print('请输入项目的地址') sys.exit(2) if opt in [\"-m\", \"--mode\"]: flutter_build_mode = (True, arg if len(arg) &gt; 0 else \"release\") if opt in [\"-t\", \"--target\"]: target_name = arg # 处理flutter if flutter_build_mode[0]: fileName = project_path.split(\"/\")[-1] if not fileName.endswith(\"xcodeproj\"): print(\"请使用-p指定.xcodeproj文件的路径\") sys.exit(3) project = XcodeProject.load(project_path + '/project.pbxproj') # 设置 User-Defined (如果target_name是None，则每个target都会设置flag) project.set_flags('FLUTTER_BUILD_MODE', flutter_build_mode[1], target_name) project.save() 使用也很简单，终端直接输入如下命令 1python switch_flutter_build_mode.py -p 'xxx/项目.xcodeproj' -t target名称 -m release 各参数说明 参数 用途 -p xcodeproj 文件的路径 -t target 名称 -m 编译模式 ( release、debug、profile ) PS: 脚本基于 Python3 我们是使用 Jenkins 进行打包并自动上传至蒲公英的，所以只需要在 Jenkins 中配置打包前调用该脚本即可。 最后再结合 Shuttle 这个软件，就可以实现以界面的方式去切换编译模式了 四、最后说两句本文是基于 Flutter混合开发 进行说明的，如果有什么不对或不足的地方，欢迎指正，感谢大家的阅读","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/categories/Flutter/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://linxunfeng.top/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/tags/Flutter/"}]},{"title":"分享 - Flutter打造好用的打印工具类","slug":"Share/分享 - Flutter打造好用的打印工具类","date":"2020-09-11T00:00:00.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2020/09/11/Share/分享 - Flutter打造好用的打印工具类/","link":"","permalink":"http://linxunfeng.top/2020/09/11/Share/%E5%88%86%E4%BA%AB%20-%20Flutter%E6%89%93%E9%80%A0%E5%A5%BD%E7%94%A8%E7%9A%84%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。 +","text":"如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。 + 一、思考做 iOS 开发的同学都知道，我们在平时开发过程中，经常会用到非常实用的自定义打印功能，方便我们快速定位是在哪个控制器，哪一行代码。 在 OC 和 Swift 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，这里以 Swift 的打印为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374enum LogType: String &#123; case error = \"❤️ ERROR\" case warning = \"💛 WARNING\" case info = \"💙 INFO\" case debug = \"💚 DEBUG\"&#125;let log = Logger.sharedfinal class Logger &#123; static let shared = Logger() private init() &#123; &#125; static let logDateFormatter: DateFormatter = &#123; let f = DateFormatter() f.dateFormat = \"yyyy-MM-dd HH:mm:ss.SSS\" return f &#125;()&#125;extension Logger &#123; func error&lt;T&gt;( _ message : T, file : StaticString = #file, function : StaticString = #function, line : UInt = #line ) &#123; LXFLog(message, type: .error, file : file, function: function, line: line) &#125; func warning&lt;T&gt;( _ message : T, file : StaticString = #file, function : StaticString = #function, line : UInt = #line ) &#123; LXFLog(message, type: .warning, file : file, function: function, line: line) &#125; func info&lt;T&gt;( _ message : T, file : StaticString = #file, function : StaticString = #function, line : UInt = #line ) &#123; LXFLog(message, type: .info, file : file, function: function, line: line) &#125; func debug&lt;T&gt;( _ message : T, file : StaticString = #file, function : StaticString = #function, line : UInt = #line ) &#123; LXFLog(message, type: .debug, file : file, function: function, line: line) &#125;&#125;// MARK:- 自定义打印方法// target -&gt; Build Settings 搜索 Other Swift Flags// 设置Debug 添加 -D DEBUGfunc LXFLog&lt;T&gt;( _ message : T, type: LogType, file : StaticString = #file, function : StaticString = #function, line : UInt = #line) &#123; #if DEBUG let time = Logger.logDateFormatter.string(from: Date()) let fileName = (file.description as NSString).lastPathComponent print(\"\\(time) \\(type.rawValue) \\(fileName):(\\(line))-\\(message)\") #endif&#125; 使用及打印结果： 1234567891011log.debug(\"models count -- \\(models.count)\")log.warning(\"models count -- \\(models.count)\")log.info(\"models count -- \\(models.count)\")log.error(\"models count -- \\(models.count)\")/*💚 DEBUG XXXViewController.swift:(79)-models count -- 10💛 WARNING XXXViewController.swift:(80)-models count -- 10💙 INFO XXXViewController.swift:(81)-models count -- 10❤️ ERROR XXXViewController.swift:(82)-models count -- 10*/ OC 和 Swift 的预处理宏对应表 OC Swift __FILE__ #file 打印当前文件路径 __LINE__ #line 打印当前行号，整数 __FUNCTION__ #function 打印当前函数或方法 但是在 Dart 中并没有提供这些功能，但是这个功能对我们来说确实又非常需要，那有什么办法实现它呢？ 🤔 我们回想在开发过程中，是不是发现只要一不小心抛异常，就可以看到类似如下的打印内容，而且还能清楚的知道异常是在哪个文件和哪一行的代码造成的。 所以如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。 二、实践在 dart:core 中提供了 堆栈跟踪(StackTrace)，可以通过 StackTrace.current 取到当前的堆栈信息，打印如下图所示，会发现这不好拿到我们想要的信息。 这里我用到了官方开发的一个包 stack_trace，它可以将堆栈信息变得更多人性化，并方便我们查看堆栈信息和获取想要的数据。 ps: stack_trace 在 Flutter 环境下直接导包即可使用，而在纯 Dart 下需要将其添加为依赖于pubspec.yaml中。 12dependencies: stack_trace: ^1.9.3 那下面我们来试试 stack_trace 的威力吧12345678import 'package:stack_trace/stack_trace.dart';// 将 StackTrace 对象转换成 Chain 对象// 当然，这里也可以直接用 Chain.current();// final chain = Chain.current();final chain = Chain.forTrace(StackTrace.current);print(chain); 打印内容： 123456789101112flutter: package:flutter_test1/main.dart 79:17 _MyHomePageState.test_printpackage:flutter_test1/main.dart 38:5 _MyHomePageState._incrementCounterpackage:flutter/src/material/ink_well.dart 779:19 _InkResponseState._handleTappackage:flutter/src/material/ink_well.dart 862:36 _InkResponseState.build.&lt;fn&gt;package:flutter/src/gestures/recognizer.dart 182:24 GestureRecognizer.invokeCallbackpackage:flutter/src/gestures/tap.dart 504:11 TapGestureRecognizer.handleTapUppackage:flutter/src/gestures/tap.dart 282:5 BaseTapGestureRecognizer._checkUppackage:flutter/src/gestures/tap.dart 254:7 BaseTapGestureRecognizer.acceptGesturepackage:flutter/src/gestures/arena.dart 156:27 GestureArenaManager.sweeppackage:flutter/src/gestures/binding.dart 222:20 GestureBinding.handleEventpackage:flutter/src/gestures/binding.dart 198:22 GestureBinding.dispatchEventpackage:flutter/src/gestures/binding.dart 156:7 GestureBinding._handle&lt;…&gt; 工具代码雏形： 12345678910111213import 'package:stack_trace/stack_trace.dart';// 将 StackTrace 对象转换成 Chain 对象// 当然，这里也可以直接用 Chain.current();final chain = Chain.forTrace(StackTrace.current);// 拿出其中一条信息final frames = chain.toTrace().frames;final frame = frames[1];// 打印print(\"所在文件：$&#123;frame.uri&#125; 所在行 $&#123;frame.line&#125; 所在列 $&#123;frame.column&#125;\");// 打印结果// flutter: 所在文件：package:flutterlog/main.dart 所在行 55 所在列 23 Frame 类的属性 12345678910111213141516171819/// A single stack frame. Each frame points to a precise location in Dart code.class Frame &#123; /// The URI of the file in which the code is located. /// /// This URI will usually have the scheme `dart`, `file`, `http`, or `https`. final Uri uri; /// The line number on which the code location is located. /// /// This can be null, indicating that the line number is unknown or /// unimportant. final int line; /// The name of the member in which the code location occurs. /// /// Anonymous closures are represented as `&lt;fn&gt;` in this member string. final String member; ...&#125; uri : 获取代码所在文件的路径 line : 获取代码所在行 member : 获取所在方法 打印看一下 : 12345678// uriprint(\"$&#123;frame.uri.toString()&#125;\"); // package:flutter_test1/main.dart// memberprint(\"$&#123;frame.member&#125;\"); // _MyHomePageState.scheduleAsync.&lt;fn&gt;// lineprint(\"$&#123;frame.line&#125;\"); // 97 三、呈上代码下面我做了一点封装，直接拿走即可使用，完整的代码和示例请到GitHub上【查看】。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344// log.dartenum FLogMode &#123; debug, // 💚 DEBUG warning, // 💛 WARNING info, // 💙 INFO error, // ❤️ ERROR&#125;void FLog(dynamic msg, &#123; FLogMode mode = FLogMode.debug &#125;) &#123; if (kReleaseMode) &#123; // release模式不打印 return; &#125; var chain = Chain.current(); // Chain.forTrace(StackTrace.current); // 将 core 和 flutter 包的堆栈合起来（即相关数据只剩其中一条） chain = chain.foldFrames((frame) =&gt; frame.isCore || frame.package == \"flutter\"); // 取出所有信息帧 final frames = chain.toTrace().frames; // 找到当前函数的信息帧 final idx = frames.indexWhere((element) =&gt; element.member == \"FLog\"); if (idx == -1 || idx+1 &gt;= frames.length) &#123; return; &#125; // 调用当前函数的函数信息帧 final frame = frames[idx+1]; var modeStr = \"\"; switch(mode) &#123; case FLogMode.debug: modeStr = \"💚 DEBUG\"; break; case FLogMode.warning: modeStr = \"💛 WARNING\"; break; case FLogMode.info: modeStr = \"💙 INFO\"; break; case FLogMode.error: modeStr = \"❤️ ERROR\"; break; &#125; print(\"$modeStr $&#123;frame.uri.toString().split(\"/\").last&#125;($&#123;frame.line&#125;) - $msg \");&#125; 四、使用12345678// 直接使用FLogFLog(\"flutter_log demo\");// mode：打印模式（默认值为debug）FLog(\"flutter_log demo\", mode: FLogMode.debug);FLog(\"flutter_log demo\", mode: FLogMode.warning);FLog(\"flutter_log demo\", mode: FLogMode.info);FLog(\"flutter_log demo\", mode: FLogMode.error); 打印效果如下所示：","categories":[{"name":"Share","slug":"Share","permalink":"http://linxunfeng.top/categories/Share/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://linxunfeng.top/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/tags/Flutter/"}]},{"title":"解决 Could not find 'faraday' ...  gem(s) (Gem::LoadError)","slug":"iOS/解决 Could not find faraday ...  gem(s) (Gem LoadError)","date":"2020-08-29T17:27:00.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2020/08/29/iOS/解决 Could not find faraday ...  gem(s) (Gem LoadError)/","link":"","permalink":"http://linxunfeng.top/2020/08/29/iOS/%E8%A7%A3%E5%86%B3%20Could%20not%20find%20faraday%20...%20%20gem(s)%20(Gem%20LoadError)/","excerpt":"`to_specs’: Could not find ‘faraday’ (&gt;= 0.7.4) among 77 total gem(s) (Gem::LoadError) +","text":"`to_specs’: Could not find ‘faraday’ (&gt;= 0.7.4) among 77 total gem(s) (Gem::LoadError) + 一、遇到的问题报错内容如下：1234567891011121314151617/Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/dependency.rb:319:in `to_specs': Could not find 'faraday' (&gt;= 0.7.4) among 77 total gem(s) (Gem::LoadError)Checked in 'GEM_PATH=/Users/lxf/.fastlane/bin/bundle/bin:/Users/lxf/.fastlane/bin/bundle/lib/ruby/gems/2.2.0', execute `gem env` for more information from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1439:in `block in activate_dependencies' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `each' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `activate_dependencies' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1410:in `activate' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1442:in `block in activate_dependencies' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `each' from /Users/xxx/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `activate_dependencies' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1410:in `activate' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems.rb:196:in `rescue in try_activate' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems.rb:193:in `try_activate' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:125:in `rescue in require' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:40:in `require' from /Users/lxf/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/gems/fastlane-2.28.3/bin/fastlane:9:in `&lt;top (required)&gt;' from /Users/lxf/.fastlane/bin/bundle/bin/fastlane:22:in `load' from /Users/lxf/.fastlane/bin/bundle/bin/fastlane:22:in `&lt;main&gt;' 在执行 fastlane 命令时遇到了上面那个错误 二、解决方案：执行如下几行命令即可，解决方案出自: 链接123rm -rf $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/gems/faraday-0.*rm -rf $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/specifications/faraday-0.*gem install faraday -v 0.17.0 --install-dir $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0 接着再执行 fastlane 命令试试看吧~","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"}]},{"title":"Flutter - 解决混合开发iOS脚本打包遇到的问题","slug":"Flutter/Flutter - 解决混合开发iOS脚本打包遇到的问题","date":"2020-08-12T00:00:00.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2020/08/12/Flutter/Flutter - 解决混合开发iOS脚本打包遇到的问题/","link":"","permalink":"http://linxunfeng.top/2020/08/12/Flutter/Flutter%20-%20%E8%A7%A3%E5%86%B3%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"使用Xcode手动打包是正常的，但是使用脚本打包会报错 +","text":"使用Xcode手动打包是正常的，但是使用脚本打包会报错 + 使用 Xcode 手动打包是正常的，但是使用脚本打包会报错，错误如下： 123456The following build commands failed: PhaseScriptExecution [CP-User]\\ Run\\ Flutter\\ Build\\ Script .../Script-C3A097A8FE12FF5F875B057C.sh flutter build ios --releasethen re-run Archive from Xcode.Command PhaseScriptExecution failed with a nonzero exit code 定位错误 到 Flutter 环境目录下，按图上所示地址找到 xcode_backend.sh，也可以直接看 官方脚本链接 123456789101112# Archive builds (ACTION=install) should always run in release mode.if [[ \"$ACTION\" == \"install\" &amp;&amp; \"$build_mode\" != \"release\" ]]; then EchoError \"========================================================================\" EchoError \"ERROR: Flutter archive builds must be run in Release mode.\" EchoError \"\" EchoError \"To correct, ensure FLUTTER_BUILD_MODE is set to release or run:\" EchoError \"flutter build ios --release\" EchoError \"\" EchoError \"then re-run Archive from Xcode.\" EchoError \"========================================================================\" exit -1fi 解决方案可以看到，官方脚本的说明里面给出两个解决方案 方案一：直接设置 FLUTTER_BUILD_MODE 为 release 方案二：先运行 flutter build ios --release ，再使用 Xcode 去打包 这里我们是用 Jenkins 脚本进行打包，所以方案二不适用，方案一更加方便些 12345# 设置Flutter的编译模式为releaseexport FLUTTER_BUILD_MODE=release# 执行原有项目的打包脚本./script/build_iOS.sh","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/categories/Flutter/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://linxunfeng.top/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/tags/Flutter/"}]},{"title":"Flutter - 混合开发","slug":"Flutter/Flutter - 混合开发","date":"2020-07-12T00:00:00.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2020/07/12/Flutter/Flutter - 混合开发/","link":"","permalink":"http://linxunfeng.top/2020/07/12/Flutter/Flutter%20-%20%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/","excerpt":"目前大多数公司都有自己开发多年的项目，不可能直接用 Flutter 从头开发一套，那样不实现，除非是小项目，因此只能是在原有的基础上用 Flutter 来开发新业务或重构旧业务，而这里就需要用到 Flutter 的 混合开发 +","text":"目前大多数公司都有自己开发多年的项目，不可能直接用 Flutter 从头开发一套，那样不实现，除非是小项目，因此只能是在原有的基础上用 Flutter 来开发新业务或重构旧业务，而这里就需要用到 Flutter 的 混合开发 + 目前大多数公司都有自己开发多年的项目，不可能直接用 Flutter 从头开发一套，那样不实现，除非是小项目，因此只能是在原有的基础上用 Flutter 来开发新业务或重构旧业务，而这里就需要用到 Flutter 的 混合开发 一、创建Flutter模块使用混合开发就不能像之前一样直接上来就创建一个 Flutter 项目，而是要使用 Flutter模板 12345# flutter_module_lxf 可以随便你命名flutter create --template module flutter_module_lxf# --template 可以替换为 -t# flutter create -t module flutter_module_lxf 创建出来的 Flutter 模块依然是可以像之前创建的Flutter项目 一样打开和运行的。 目录下有也有 ios 和 android 目录，只不过前面加了个点 ，成了点目录。 二、iOS集成 通过 Cocoapods ，将 Flutter 模块编译成一个库，再到原生项目中进行引入和使用即可 在 Podfile 中添加两行配置 12345# 指定我们刚刚创建的 Flutter 模块的路径flutter_application_path = '../flutter_module_lxf'# 拼接脚本文件的路径: .ios/Flutter/podhelper.rbload File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb') 在每个需要引用 Flutter 的 Target 下，都需要添加一行配置 1install_all_flutter_pods(flutter_application_path) 添加后如下所示： 123456789flutter_application_path = '../flutter_module_lxf'load File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')use_frameworks!target 'LXFFlutterHybridDemo' do install_all_flutter_pods(flutter_application_path) end 添加完成后，执行一次 pod install 混合开发混合开发 使用 两个步骤 获取 Flutter引擎 FlutterEngine 通过 FlutterEngine 创建 FlutterViewController 基本使用AppDelegate 类中声明一个 FlutterEngine 变量，在 didFinishLaunchingWithOptions 方法中启动 Flutter引擎 1234567891011121314151617181920// AppDelegate.swiftimport Flutter@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate &#123; // 创建 Flutter引擎 lazy var flutterEngine = FlutterEngine(name: \"lxf\") func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // 启动 Flutter引擎 flutterEngine.run() return true &#125; ...&#125; ViewController 中添加一个按钮，点击弹出 Flutter模块 1234567891011121314151617181920212223// ViewController.swiftoverride func viewDidLoad() &#123; super.viewDidLoad() let btn = UIButton(type: .custom) btn.frame = CGRect(x: 100, y: 200, width: 200, height: 44) btn.backgroundColor = .black btn.addTarget(self, action: #selector(showFlutterVc), for: .touchUpInside) btn.setTitle(\"弹出Flutter模块\", for: .normal) self.view.addSubview(btn)&#125;@objc func showFlutterVc() &#123; // 创建FlutterViewController // 这里的 engine 可以传 nil，Flutter会帮我们自动创建一个引擎，但是性能较差 let flutterVc = FlutterViewController(engine: fetchFlutterEngine(), nibName: nil, bundle: nil) self.present(flutterVc, animated: true, completion: nil)&#125;func fetchFlutterEngine() -&gt; FlutterEngine &#123; return (UIApplication.shared.delegate as! AppDelegate).flutterEngine&#125; 如果遇到报 Command PhaseScriptExecution failed with a nonzero exit code 错误，如下图所示： 请先用 Android Studio 或 VSCode 打开 Flutter模块 项目并运行到iOS设备上，让其帮我们对iOS项目进行一些初始化配置。成功运行后就可以关闭 Flutter模块 项目的运行了，接着再用 Xcode 打开原生项目运行即可。 修改初始路由官方文档里面提到，修改初始路由，需要在 Flutter引擎 在 run 之前，通过 invokeMethod 调用 setInitialRoute 方法进行设置，代码如下 1234// 修改初始路由flutterEngine.navigationChannel.invokeMethod(\"setInitialRoute\", arguments: \"/other\")// 启动 Flutter引擎flutterEngine.run() 但是，我发现这样写并没有起任何作用，在 Flutter 的官方 issue 上也有人提到这个问题： 【setInitialRoute is broken for iOS add-to-app #59895】，目前只能官方进行修复和调整 API 临时可以使用如下方式实现： 123let flutterVc = FlutterViewController(project: FlutterDartProject(), nibName: nil, bundle: nil)flutterVc.setInitialRoute(\"/other\")self.present(flutterVc, animated: true, completion: nil) 虽然这么写可以实现这个功能，但是会有明显的类似卡顿的现象，因为使用这种方式去创建 FlutterViewController 之前，会隐式创建和启动一个 FlutterEngine，而我们弹出 FlutterViewController 时 FlutterEngine 还没加载完毕，所以我们会看到先弹出了一个透明的界面，再显示 /other 路由对应的界面视图。 使用 FlutterAppDelegate使用 FlutterAppDelegate这个不是必要的操作，但是如果你想让 Flutter模块 也能使用原生的功能的话，建议使用 原生功能 处理 openURL 的回调 列表视图在点击状态栏后滚到顶部 1class AppDelegate: FlutterAppDelegate 更具体的使用，请阅读 官方文档 三、Android修改安卓项目 根目录下的 settings.gradle 文件 123456789// settings.gradleinclude ':app' // assumed existing contentsetBinding(new Binding([gradle: this])) // newevaluate(new File( // new settingsDir.parentFile, // new // 这里的 flutter_module_lxf 请修改为你自己创建的Flutter模板目录名称 'flutter_module_lxf/.android/include_flutter.groovy' // new)) 修改安卓项目 app 目录下的 build.gradle 文件 1234567// app/build.gradledependencies &#123; ... // 配置flutter依赖 implementation project(':flutter')&#125; 如果在编译的时候遇到如下错误 1Default interface methods are only supported starting with Android N (--min-api 24): void androidx.lifecycle.DefaultLifecycleObserver.onCreate(androidx.lifecycle.LifecycleOwner) 请确认是否指定了使用 Java 8 进行编译 【官方文档 - Java 8 requirement】 修改安卓项目 app 目录下的 build.gradle 文件 12345678910&#x2F;&#x2F; app&#x2F;build.gradleandroid &#123; ... compileOptions &#123; sourceCompatibility 1.8 targetCompatibility 1.8 &#125; ...&#125; 修改 app/src/main/AndroidManifest.xml 文件 123456789// app/src/main/AndroidManifest.xml&lt;activity android:name=\"io.flutter.embedding.android.FlutterActivity\" android:theme=\"@style/AppTheme\" android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode\" android:hardwareAccelerated=\"true\" android:windowSoftInputMode=\"adjustResize\" /&gt; 添加一个按钮，点击弹出 Flutter模块 12345678910111213&lt;!-- activity_main.xml --&gt;&lt;Button android:id=\"@+id/btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"20sp\" android:text=\"弹出Flutter模块\" android:background=\"#000000\" android:textColor=\"#ffffff\" android:gravity=\"center\" android:onClick=\"btnClick\" /&gt; 1234567// MainActivity.javapublic void btnClick(View v) &#123; startActivity( FlutterActivity.createDefaultIntent(this) );&#125; 四、调试与热重载 由于当前我们是使用原生开发工具(如：Xcode)来运行项目，每次修改我们的 Flutter模块 的代码，也就需要重新运行才能看到效果，不像之前按下 Cmd + s 就能进行热重载。这样 Flutter模块 的开发效率极其低下，那有没有办法可以让我们像之前开发 Flutter 项目时那样进行 热重载 呢？答案是有的 Flutter 官方提供了 flutter attach ，以辅助我们开发，到终端下执行 1flutter attach 如果当前有多个设备，会提示我们需要指定 attach 哪个设备 按要求加上指定参数即可 1flutter attach -d FE305309-9E79-418D-BA3F-7EFECF2980BC 如图，这样就关联上了，你在 dart 文件里面对界面进行任何修改后，按 r 进行热重载，按 R 进行热启动。 如果你使用的是 Android Studio，可以直接选择对应的设备后，点击右边的 Flutter Attach 按钮，执行成功后就可以跟之前一样按 Cmd + s 进行热重载了。 五、资料 GitHub LXFFlutterHybridDemo 官方文档 add-to-app | add-to-app/ios | add-to-app/android | Debugging &amp; hot reload","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/categories/Flutter/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://linxunfeng.top/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/tags/Flutter/"}]},{"title":"Flutter - 打印好用的Debug日志","slug":"Flutter/Flutter - 打印好用的Debug日志","date":"2020-06-26T00:35:00.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2020/06/26/Flutter/Flutter - 打印好用的Debug日志/","link":"","permalink":"http://linxunfeng.top/2020/06/26/Flutter/Flutter%20-%20%E6%89%93%E5%8D%B0%E5%A5%BD%E7%94%A8%E7%9A%84Debug%E6%97%A5%E5%BF%97/","excerpt":"做 iOS 开发时这个功能很常用， 在 OC 和 Swift 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，但是在 Dart 中并不提供这些，那有什么办法实现它呢？ +","text":"做 iOS 开发时这个功能很常用， 在 OC 和 Swift 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，但是在 Dart 中并不提供这些，那有什么办法实现它呢？ + 一、思考做 iOS 开发时这个功能很常用， 在 OC 和 Swift 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，但是在 Dart 中并不提供这些，那有什么办法实现它呢？ 我们回想在开发过程中，是不是发现只要一不小心抛异常，就可以看到类似如下的打印内容，而且还能清楚的知道异常是在哪个文件和哪一行的代码造成的。 所以如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。 二、实践在 dart:core 中提供了 堆栈跟踪(StackTrace)，可以通过 StackTrace.current 取到当前的堆栈信息，打印如下图所示，会发现这不好拿到我们想要的信息。 这里我用到了官方开发的一个包 stack_trace，它可以将堆栈信息变得更多人性化，并方便我们查看堆栈信息和获取想要的数据。 ps: stack_trace 在 Flutter 环境下直接导包即可使用，而在纯 Dart 下需要将其添加为依赖于pubspec.yaml中。 12dependencies: stack_trace: ^1.9.3 那下面我们来试试 stack_trace 的威力吧12345678910111213import 'package:stack_trace/stack_trace.dart';// 将 StackTrace 对象转换成 Chain 对象// 当然，这里也可以直接用 Chain.current();final chain = Chain.forTrace(StackTrace.current);// 拿出其中一条信息final frames = chain.toTrace().frames;final frame = frames[1];// 打印print(\"所在文件：$&#123;frame.uri&#125; 所在行 $&#123;frame.line&#125; 所在列 $&#123;frame.column&#125;\");// 打印结果// flutter: 所在文件：package:flutterlog/main.dart 所在行 55 所在列 23 三、呈上代码下面我做了一点封装，直接拿走即可使用，打印效果如下所示： 完整的代码和示例请到GitHub上【查看】。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344// log.dartenum FLogMode &#123; debug, // 💚 DEBUG warning, // 💛 WARNING info, // 💙 INFO error, // ❤️ ERROR&#125;void FLog(dynamic msg, &#123; FLogMode mode = FLogMode.debug &#125;) &#123; if (kReleaseMode) &#123; // release模式不打印 return; &#125; var chain = Chain.current(); // Chain.forTrace(StackTrace.current); // 将 core 和 flutter 包的堆栈合起来（即相关数据只剩其中一条） chain = chain.foldFrames((frame) =&gt; frame.isCore || frame.package == \"flutter\"); // 取出所有信息帧 final frames = chain.toTrace().frames; // 找到当前函数的信息帧 final idx = frames.indexWhere((element) =&gt; element.member == \"FLog\"); if (idx == -1 || idx+1 &gt;= frames.length) &#123; return; &#125; // 调用当前函数的函数信息帧 final frame = frames[idx+1]; var modeStr = \"\"; switch(mode) &#123; case FLogMode.debug: modeStr = \"💚 DEBUG\"; break; case FLogMode.warning: modeStr = \"💛 WARNING\"; break; case FLogMode.info: modeStr = \"💙 INFO\"; break; case FLogMode.error: modeStr = \"❤️ ERROR\"; break; &#125; print(\"$modeStr $&#123;frame.uri.toString().split(\"/\").last&#125;($&#123;frame.line&#125;) - $msg \");&#125;","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/categories/Flutter/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://linxunfeng.top/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/tags/Flutter/"}]},{"title":"Dart - 抽象类的实例化","slug":"Flutter/Dart-抽象类的实例化","date":"2020-06-07T11:27:00.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2020/06/07/Flutter/Dart-抽象类的实例化/","link":"","permalink":"http://linxunfeng.top/2020/06/07/Flutter/Dart-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/","excerpt":"抽象类不能用于创建实例，但是有没有发现，Dart 提供的 Map 和 List 就是抽象类，却可以直接使用它们创建出一个实例对象 +","text":"抽象类不能用于创建实例，但是有没有发现，Dart 提供的 Map 和 List 就是抽象类，却可以直接使用它们创建出一个实例对象 + 一、抽象类的使用Dart 抽象类可以只声明方法，也可以有具体的方法实现，但是不能直接用抽象类来创建实例，只能被继承使用或者充当接口。 定义一个抽象类 Animal123456789abstract class Animal &#123; // 仅声明eat方法 void eat(); // 声明方法，且有具体实现 void sleep() &#123; print(\"睡觉\"); &#125;&#125; 继承使用 123456789class Cat extends Animal &#123; @override void eat() &#123; print(\"喵喵吃\"); sleep(); &#125;// 可以不实现 sleep 方法&#125; 充当接口1234567891011class Cat implements Animal &#123; void eat() &#123; print(\"吃\"); &#125; // 必须实现 sleep 方法 void sleep() &#123; print('睡'); &#125;&#125;实例化123final animal = Animal();// 抽象类实例化会报错// Error: The class 'Test' is abstract and can't be instantiated. 抽象类不能实例化。 继承: 子类比较实现抽象方法，子类可以不重写抽象类中已实现的方法。 接口: 必须实现抽象类中声明的所有方法 二、抽象类的实例化上面提到了抽象类不能用于创建实例，但是有没有发现，Dart 提供的 Map 和 List 就是抽象类，却可以直接使用它们创建出一个实例对象12final list = List();final dict = Map&lt;String, dynamic&gt;();我们来看一下 Map 的源码： Map 的确是抽象类，不过此时我们也注意到了，在 Map 这个抽象类中，定义了一个工厂构造方法，这就是使抽象类可实例化的关键所在，因为工厂方法可以返回一个实例对象，但这个对象的类型不一定就是当前类! 在这个地方，Map 的工厂方法并没有具体的实现，而只是在工厂构造方法前加了一个关键字 external。external 关键字可以让方法的声明与实现分离，即 可以由外部来帮我们完成具体的方法实现，那外部如何才能关联到该声明的方法呢？这里就需要用到注解 @patch，使外部的方法实现与该声明的方法绑定 external 可以分离方法的声明与实现@patch 关联某个类中用 external 修饰的方法的实现 根据如下路径可以找到 Map 的具体实现源码1234// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/map_patch.dart@patchfactory Map() =&gt; new LinkedHashMap&lt;K, V&gt;(); 可以看到，这里使用了 LinkedHashMap 来实现 Map 。 我们再去看一下 LinkedHashMap 的实现源码，路径如下：123456// flutter/bin/cache/dart-sdk/lib/collection/linked_hash_map.dartexternal factory LinkedHashMap( &#123;bool Function(K, K)? equals, int Function(K)? hashCode, bool Function(dynamic)? isValidKey&#125;);这里我们又发现 LinkedHashMap 也仅仅只是声明，找到具体实现 12345678910111213141516171819202122232425262728293031// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/collection_patch.dart@patchclass LinkedHashMap&lt;K, V&gt; &#123; @patch factory LinkedHashMap( &#123;bool equals(K key1, K key2)?, int hashCode(K key)?, bool isValidKey(potentialKey)?&#125;) &#123; if (isValidKey == null) &#123; if (hashCode == null) &#123; if (equals == null) &#123; return new _InternalLinkedHashMap&lt;K, V&gt;(); &#125; hashCode = _defaultHashCode; &#125; else &#123; if (identical(identityHashCode, hashCode) &amp;&amp; identical(identical, equals)) &#123; return new _CompactLinkedIdentityHashMap&lt;K, V&gt;(); &#125; equals ??= _defaultEquals; &#125; &#125; else &#123; hashCode ??= _defaultHashCode; equals ??= _defaultEquals; &#125; return new _CompactLinkedCustomHashMap&lt;K, V&gt;(equals, hashCode, isValidKey); &#125;...&#125; 可以看到，LinkedHashMap的工厂构造方法返回的实例类型是 _InternalLinkedHashMap 或 _CompactLinkedCustomHashMap ，这里我们再看一下这两个类的实现源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/compact_hash.dart@pragma(\"vm:entry-point\")class _InternalLinkedHashMap&lt;K, V&gt; extends _HashVMBase with MapMixin&lt;K, V&gt;, _LinkedHashMapMixin&lt;K, V&gt;, _HashBase, _OperatorEqualsAndHashCode implements LinkedHashMap&lt;K, V&gt; &#123; _InternalLinkedHashMap() &#123; _index = new Uint32List(_HashBase._INITIAL_INDEX_SIZE); _hashMask = _HashBase._indexSizeToHashMask(_HashBase._INITIAL_INDEX_SIZE); _data = new List.filled(_HashBase._INITIAL_INDEX_SIZE, null); _usedData = 0; _deletedKeys = 0; &#125;&#125;......class _CompactLinkedIdentityHashMap&lt;K, V&gt; extends _HashFieldBase with MapMixin&lt;K, V&gt;, _LinkedHashMapMixin&lt;K, V&gt;, _HashBase, _IdenticalAndIdentityHashCode implements LinkedHashMap&lt;K, V&gt; &#123; _CompactLinkedIdentityHashMap() : super(_HashBase._INITIAL_INDEX_SIZE);&#125;class _CompactLinkedCustomHashMap&lt;K, V&gt; extends _HashFieldBase with MapMixin&lt;K, V&gt;, _LinkedHashMapMixin&lt;K, V&gt;, _HashBase implements LinkedHashMap&lt;K, V&gt; &#123; final _equality; final _hasher; final _validKey; // TODO(koda): Ask gbracha why I cannot have fields _equals/_hashCode. int _hashCode(e) =&gt; _hasher(e); bool _equals(e1, e2) =&gt; _equality(e1, e2); bool containsKey(Object? o) =&gt; _validKey(o) ? super.containsKey(o) : false; V? operator [](Object? o) =&gt; _validKey(o) ? super[o] : null; V? remove(Object? o) =&gt; _validKey(o) ? super.remove(o) : null; _CompactLinkedCustomHashMap(this._equality, this._hasher, validKey) : _validKey = (validKey != null) ? validKey : new _TypeTest&lt;K&gt;().test, super(_HashBase._INITIAL_INDEX_SIZE);&#125; 它们都是一个普通的类，没有工厂构造方法，也就是说 Map 中的 external factory Map(); 最终返回的最终实例类型为 _InternalLinkedHashMap 或 _CompactLinkedCustomHashMap 我们可以做一个简单的验证12345final map = Map();print(map.runtimeType);// 打印结果// _InternalLinkedHashMap&lt;dynamic, dynamic&gt; 我们来试着来实例化一个抽象类吧123456789101112131415161718192021abstract class Animal &#123; void eat(); void sleep() &#123; print(\"睡觉\"); &#125; factory Animal() &#123; return Cat(); &#125;&#125; class Cat implements Animal &#123; void eat() &#123; print(\"吃\"); &#125; void sleep() &#123; print('睡'); &#125;&#125; 1234final animal = Animal();print(animal.runtimeType); // 打印结果: Cat 可能会有同学要问了，这里用的是接口的方式，可以用继承的方式吗？很遗憾不行，因为在抽象类中定义了工厂构造方法后，在子类中不能定义除工厂构造方法外的其它构造方法了，会报错~ 总结一下： 抽象类无法直接创建实例，但是可以通过实现工厂构造方法来间接实现抽象类的实例化！ 三、补充那饶了这么一大圈，为什么不直接在声明的时候就给它实现了呢？🤔这样做的好处就是： 复用同一套API的声明 可以针对不同的平台做不同的实现 而 针对不同的平台做不同的实现 这一点在下方给出的源码中可以看出 123456// flutter/bin/cache/dart-sdk/lib/io/file_system_entity.dartabstract class _FileSystemWatcher &#123; external static Stream&lt;FileSystemEvent&gt; _watch( String path, int events, bool recursive); external static bool get isSupported;&#125; 123456789101112131415161718// flutter/bin/cache/dart-sdk/lib/_internal/vm/bin/file_patch.dart@patchstatic Stream&lt;FileSystemEvent&gt; _watch( String path, int events, bool recursive) &#123; if (Platform.isLinux) &#123; return new _InotifyFileSystemWatcher(path, events, recursive)._stream; &#125; if (Platform.isWindows) &#123; return new _Win32FileSystemWatcher(path, events, recursive)._stream; &#125; if (Platform.isMacOS) &#123; return new _FSEventStreamFileSystemWatcher(path, events, recursive) ._stream; &#125; throw new FileSystemException( \"File system watching is not supported on this platform\");&#125;","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://linxunfeng.top/categories/Flutter/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"http://linxunfeng.top/tags/Dart/"}]},{"title":"解决SecurityEnvSDK与SGMain的冲突问题","slug":"解决SecurityEnvSDK与SGMain的冲突问题","date":"2020-03-14T13:21:00.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2020/03/14/解决SecurityEnvSDK与SGMain的冲突问题/","link":"","permalink":"http://linxunfeng.top/2020/03/14/%E8%A7%A3%E5%86%B3SecurityEnvSDK%E4%B8%8ESGMain%E7%9A%84%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/","excerpt":"报错是说有重复类，解决的办法比较简单粗暴，就是把在Xcode里全文搜索-framework &quot;SecurityEnvSDK&quot;，接着全文替换为空字符串就可以了。 +","text":"报错是说有重复类，解决的办法比较简单粗暴，就是把在Xcode里全文搜索-framework &quot;SecurityEnvSDK&quot;，接着全文替换为空字符串就可以了。 + 问题在集成友盟统计和阿里百川之后项目报如下错误 123456789101112duplicate symbol '_OBJC_CLASS_$_tdvSFHFKeychainUtils' in: /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o) /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)duplicate symbol '_OBJC_METACLASS_$_tdvSFHFKeychainUtils' in: /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o) /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)duplicate symbol '_OBJC_CLASS_$_SGDataCollectionLock' in: /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o) /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)duplicate symbol '_OBJC_METACLASS_$_SGDataCollectionLock' in: /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o) /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o) 报错是说有重复类，解决的办法比较简单粗暴，就是把在Xcode里全文搜索 -framework &quot;SecurityEnvSDK&quot;，接着全文替换为空字符串就可以了。 虽然解决这个问题的方式很简单，但是每次 pod install 后都要做一遍该操作，这就很无语了 。 那有什么办法可以让我们不用自己去做这个烦琐的事情呢？ 改进 首先要搞清楚，上面的操作原理是怎么回事？其它很简单，就是将下面这两个文件中 OTHER_LDFLAGS 所在行的内容里，把 -framework &quot;SecurityEnvSDK&quot; 置为空字符串。 12Pods/Target Support Files/Pods-项目名/Pods-项目名.debug.xcconfigPods/Target Support Files/Pods-项目名/Pods-项目名.release.xcconfig 有什么办法可以让我们在适当的时候去执行这个置空字符串的操作？Cocoapods 提供了一个很好用的 Hook 就是 post_install，这个钩子的作用就是方便我们在执行 pod install 之后去做一些其它配置，这里我们就用它来搞事情。 Podfile 文件中使用的是 ruby 语言，ruby 执行终端命令的代码如下所示：12345post_install do |installer| # command = \"echo 'hello world'\" command = \"终端命令\" system(command)endOK，现在开始搞事！ 步骤 在项目的目录，即与Pods平级目录中，新建一个文件，名为 fix.py 12345678.├── ...├── Podfile├── Podfile.lock├── Pods│ ├── ...│ └── ...└── fix.py 在 fix.py 中粘贴如下内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: UTF-8 -*-import sys, os, getopt, codecsdef get_current_file_name(): \"\"\"获取当前文件名称\"\"\" return os.path.split(__file__)[-1]def replace_all_str(file_path, for_str, to_str): \"\"\" 全文搜索替换或单行替换 :param file_path: 文件路径 :param for_str: 要被替换的内容 :param to_str: 替换之后的内容 \"\"\" if not os.path.exists(file_path): # 文件不存在 print('文件不存在') return bak_file_path = file_path+\".bak\" with codecs.open(file_path, 'r', encoding='utf-8') as f, codecs.open(bak_file_path, 'w', encoding='utf-8') as f_w: lines = f.readlines() for line in lines: if \"OTHER_LDFLAGS\" in line and for_str in line: line = line.replace(for_str, to_str) f_w.write(line) os.remove(file_path) os.rename(bak_file_path, file_path)def throwParamError(): print(\"请正确输入命令： %s -p 项目名称\" % get_current_file_name()) sys.exit(0)def main(argv): project_name = \"\" try: opts, args = getopt.getopt(argv, \"p:\", [\"project=\"]) except getopt.GetoptError: throwParamError() for opt, arg in opts: # print(\"opt -- \", opt) # print(\"arg -- \", arg) if opt in ('-p', '--project'): project_name = arg if not len(project_name): throwParamError() path_str = \"Pods/Target Support Files/Pods-%s/Pods-%s.%s.xcconfig\" xcconfig_debug_path = path_str % (project_name, project_name, \"debug\") xcconfig_release_path = path_str % (project_name, project_name, \"release\") # print(xcconfig_debug_path) # print(xcconfig_release_path) be_fixed_str = '-framework \"SecurityEnvSDK\"' replace_all_str(xcconfig_debug_path, be_fixed_str, '') replace_all_str(xcconfig_release_path, be_fixed_str, '') print(\"%s is fixed successfully\" %project_name)if __name__ == \"__main__\": main(sys.argv[1:]) 打开 Podfile，在内容最后添加如下内容12345post_install do |installer| # 解决SecurityEnvSDK与SGMain的冲突问题 command = \"python fix.py -p 项目名称\" system(command)end 执行pod install 好了，现在开始就又可以继续愉快的搬砖了~ GitHub相关代码文件可以到这里下载，如果觉得不错，不妨给个 Star 鼓励一下https://github.com/LinXunFeng/fix_confict_SecurityEnvSDK_SGMain","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://linxunfeng.top/tags/Cocoapods/"},{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"}]},{"title":"解决Transporter一直卡正在验证的问题","slug":"解决Transporter一直卡正在验证的问题","date":"2020-03-12T22:16:00.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2020/03/12/解决Transporter一直卡正在验证的问题/","link":"","permalink":"http://linxunfeng.top/2020/03/12/%E8%A7%A3%E5%86%B3Transporter%E4%B8%80%E7%9B%B4%E5%8D%A1%E6%AD%A3%E5%9C%A8%E9%AA%8C%E8%AF%81%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"苹果的上传应用工具 Transporter 虽然挺好用，但是估计也不少人跟我一样遇到过这样的问题，就是一直卡在 正在验证，不采取点措施估计能一直卡下去~ +","text":"苹果的上传应用工具 Transporter 虽然挺好用，但是估计也不少人跟我一样遇到过这样的问题，就是一直卡在 正在验证，不采取点措施估计能一直卡下去~ + 苹果的上传应用工具 Transporter 虽然挺好用，但是估计也不少人跟我一样遇到过这样的问题，就是一直卡在 正在验证，不采取点措施估计能一直卡下去~ 其实原因很简单，就是 /User/当前登录用户/Library/Caches/com.apple.amp.itmstransporter 这个目录里的文件不全，一直处于下载更新的状态。 解决方案方案一科学上网前提下，在终端下执行 Transporter 包内的 iTMSTransporter，1/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter因为国外服务器（contentdelivery.itunes.apple.com:443）对我们来说会很慢，所以这个过程最好弄下科学环境。 直到出现这个命令说明界面就可以了 方案二适用人群 没有科学环境 速度要求高的 比较懒的 可以使用 transporter_fixGitHub地址：https://github.com/LinXunFeng/transporter_fix执行文件下载地址：点我下载，下载后双击运行即可。 比较懒的朋友看到这就可以了，要求速度快的就继续往下看 重点 transporter_fix 默认是从 github 上下载 com.apple.amp.itmstransporter.zip 到同目录级别的 files 目录下。 如果 files 目录下已存在 com.apple.amp.itmstransporter.zip ，则不会重新下载。 所以，如果当前正常网络对 github 不给力，可以到这里，找个离当前日期最近的压缩包，下载下来后改名为 com.apple.amp.itmstransporter.zip，存放 files 目录下即可","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"}]},{"title":"FQ-Terminal下的代理工具ProxyChains-NG","slug":"Others/FQ-Terminal下的代理工具ProxyChains-NG","date":"2019-01-01T17:11:51.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2019/01/01/Others/FQ-Terminal下的代理工具ProxyChains-NG/","link":"","permalink":"http://linxunfeng.top/2019/01/01/Others/FQ-Terminal%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7ProxyChains-NG/","excerpt":"是不是你也遇到过，在 Shadowsocks 使用 全局 模式下，终端依旧无法 ping 通谷歌？这是因为 Shadowsocks 仅针对代理应用软件，但是一些终端下执行的命令是无法代理的。所以本篇就来介绍一下如何使你的终端也走代理进行访问。","text":"是不是你也遇到过，在 Shadowsocks 使用 全局 模式下，终端依旧无法 ping 通谷歌？这是因为 Shadowsocks 仅针对代理应用软件，但是一些终端下执行的命令是无法代理的。所以本篇就来介绍一下如何使你的终端也走代理进行访问。 是不是你也遇到过，在 Shadowsocks 使用 全局 模式下，终端依旧无法 ping 通谷歌？这是因为 Shadowsocks 仅针对代理应用软件，但是一些终端下执行的命令是无法代理的。所以本篇就来介绍一下如何使你的终端也走代理进行访问。 方案一：终端下的all_proxy 这里以 zshrc + Shadowsocks 为例 打开 Shadowsocks，模式选为 PAC自动模式 或 全局模式 如果不是使用 .zshrc 就 编辑 ~/.bashrc，下面的同理 1、打开 .zshrc1vim ~/.zshrc 2、添加命令12alias proxy='export all_proxy=socks5://127.0.0.1:1086'alias unproxy='unset all_proxy' 3、使用先应用一下配置 1source ~/.zshrc 终端下敲入 1proxy 这样就应用上代理了，使用 curl 获取一下 cip.cc 来查看当前所使用的 ip 1curl cip.cc 如果不想使用代理了，就使用如下命令 1unproxy 4、总结这种方式我个人是亲测无效的，不知道是不是我人品问题，还是我的 MAC 有问题，有兴趣的小伙伴可以试试。 方案二：ProxyChains-NGproxychains-ng是proxychains的加强版，主要有以下功能和不足： 支持http/https/socks4/socks5 支持认证 远端dns查询 多种代理模式 不支持udp/icmp转发 少部分程序和在后台运行的可能无法代理 详情可见 GitHub地址 环境这里以 MAC + homebrew 为例，如果你还没有安装的话可以参考下方命令，详细可见官网 Homebrew 12# 将命令粘贴至终端并回车进行安装/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 关闭SIPmacOS 10.11 后下由于开启了 SIP（System Integrity Protection） 会导致命令行下 proxychains-ng 代理的模式失效，如果你要使用 proxychains-ng 这种简单的方法，就需要先关闭 SIP。 具体的关闭方法如下： 部分关闭 SIP 重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。实用工具（Utilities）-&gt; 终端（Terminal）。输入命令csrutil enable --without debug运行。重启进入系统后，终端里输入 csrutil status，结果中如果有 Debugging Restrictions: disabled 则说明关闭成功。 完全关闭 SIP 重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。实用工具（Utilities）-&gt; 终端（Terminal）。输入命令csrutil disable运行。重启进入系统后，终端里输入 csrutil status，结果中如果有 System Integrity Protection status:disabled. 则说明关闭成功。 安装1brew install proxychains-ng 配置使用 Homebrew 安装完成后的配置文件路径为 /usr/local/etc/proxychains.conf 打开它，找到 [ProxyList] 12[ProxyList]socks5 127.0.0.1 1086 proxychains-ng支持多种代理模式,默认是选择 strict_chain。 dynamic_chain ：动态模式,按照代理列表顺序自动选取可用代理 strict_chain ：严格模式,严格按照代理列表顺序使用代理，所有代理必须可用 round_robin_chain ：轮询模式，自动跳过不可用代理 random_chain ：随机模式,随机使用代理 给proxychains4增加一个别名，在 ~/.zshrc或~/.bashrc末尾加入如下行： 1alias pc='proxychains4' 这样就可以使用 pc 来 指代 proxychains4，简化输入。 1pc curl cip.cc 如果你使用 iTerm 的话可以配置快捷键来实现前缀补全功能 1在 iTerm -&gt; Preferences -&gt; Profiles -&gt; Keys 中，新建一个快捷键，例如 ⌥ + p ，Action 选择 Send Hex Code，键值为 0x1 0x70 0x63 0x20 0xd，保存生效。 更多的Hex Code可以到 manytricks 上查找。 使用场景：敲了一长串的命令后想使用代理功能时，就可以直接使用快捷键 ⌥ + p ，这样就会自动在命令的最前面加上 pc 测试1234proxychains4 curl cip.cc// 如果你设置了别名的话可以使用 pc 指代 proxychains4pc curl cip.cc 可以看到这就代理上了 123456789IP : xxx.xxx.xxx.xxx地址 : 美国 加利福尼亚州 洛杉矶运营商 : it7.net数据二 : 美国数据三 : 美国加利福尼亚洛杉矶URL : http:&#x2F;&#x2F;www.cip.cc&#x2F;xxx.xxx.xxx.xxx","categories":[{"name":"Others","slug":"Others","permalink":"http://linxunfeng.top/categories/Others/"}],"tags":[{"name":"FQ","slug":"FQ","permalink":"http://linxunfeng.top/tags/FQ/"},{"name":"Terminal","slug":"Terminal","permalink":"http://linxunfeng.top/tags/Terminal/"}]},{"title":"Swift 掌控Moya的网络请求、数据解析与缓存","slug":"Swift-掌控Moya的网络请求、数据解析与缓存","date":"2018-10-27T23:41:37.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2018/10/27/Swift-掌控Moya的网络请求、数据解析与缓存/","link":"","permalink":"http://linxunfeng.top/2018/10/27/Swift-%E6%8E%8C%E6%8E%A7Moya%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BC%93%E5%AD%98/","excerpt":"Moya 在Swift开发中起着重要的网络交互作用，但是还有不如之处，比如网络不可用时，返回的 Response 为 nil，这时还得去解析相应的 Error Codable 可以帮助我们快速的解析数据，但是一旦声明的属性类型与json中的不一致，将无法正常解析; 而且对于模型中自定义属性名的处理也十分繁琐 +","text":"Moya 在Swift开发中起着重要的网络交互作用，但是还有不如之处，比如网络不可用时，返回的 Response 为 nil，这时还得去解析相应的 Error Codable 可以帮助我们快速的解析数据，但是一旦声明的属性类型与json中的不一致，将无法正常解析; 而且对于模型中自定义属性名的处理也十分繁琐 + Moya 在Swift开发中起着重要的网络交互作用，但是还有不如之处，比如网络不可用时，返回的 Response 为 nil，这时还得去解析相应的 Error Codable 可以帮助我们快速的解析数据，但是一旦声明的属性类型与json中的不一致，将无法正常解析; 而且对于模型中自定义属性名的处理也十分繁琐 解决的方案有很多，不过我比较习惯使用 MoyaMapper ，不仅可以解决上述问题，还提供了多种模型转换、数据互转、多种数据类型任意存储的便捷方法。掌控Moya的网络请求、数据解析与缓存简直易如反掌。 MoyaMapper是基于Moya和SwiftyJSON封装的工具，以Moya的plugin的方式来实现间接解析，支持RxSwift GitHub: MoyaMapper 📖 详细的使用请查看手册 https://MoyaMapper.github.io 特点 支持json 转 Model 自动映射 与 自定义映射 无视 json 中值的类型，Model 中属性声明的是什么类型，它就是什么类型 支持 Data 字典 JSON json字符串 Model 互转 插件方式，全方位保障Moya.Response，拒绝各种网络问题导致 Response 为 nil，将各式各样的原因导致的数据加载失败进行统一处理，开发者只需要关注 Response 可选 - 支持数据随意缓存( JSON 、 Number 、String、 Bool、 Moya.Response ) 可选 - 支持网络请求缓存 数据解析一、插件注入附：插件 MoyaMapperPlugin 的详细使用 1、定义适用于项目接口的 ModelableParameterType 1234567// statusCodeKey、tipStrKey、 modelKey 可以任意指定级别的路径，如： \"error&gt;used\"struct NetParameter : ModelableParameterType &#123; var successValue = \"000\" var statusCodeKey = \"retStatus\" var tipStrKey = \"retMsg\" var modelKey = \"retBody\"&#125; 2、在 MoyaProvider 中使用 MoyaMapperPlugin 插件，并指定 ModelableParameterType 1let lxfNetTool = MoyaProvider&lt;LXFNetworkTool&gt;(plugins: [MoyaMapperPlugin(NetParameter())]) ❗ 使用 MoyaMapperPlugin 插件是整个 MoyaMapper 的核心所在！ 二、Model声明 Model 需遵守 Modelable 协议 MoyaMapper 支持模型自动映射 和 自定义映射 不需要考虑源json数据的真实类型，这里统一按 Model 中属性声明的类型进行转换 1、一般情况下如下写法即可 1234567struct CompanyModel: Modelable &#123; var name : String = \"\" var catchPhrase : String = \"\" init() &#123; &#125;&#125; 2、如果自定义映射，则可以实现方法 mutating func mapping(_ json: JSON) 12345678910struct CompanyModel: Modelable &#123; var name : String = \"\" var catchPhrase : String = \"\" init() &#123; &#125; mutating func mapping(_ json: JSON) &#123; self.name = json[\"nickname\"].stringValue &#125;&#125; 3、支持模型嵌套 12345678struct UserModel: Modelable &#123; var id : String = \"\" var name : String = \"\" var company : CompanyModel = CompanyModel() init() &#123; &#125;&#125; 三、Response 解析 1、以下示例皆使用了 MoyaMapperPlugin ，所以不需要指定 解析路径 2、如果没有使用 MoyaMapperPlugin 则需要指定 解析路径，否则无法正常解析 ps: 解析路径 可以使用 a&gt;b 这种形式来解决多级路径的问题 解析方法如下列表所示 方法 描述 (支持RxSwift) toJSON Response 转 JSON ( toJSON rx.toJSON) fetchString 获取指定路径的字符串( fetchString rx.fetchString) fetchJSONString 获取指定路径的原始json字符串 ( fetchJSONString rx.fetchJSONString ) mapResult Response -&gt; MoyaMapperResult (Bool, String) ( mapResult rx.mapResult ) mapObject Response -&gt; Model ( mapObject rx.mapObject) mapObjResult Response -&gt; (MoyaMapperResult, Model) ( mapObjResult rx.mapObjResult) mapArray Response -&gt; [Model] ( mapArray rx.mapArray) mapArrayResult Response -&gt; (MoyaMapperResult, [Model]) ( mapArrayResult rx.mapArrayResult) ❗除了 fetchJSONString 的默认解析路径是根路径之外，其它方法的默认解析路径为插件对象中的 modelKey 如果接口请求后 json 的数据结构与下图类似，则使用 MoyaMapper 是最合适不过了 1234567891011121314// Normallet model = response.mapObject(MMModel.self)print(\"name -- \\(model.name)\")print(\"github -- \\(model.github)\")// 打印jsonprint(response.fetchJSONString())// RxrxRequest.mapObject(MMModel.self) .subscribe(onSuccess: &#123; (model) in print(\"name -- \\(model.name)\") print(\"github -- \\(model.github)\") &#125;).disposed(by: disposeBag) 附： fetchJSONString的详细使用 12345678910111213141516// Normallet models = response.mapArray(MMModel.self)let name = models[0].nameprint(\"count -- \\(models.count)\")print(\"name -- \\(name)\")// 打印 json 模型数组中第一个的nameprint(response.fetchString(keys: [0, \"name\"]))// RxrxRequest.mapArray(MMModel.self) .subscribe(onSuccess: &#123; models in let name = models[0].name print(\"count -- \\(models.count)\") print(\"name -- \\(name)\") &#125;).disposed(by: disposeBag) 附：mapArray的详细使用说明 1234567891011// Normallet (isSuccess, tipStr) = response.mapResult()print(\"isSuccess -- \\(isSuccess)\")print(\"tipStr -- \\(tipStr)\")// RxrxRequest.mapResult() .subscribe(onSuccess: &#123; (isSuccess, tipStr) in print(\"isSuccess -- \\(isSuccess)\") // 是否为 \"000\" print(\"retMsg -- \\(retMsg)\") // \"缺少必要参数\" &#125;).disposed(by: disposeBag) 附：mapResult的详细使用说明 统一处理网络请求结果 在APP的实际使用过程中，会遇到各种各样的网络请求结果，如:服务器挂了、手机无网络，此时 Moya 返回的 Response 为 nil，这样我们就不得不去判断 Error。但是使用 MoyaMapperPlugin 就可以让我们只关注 Response 12345678// MoyaMapperPlugin 的初始化方法public init&lt;T: ModelableParameterType&gt;( _ type: T, transformError: Bool = true)type : ModelableParameterType 用于定义字段路径，做为全局解析数据的依据transformError : Bool 是否当网络请求失败时，自动转换请求结果，默认为 true 当请求失败的时候，此时的 result.response 为 nil，根据transformError是否为true 判断是否创建一个自定义的 response 并返回出去。 ➡ 本来可以请求到的数据内容 ➡ 现在关闭网络，再请求数据 正常情况下，即不做任何不处理的时候， Response 为 nil 经过 MoyaMapperPlugin 处理的后可得到转换后的 Response ，如图 这里将请求失败进行了统一处理，无论是服务器还是自身网络的问题，retStatus 都为 MMStatusCode.loadFail，但是 errorDescription 会保持原来的样子并赋值给 retMsg。 retStatus 值会从枚举 MMStatusCode 中取 loadFail.rawValue ，即 700 取 类型为 ModelableParameterType 的 type 中 statusCodeKey 所指定的值 为键名，retMsg也同理 ps: 这个时候可以通过判断 retStatus 或 response.statusCode 是否与 MMStatusCode.loadFail.rawValue 相同来判断是否显示加载失败的空白页占位图 1234enum MMStatusCode: Int &#123; case cache = 230 case loadFail = 700&#125; 枚举 MMStatusCode 中除了 loadFail ，还有 cache，我们已经知道 loadFail 在数据加载失败的时候会出现，那 cache 是在什么时候出来呢？不急，看下一节就知道了。 数据缓存一、基本使用12345&#x2F;&#x2F; 缓存@discardableResultMMCache.shared.cache&#96;XXX&#96;(value : XXX, key: String, cacheContainer: MMCache.CacheContainer &#x3D; .RAM) -&gt; Bool&#x2F;&#x2F; 取舍MMCache.shared.fetch&#96;XXX&#96;Cache(key: String, cacheContainer: MMCache.CacheContainer &#x3D; .RAM) 缓存成功会返回一个 Bool 值，这里可不接收 XXX 所支持类型 Bool - Float - Double - String - JSON - Modelable [Modelable] Moya.Response - Int UInt Int8 UInt8 Int16 UInt16 Int32 UInt32 Int64 UInt64 其中，除了 Moya.Response 之外，其它类型皆是通过 JSON 来实现缓存 所以，如果你想清除这些类型的缓存，只需要调用如下方法即可 12345@discardableResultfunc removeJSONCache(_ key: String, cacheContainer: MMCache.CacheContainer = .RAM) -&gt; Bool@discardableResultfunc removeAllJSONCache(cacheContainer: MMCache.CacheContainer = .RAM) -&gt; Bool 清除 Moya.Response 则使用如下两个方法 12345@discardableResultfunc removeResponseCache(_ key: String) -&gt; Bool@discardableResultfunc removeAllResponseCache() -&gt; Bool 再来看看MMCache.CacheContainer 1234enum CacheContainer &#123; case RAM // 只缓存于内存的容器 case hybrid // 缓存于内存与磁盘的容器&#125; 这两种容器互不相通，即 即使key相同，使用 hybrid 来缓存后，再通过 RAM 取值是取不到的。 RAM : 仅缓存于内存之中，缓存的数据在APP使用期间一直存在 hybrid ：缓存于内存与磁盘中，APP重启后也可以获取到数据 二、缓存网络请求内部缓存过程： APP首次启动并进行网络请求，网络数据将缓存起来 APP再次启动并进行网络请求时，会先返回缓存的数据，等请求成功后再返回网络数据 其它情况只会加载网络数据 每次成功请求到数据后，都会对缓存的数据进行更新 123456789101112131415// Normalfunc cacheRequest( _ target: Target, cacheType: MMCache.CacheKeyType = .default, callbackQueue: DispatchQueue? = nil, progress: Moya.ProgressBlock? = nil, completion: @escaping Moya.Completion) -&gt; Cancellable// Rxfunc cacheRequest( _ target: Base.Target, callbackQueue: DispatchQueue? = nil, cacheType: MMCache.CacheKeyType = .default) -&gt; Observable&lt;Response&gt; 实际上是对 Moya 请求后的 Response 进行缓存。 其实与 Moya 自带的方法相比较只多了一个参数 cacheType: MMCache.CacheKeyType ，定义着缓存中的 key ，默认为 default 下面是 MMCache.CacheKeyType 的定义 123456789101112&#x2F;** let cacheKey &#x3D; [method]baseURL&#x2F;path - default : cacheKey + &quot;?&quot; + parameters - base : cacheKey - custom : cacheKey + &quot;?&quot; + customKey *&#x2F;public enum CacheKeyType &#123; case &#96;default&#96; case base case custom(String)&#125; 如果你想缓存多页列表数据的最新一页数据，此时使用 default 是不合适的，因为 default 使用的 key 包含了 pageIndex，这样就达不到只缓存 最新一页数据 的目的， 所以这里应该使用 base 或者 custom(String) 我们可以来试一下带缓存的请求 123456789101112131415161718/* * APP第一次启动并进行网络请求，网络数据将缓存起来 * APP再次启动并进行网络请求时，会先加载缓存，再加载网络数据 * 其它情况只会加载网络数据 * 每次成功请求到数据都会进行数据更新 */lxfNetTool.rx.cacheRequest(.data(type: .all, size: 10, index: 1)) .subscribe(onNext: &#123; response in log.debug(\"statusCode -- \\(response.statusCode)\") &#125;).disposed(by: disposeBag)// 传统方式/*let _ = lxfNetTool.cacheRequest(.data(type: .all, size: 10, index: 1)) &#123; result in guard let resp = result.value else &#123; return &#125; log.debug(\"statusCode -- \\(resp.statusCode)\")&#125;*/ 打印结果 123456789&#x2F;&#x2F; 首次使用APPstatusCode -- 200&#x2F;&#x2F; 关闭并重新打开APP，再请求一下statusCode -- 230statusCode -- 200&#x2F;&#x2F; 然后再请求一下statusCode -- 200 这里的 230 就是 MMStatusCode.cache.rawValue CocoaPods 默认安装 MoyaMapper默认只安装Core下的文件1pod 'MoyaMapper' RxSwift拓展 1pod 'MoyaMapper/Rx' 缓存拓展 1pod 'MoyaMapper/MMCache' Rx缓存 1pod 'MoyaMapper/RxCache'","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"Swift 优雅的适配大小","slug":"Swift-优雅的适配大小","date":"2018-10-24T20:44:50.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2018/10/24/Swift-优雅的适配大小/","link":"","permalink":"http://linxunfeng.top/2018/10/24/Swift-%E4%BC%98%E9%9B%85%E7%9A%84%E9%80%82%E9%85%8D%E5%A4%A7%E5%B0%8F/","excerpt":"在日常开发中常常会对设备进行一定的适配，为了方便在多个项目里统一管理和使用，所以封装并开源了SwiftyFitsize这个库，可用于适配视图及字体大小，同时也支持 xib 和 storyboard GitHub: SwiftyFitsize +","text":"在日常开发中常常会对设备进行一定的适配，为了方便在多个项目里统一管理和使用，所以封装并开源了SwiftyFitsize这个库，可用于适配视图及字体大小，同时也支持 xib 和 storyboard GitHub: SwiftyFitsize + 在日常开发中常常会对设备进行一定的适配，为了方便在多个项目里统一管理和使用，所以封装并开源了SwiftyFitsize这个库，可用于适配视图及字体大小，同时也支持 xib 和 storyboard GitHub: SwiftyFitsize 最终的效果如下图所示 安装使用Cocoapods安装，或手动拖入项目1pod &#39;SwiftyFitsize&#39; 使用SwiftyFitsize在默认状况下所使用的参照宽度为iphone6的375如果设计图所选用设备的宽度与默认值不同，可以在AppDelegate下初始化所参照的宽度 1SwiftyFitsize.reference(width: 414) 下面列出一些设备对应的分辨率，方便查找 设备 逻辑分辨率(point) 设备分辨率(pixel) SE 320x568 640x1136 6(S)／7／8 375x667 750x1334 6(S)+／7+／8+ 414x736 1080x1920 X(S) 375x812 1125x2436 XR 414x896 828x1792 XS Max 414x896 1242x2688 使用也是非常方便的，只需要在Number、UIFont、CGPoint、CGSize、UIEdgeInsetsMake这些类型的值后面加上~即可123456100~UIFont.systemFont(ofSize: 14)~CGPoint(x: 10, y: 10)~CGSize(width: 100, height: 100)~CGRect(x: 10, y: 10, width: 100, height: 100)~UIEdgeInsetsMake(10, 10, 10, 10)~ xib / storyboard 字体适配支持控件 UILabel UIButton UITextView UITextField xib / storyboard 约束适配 ##### 注：~请不要相互嵌套使用，如 1CGPoint(x: 10~, y: 10~)~","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS-面向协议封装全屏旋转功能","slug":"iOS-面向协议封装全屏旋转功能","date":"2018-09-15T18:05:45.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2018/09/15/iOS-面向协议封装全屏旋转功能/","link":"","permalink":"http://linxunfeng.top/2018/09/15/iOS-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E5%B0%81%E8%A3%85%E5%85%A8%E5%B1%8F%E6%97%8B%E8%BD%AC%E5%8A%9F%E8%83%BD/","excerpt":"关于使用面向协议来封装功能的实战可以参考我上篇文章 【iOS-面向协议方式封装空白页功能】，这里就不再赘述，我们直接进入使用阶段吧。本篇文章只有一个目的，那就是只要遵守协议，一行代码随意切换全屏～ 如果对面向协议有疑问的同学可以看下我之前的两篇文章 iOS - Swift 面向协议编程（一） iOS - Swift 面向协议编程（二） +","text":"关于使用面向协议来封装功能的实战可以参考我上篇文章 【iOS-面向协议方式封装空白页功能】，这里就不再赘述，我们直接进入使用阶段吧。本篇文章只有一个目的，那就是只要遵守协议，一行代码随意切换全屏～ 如果对面向协议有疑问的同学可以看下我之前的两篇文章 iOS - Swift 面向协议编程（一） iOS - Swift 面向协议编程（二） + 关于使用面向协议来封装功能的实战可以参考我上篇文章 【iOS-面向协议方式封装空白页功能】，这里就不再赘述，我们直接进入使用阶段吧。本篇文章只有一个目的，那就是只要遵守协议，一行代码随意切换全屏～ 如果对面向协议有疑问的同学可以看下我之前的两篇文章 iOS - Swift 面向协议编程（一） iOS - Swift 面向协议编程（二） 开源库 Name Link GitHub LXFProtocolTool Wiki Wiki首页 本文 Demo LXFFullScreenable 使用Cocoapods的方式来安装即可 1pod 'LXFProtocolTool/FullScreenable' 一、配置在AppDelegate中实现如下方法 123func application(_ application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?) -&gt; UIInterfaceOrientationMask &#123; return UIApplication.shared.lxf.currentVcOrientationMask&#125; 二、使用案例 方法与属性的调用都需要命名空间加上 lxf，如isFullScreen -&gt; lxf.isFullScreen 1isFullScreen : 获取当前遵守协议者是否为全屏状态 1234567func switchFullScreen( isEnter: Bool? = nil, specifiedView: UIView? = nil, superView: UIView? = nil, config: FullScreenableConfig? = nil, completed: ((_ isFullScreen: Bool)-&gt;Void)? = nil) Name Type Desc isEnter Bool? 是否进入全屏 specifiedView UIView? 指定即将全屏的视图 superView UIView? 作为退出全屏后specifiedView的父视图 config FullScreenableConfig? 配置 completed ((_ isFullScreen: Bool)-&gt;Void)? 进入/退出 全屏后的回调 当switchFullScreen的调用者为UIView时，如果specifiedView为nil会自动填写，superView也是如此 switchFullScreen方法不推荐直接使用，不过当遵守协议者为UIViewController时，可以通过使用默认参数来切换屏幕方向lxf.switchFullScreen() 以下分两种情况说明 UIViewController12345func enterFullScreen( specifiedView: UIView, config: FullScreenableConfig? = nil, completed: FullScreenableCompleteType? = nil) 12345func exitFullScreen( superView: UIView, config: FullScreenableConfig? = nil, completed: FullScreenableCompleteType? = nil) 以上两个方法是对switchFullScreen的抽离，使调用时对参数的传递更加清晰 1、遵守协议 FullScreenable 1class LXFFullScreenableController: UIViewController, FullScreenable &#123; &#125; 2、指定视图进入全屏1lxf.enterFullScreen(specifiedView: cyanView) 3、指定视图退出全屏，并添加到当前控制器的view上1lxf.exitFullScreen(superView: self.view) 🔥自动进入|退出全屏12345func autoFullScreen( specifiedView: UIView, superView: UIView, config: FullScreenableConfig? = nil) 控制器可以调用该方法来注册自动进入或退出全屏，各控制器之间互不影响。 view手动进入全屏会屏蔽当前控制器的自动全屏功能，退出方可恢复 UIView12345func enterFullScreen( specifiedView: UIView? = nil, config: FullScreenableConfig? = nil, completed: FullScreenableCompleteType? = nil) 12345func exitFullScreen( superView: UIView? = nil, config: FullScreenableConfig? = nil, completed: FullScreenableCompleteType? = nil) 以上两个方法是对switchFullScreen的抽离，使调用时对参数的传递更加清晰 1、遵守协议 FullScreenable 1class LXFFullScreenView: UIButton, FullScreenable &#123; &#125; 1let cyanView = LXFFullScreenView() 2、进入全屏 1cyanView.lxf.enterFullScreen() 3、退出全屏1cyanView.lxf.exitFullScreen() 这里是对遵守了FullScreenable协议的视图进入全屏切换，由于代码内部已经经过自动视图填写，所以\b直接调用相应的方法即可，当然也可以自己指定specifiedView和superView 三、FullScreenableConfig说明 上述的方法都有一个config参数，默认为nil，即为默认配置 相关属性说明| Name | Type | Desc | Default || ————————– | ———————— | —————————— | ————– || animateDuration | Double | 进入/退出 全屏时的旋转动画时间 | 0.25 || enterFullScreenOrientation | UIInterfaceOrientation | 进入全屏时的初始方向 | landscapeRight | 这里我们把动画时间设置为1s，初始方向为左后来看看效果1234FullScreenableConfig( animateDuration: 1, enterFullScreenOrientation : .landscapeLeft)12cyanView.lxf.enterFullScreen(config: diyConfig)cyanView.lxf.exitFullScreen(config: diyConfig) 结语到这里相关的说明已罗列完毕，有什么不清楚的可以下载Demo看看，或者在文章下方留言提问 LXFProtocolTool 主要是通过协议的方式来方便快捷地实现一些的实用功能，除了本文提及的全屏旋转功能外还有其它实用功能的封装，具体内容可以到 Wiki首页 查找。如果你有什么想实现的功能也可以提出来，喜欢的就给个Star鼓励下我吧 🚀 🚀 🚀，感谢支持！","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"AppRTC实战","slug":"AppRTC实战","date":"2018-06-07T22:49:36.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2018/06/07/AppRTC实战/","link":"","permalink":"http://linxunfeng.top/2018/06/07/AppRTC%E5%AE%9E%E6%88%98/","excerpt":"记录AppRTC的搭建过程，实现iOS、Android、Browser同异设备的视频通信","text":"记录AppRTC的搭建过程，实现iOS、Android、Browser同异设备的视频通信 1、记录AppRTC的搭建过程，实现iOS、安卓、browser同异设备的视频通信2、以下直接以root身份进行操作，所有的需要下载的文件均放置于/root目录下，需要的话，可以自行决定存放位置，但是要注意修改相关的配置路径～ 一、设备配置 阿里云ESC服务器 Ubuntu 16.04 64位 腾讯云域名 二、相关环境1、JDK123add-apt-repository ppa:openjdk-r/ppa apt-get update apt-get install openjdk-8-jdk 2、nodejsnodejs官网123// 这里的版本8.x可以按自己的需求去修改curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -apt-get install -y nodejs至此已经安装了最新版的nodejs和npm了,可以使用-v来查看当前版本 12node -vnpm -v 安装grunt-cli，后面需要grunt来构建房间服务器 1npm -g install grunt-cli 3、python与python-webtest12apt-get install python apt-get install python-webtest libevent12apt-cache search libeventapt-get install libevent-dev 三、Room Server 房间服务器123git clone https:&#x2F;&#x2F;github.com&#x2F;webrtc&#x2F;apprtc.git cd apprtcnpm install 1、配置 constants.py12# 当前目录 -- apprtcvim src/app_engine/constants.py 1234567891011121314151617181920212223# 这部分为 添加TURN_BASE_URL = 'https://linxunfeng.top' # 修改为你自己当前服务器的域名，下面的亦是如此TURN_URL_TEMPLATE = '%s/turn.php?username=%s&amp;key=%s' #如果turn.php未实现，可使用默认配置CEOD_KEY = 'lxf' # 这个很重要，后面配置turn时需要用到# 这部分为 修改ICE_SERVER_BASE_URL = 'https://linxunfeng.top'ICE_SERVER_URL_TEMPLATE = '%s/iceconfig.php?key=%s' #如果iceconfig.php未实现，可用默认配置，但是Android Apk会有问题ICE_SERVER_API_KEY = os.environ.get('ICE_SERVER_API_KEY')# Dictionary keys in the collider instance info constant.WSS_INSTANCE_HOST_KEY = 'linxunfeng.top:8089' #信令服务器端口号8089 WSS_INSTANCE_NAME_KEY = 'vm_name'WSS_INSTANCE_ZONE_KEY = 'zone'WSS_INSTANCES = [&#123; WSS_INSTANCE_HOST_KEY: 'linxunfeng.top:8089', WSS_INSTANCE_NAME_KEY: 'wsserver-std', WSS_INSTANCE_ZONE_KEY: 'us-central1-a'&#125;, &#123; WSS_INSTANCE_HOST_KEY: 'linxunfeng.top:8089', WSS_INSTANCE_NAME_KEY: 'wsserver-std-2', WSS_INSTANCE_ZONE_KEY: 'us-central1-f'&#125;] 2、编译12# 当前目录 -- apprtcgrunt build 编译好后apprtc目录下就会多出一个名为out的目录，里面存放的就是编译好的room server 3、GoogleAppEngine的安装与配置官网：GoogleAppEngine 可以在此路径找最新版本 GoogleAppEngine -&gt; Python -&gt; Download and install the original App Engine SDK for Python. 目前最新版本为：google_appengine_1.9.70.zip 下载 GoogleAppEngine 1wget https://storage.googleapis.com/appengine-sdks/featured/google_appengine_1.9.70.zip 解压 1unzip google_appengine_1.9.70.zip 设置环境变量 1vim /etc/profile 1export PATH=\"$PATH:/root/google_appengine/\" 应用环境变量 1source /etc/profile 4、开启 Room Server 基本命令 12# 当前路径 -- /root/google_appengine./dev_appserver.py --host=linxunfeng.top ../apprtc/out/app_engine/ 如果你使用的是阿里云服务器，这里就不能用域名linxunfeng.top来启动room server，而是使用本地网卡地址，否则就会提示 raise BindError(‘Unable to bind %s:%s’ % self.bind_addr)google.appengine.tools.devappserver2.wsgi_server.BindError: Unable to bind linxunfeng.top:8080 查看网卡 1ifconfig 1234root@xxx:~/google_appengine# ifconfigeth0 Link encap:Ethernet HWaddr 00:16:3e:08:b4:02 inet addr:172.18.141.108 Bcast:172.18.143.255 Mask:255.255.240.0 ... 1./dev_appserver.py --host=172.18.141.108 ../apprtc/out/app_engine/ 这样就好了吗？不，虽然没有报错，但是你用浏览器打开你的域名看看…这里直接给出最终命令，具体原因看 疑难杂症 - 1 最终命令 1234./dev_appserver.py --enable_host_checking=false --host=172.18.141.108 ../apprtc/out/app_engine/# 如果想直接后台运行，则使用如下命令nohup ./dev_appserver.py --enable_host_checking=false --host=172.18.141.108 ../apprtc/out/app_engine/ &amp; 访问 room server 1http:&#x2F;&#x2F;域名:8080 四、Collider Server 信令服务器1、拷贝collider源码12# 当前路径 -- /rootmkdir -p goWorkspace/src 把apprtc/src/collider/目录下的三个目录（collider、collidermain、collidertest）复制到goWorkspace/src/目录下 1cp -rf apprtc/src/collider/* /goWorkspace/src 2、修改代码 修改房间服务器的地址 12# goWorkspace/src/collidermain/main.govar roomSrv = flag.String(\"room-server\", \"https://域名\", \"The origin of the room server\") 修改网站证书路径 123456# goWorkspace/src/collider/collider.goe = server.ListenAndServeTLS(\"/etc/letsencrypt/live/域名/fullchain.pem\", \"/etc/letsencrypt/live/域名/privkey.pem\")# 如：e = server.ListenAndServeTLS(\"/etc/letsencrypt/live/linxunfeng.top/fullchain.pem\", \"/etc/letsencrypt/live/linxunfeng.top/privkey.pem\") 相关的SSL证书fullchain.pem和privkey.pem在后面的nginx配置中会提到，这里先写上 3、安装与配置环境 下载GO语言环境 FQ 到 GO官网上下载最新版本 当前最新版本：go1.10.2.linux-amd64.tar.gz 12# 当前路径 -- /rootwget https://dl.google.com/go/go1.10.2.linux-amd64.tar.gz 修改profile 1vim /etc/profile 打开profile后添加如下内容 123export GOROOT=/root/goexport GOPATH=/root/goWorkspaceexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin 应用环境变量 1source /etc/profile 4、编译进入目录 goWorkspace/src/ 12go get collidermaingo install collidermain 这里的编译过程需要翻墙，如果无法翻墙，请看以下内容，如果可以则直接跳至第5小点 1234# 当前路径 -- /root/goWorkspace/srcmkdir -p golang.org/x cd golang.org/x/git clone https://github.com/golang/net git clone成功后再执行上面的两行编译命令 5、开启 Collider Server进入goWorkspace下的bin目录，执行命令 123456# 当前路径 -- /root/goWorkspace/bin# -tls=true : 指需要数字证书./collidermain -port=8089 -tls=true# 如果想直接后台运行，则使用如下命令nohup ./collidermain -port=8089 -tls=true &amp; 五、STUN\\TURN服务器1、安装coturn1apt-get install coturn 2、修改配置 coturn 1vim /etc/default/coturn 把TURNSERVER_ENABLED=1的注释去掉 turnserver.conf 1vim /etc/turnserver.conf 12345678910111213141516171819listening-device=eth0 #此处eth0是电脑网卡名称listening-port=3478 #turn服务器的端口号relay-device=eth0 #此处eth0是电脑网卡名称min-port=49152max-port=65535Verbosefingerprintlt-cred-mechuse-auth-secretstatic-auth-secret=lxf #此处要和房间服务器配置时constants.py文件中的CODE_KEY保持一致。user=lxf:0x8638170519dd1309044bca55319ff929user=lxf:lxfstale-noncecert=/usr/local/etc/turn_server_cert.pempkey=/usr/local/etc/turn_server_pkey.pemno-loopback-peersno-multicast-peersmobilityno-cli 上述文件中 0x8638170519dd1309044bca55319ff929： turnadmin -k -u lxf -r north.gov -p lxf -k 表示生成一个long-term credential key-u 表示用户名-p 表示密码-r 表示Realm域 coturn的证书生成（即配置文件中cert和pkey) 1openssl req -x509 -newkey rsa:2048 -keyout /usr/local/etc/turn_server_pkey.pem -out /usr/local/etc/turn_server_cert.pem -days 99999 -nodes 3、启动coturn服务器1service coturn start 用浏览器打开1http:&#x2F;&#x2F;域名:3478 显示如下内容则说明成功开启服务 TURN Serveruse https connection for the admin session 六、配置nginx服务器1、生成SSL证书这里使用let’s encrypt颁发的免费SSL证书 certbot.eff.org 安装软件 12345sudo apt-get update apt-get install software-properties-common add-apt-repository ppa:certbot/certbot apt-get update apt-get install python-certbot-nginx 生成证书 1certbot --nginx certonly SSL证书生成的目录为：/etc/letsencrypt/live/域名/，里面存放着四个文件cert.pem,chain.pem,fullchain.pem,privkey.pem 2、安装php和php-fpm 安装php和php-fpm 12apt-get install php apt-get install php7.0-fpm 3、安装与配置nginx 安装nginx 1apt-get install nginx 修改nginx配置 1vim /etc/nginx/sites-available/default 将下面的linxunfeng.top修改为你自己的域名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768upstream roomserver &#123; server linxunfeng.top:8080;&#125;server &#123; listen 80 ; server_name linxunfeng.top; return 301 https://$server_name$request_uri;&#125;server &#123; #listen 80 default_server; #listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; listen 443; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don't use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; server_name linxunfeng.top; # 添加域名，如不添加，生成SSL证书时可能会有问题 #location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. # try_files $uri $uri/ =404; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # location ~ \\.php$ &#123; include snippets/fastcgi-php.conf; # # # With php7.0-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php7.0-fpm: fastcgi_pass unix:/run/php/php7.0-fpm.sock; &#125; location / &#123; proxy_pass http://roomserver$request_uri; proxy_set_header Host $host; &#125; ssl on; ssl_certificate /etc/letsencrypt/live/linxunfeng.top/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/linxunfeng.top/privkey.pem; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; turn.php 与 iceconfig.php在/var/www/html/目录下创建两个文件 1touch turn.php iceconfig.php turn.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php $request_username = $_GET[\"username\"]; if (empty($request_username)) &#123; echo \"username == null\"; exit; &#125; $request_key = $_GET[\"key\"]; $time_to_live = 600; $timestamp = time() + $time_to_live;//失效时间 $response_username = $timestamp.\":\".$_GET[\"username\"]; $response_key = $request_key; if (empty($response_key)) &#123; $response_key = \"code_key\"; &#125; //constants.py中CEOD_KEY $response_password = getSignature($response_username, $response_key); $jsonObj = new Response(); $jsonObj-&gt;username = $response_username; $jsonObj-&gt;password = $response_password; $jsonObj-&gt;ttl = 86400; //此处需配置自己的服务器 $jsonObj-&gt;uris= array(\"stun:linxunfeng.top:3478\",\"turn:linxunfeng.top:3478?transport=udp\",\"turn:linxunfeng.top?transport=tcp\"); echo json_encode($jsonObj);/** * 使用HMAC-SHA1算法生成签名值 * * @param $str 源串 * @param $key 密钥 * * @return 签名值 */function getSignature($str, $key)&#123; $signature = \"\"; if (function_exists('hash_hmac')) &#123; $signature = base64_encode(hash_hmac(\"sha1\", $str, $key, true)); &#125; else &#123; $blocksize = 64; $hashfunc = 'sha1'; if (strlen($key) &gt; $blocksize) &#123; $key = pack('H*', $hashfunc($key)); &#125; $key = str_pad($key, $blocksize, chr(0x00)); $ipad = str_repeat(chr(0x36), $blocksize); $opad = str_repeat(chr(0x5c), $blocksize); $hmac = pack('H*', $hashfunc(($key ^ $opad) . pack('H*', $hashfunc(($key ^ $ipad) . $str)))); $signature = base64_encode($hmac); &#125; return $signature;&#125; class Response &#123; public $username = \"\"; public $password = \"\"; public $ttl = \"\"; public $uris = array(\"\"); &#125;?&gt; iceconfig.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php $request_username = \"lxf\"; //配置成自己的turn服务器用户名 if (empty($request_username)) &#123; echo \"username == null\"; exit; &#125; $request_key = \"lxf\"; //配置成自己的turn服务器密码 $time_to_live = 600; $timestamp = time() + $time_to_live;//失效时间 $response_username = $timestamp.\":\".$_GET[\"username\"]; $response_key = $request_key; if (empty($response_key)) &#123; $response_key = \"CEOD_KEY\"; &#125;//constants.py中CEOD_KEY $response_password = getSignature($response_username, $response_key); $arrayObj = array(); $arrayObj[0]['username'] = $response_username; $arrayObj[0]['credential'] = $response_password; //配置成自己的stun/turn服务器 $arrayObj[0]['urls'][0] = \"stun:linxunfeng.top:3478\"; $arrayObj[0]['urls'][1] = \"turn:linxunfeng.top:3478?transport=tcp\"; $arrayObj[0]['uris'][0] = \"stun:linxunfeng.top:3478\"; $arrayObj[0]['uris'][1] = \"turn:linxunfeng.top:3478?transport=tcp\"; $jsonObj = new Response(); $jsonObj-&gt;lifetimeDuration = \"300.000s\"; $jsonObj-&gt;iceServers = $arrayObj; echo json_encode($jsonObj);/** * 使用HMAC-SHA1算法生成签名值 * * @param $str 源串 * @param $key 密钥 * * @return 签名值 */function getSignature($str, $key)&#123; $signature = \"\"; if (function_exists('hash_hmac')) &#123; $signature = base64_encode(hash_hmac(\"sha1\", $str, $key, true)); &#125; else &#123; $blocksize = 64; $hashfunc = 'sha1'; if (strlen($key) &gt; $blocksize) &#123; $key = pack('H*', $hashfunc($key)); &#125; $key = str_pad($key, $blocksize, chr(0x00)); $ipad = str_repeat(chr(0x36), $blocksize); $opad = str_repeat(chr(0x5c), $blocksize); $hmac = pack('H*', $hashfunc(($key ^ $opad) . pack('H*', $hashfunc(($key ^ $ipad) . $str)))); $signature = base64_encode($hmac); &#125; return $signature;&#125; class Response &#123; public $username = \"\"; public $password = \"\"; public $ttl = \"\"; public $uris = array(\"\"); &#125;?&gt; 重启Nginx服务器和php7.0-fpm 12service nginx restart service php7.0-fpm restart 七、各端运行测试1、Browser浏览器直接打开即可，如果不能访问摄像头之类的，请查看疑难杂症 - 2 1https:&#x2F;&#x2F;域名 2、Androidwebrtc-android-demo-apprtc 直接安装手机，打开软件，点击右上角的扳手跳转至设置界面，滚到界面最下方，找到Room server URL.，将其修改为刚刚搭建好的服务器域名即可，如 1https:&#x2F;&#x2F;linxunfeng.top 3、iOSGitHub - ISBX/apprtc-ios 打开AppRTC项目，分别修改以下两个文件 ARTCVideoChatViewController.m 1#define SERVER_HOST_URL @\"https://linxunfeng.top\" Pods -&gt; Development Pods -&gt; AppRTC -&gt; Lib -&gt; ARDAppClient.m 1234567static NSString *kARDRoomServerHostUrl = @\"https://linxunfeng.top\";static NSString *kARDDefaultSTUNServerUrl = @\"stun:linxunfeng.top:3478\";static NSString *kARDTurnRequestUrl = @\"https://linxunfeng.top\" @\"/turn?username=lxf&amp;key=lxf\"; 1234567// 搜索 kARDDefaultSTUNServerUrl - (RTCICEServer *)defaultSTUNServer &#123; NSURL *defaultSTUNServerURL = [NSURL URLWithString:kARDDefaultSTUNServerUrl]; return [[RTCICEServer alloc] initWithURI:defaultSTUNServerURL username:@\"lxf\" password:@\"lxf\"];&#125; 疑难杂症1、Request host is not whitelist enabled 具体提示Request host is not whitelist enabled for this server. Please use the –host command-line flag to whitelist a specific host (recommended) or use –enable_host_checking to disable host checking. See the command-line flags help text for more information. 参考链接 执行dev_appserver.py时，加上如下参数1--enable_host_checking=false 完整指令1./dev_appserver.py --enable_host_checking=false --host=172.18.141.108 ../apprtc/out/app_engine/ 2、浏览器无法访问摄像头浏览器访问设备的摄像头是需要使用https链接或者localhost来访问 3、端口阿里云等国内大厂提供的服务器基本上都有一个叫安全组的玩意儿，我们搭建AppRTC服务器的所有服务所需的端口均要添加至安全组 4、Failed to execute ‘pushState’ on ‘History’ Failed to start signaling: Failed to execute ‘pushState’ on ‘History’: A history state object with URL ‘http://linxunfeng.top/r/598600855’ cannot be created in a document with origin ‘https://linxunfeng.top’ and URL ‘https://linxunfeng.top/ 解决方法有两种 解决方法1： 房间服务器编译完成后，在/root/apprtc/out/app_engine/js/apprtc.debug.js文件中找到window.history.pushState({‘roomId’: roomId, ‘roomLink’: roomLink}, roomId, roomLink)，把这句话注释掉，重新运行即可。（如果重新编译，需要重新修改） 解决方法2： 在/root/apprtc/src/web_app/js/appcontroller.js文件中找到window.history.pushState({‘roomId’: roomId, ‘roomLink’: roomLink}, roomId, roomLink)，把这句话注释掉，然后重新编译，重新运行房间服务器即可。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://linxunfeng.top/categories/Linux/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://linxunfeng.top/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"http://linxunfeng.top/tags/Linux/"},{"name":"Android","slug":"Android","permalink":"http://linxunfeng.top/tags/Android/"}]},{"title":"打造Moya便捷解析库，提供RxSwift拓展","slug":"iOS/打造Moya便捷解析库，提供RxSwift拓展","date":"2018-05-24T20:25:04.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2018/05/24/iOS/打造Moya便捷解析库，提供RxSwift拓展/","link":"","permalink":"http://linxunfeng.top/2018/05/24/iOS/%E6%89%93%E9%80%A0Moya%E4%BE%BF%E6%8D%B7%E8%A7%A3%E6%9E%90%E5%BA%93%EF%BC%8C%E6%8F%90%E4%BE%9BRxSwift%E6%8B%93%E5%B1%95/","excerpt":"MoyaMapper是基于Moya和SwiftyJSON封装的工具，以Moya的plugin的方式来实现间接解析，支持RxSwift +","text":"MoyaMapper是基于Moya和SwiftyJSON封装的工具，以Moya的plugin的方式来实现间接解析，支持RxSwift + 一、概述1、相信大家在使用Swift开发时，Moya是首选的网络工具，在模型解析这一块，Swift版模型解析的相关第三方库有很多，本人最习惯用的就是SwiftyJSON。 2、下面会开始讲解整个主要的开发功能与思想。 3、以下内容是基于大家会使用Moya和SwiftJSON的前提下所著，还不会的同学可以先简单了解后再来阅读本篇文章哦～ 二、功能开发与思想讲解1、尝试模型解析Moya请求服务器返回的数据以Response类返回给我们，那我们就给Response类做一个扩展，这里以解析模型为例1234567// 需要传入一个参数，告知我们要转换出什么模型public func mapObject&lt;T: Modelable&gt;(_ type: T.Type) -&gt; T &#123; // 模型解析过程 。。。 return T&#125; Q: 那中间的解析过程该怎么写呢？ A: 可以让开发者遵守某个协议，实现指定的转换方法并描述转换关系。其转换过程我们不需要知道，交给开发者即可。 那接着我们来定义一个协议Modelable，并声明转换方法123public protocol Modelable &#123; mutating func mapping(_ json: JSON)&#125; 开发者创建一个MyMoel的结构体，遵守协议Modelable,并实现mapping，书写转换关系1234567struct MyModel: Modelable &#123; var _id = \"\" mutating func mapping(_ json: JSON) &#123; self._id = json[\"_id\"].stringValue &#125;&#125; 以目前的现状来分析一下：mapObject可以让开发者传入模型类型，而我们的协议方法却并非是个类方法。那我们需要先得到这个模型类型的对象，再来调用mapping方法 2、模型解析的驱动开发Q: 怎么得到这个对象？ A: 可以在协议中声明一个初始化方法来创建对象。是的，我们在mapObject中创建对应模型类型的对象，调用mapping方法来转换数据，再把模型对象传出去即可。 那我们在Modelable中声明一个init方法，并传入一个参数，区别于其它初始化方法1234public protocol Modelable &#123; mutating func mapping(_ json: JSON) init(_ json: JSON)&#125; OK，现在把mapObject方法补齐模型解析过程 1234567public func mapObject&lt;T: Modelable&gt;(_ type: T.Type) -&gt; T &#123; let modelJson = JSON(data)[\"modelKey\"] // 模型解析过程 var obj = T.init(modelJson) obj.mapping(modelJson) return obj&#125; 3、自定义解析键名Q: 这样是搞定解析了，但是网络请求回来的json格式错综复杂，有什么办法可以让开发者来自行指定model对应的键名呢？ A: 嗯嗯，既然解析过程是在 Response 扩展里操作的，那我们可以通过协议定义键名属性，并且使用 Runtime 给Response动态添加一个属性，来记录遵守协议后的相应类名 12345678910public protocol ModelableParameterType &#123; /// 请求成功时状态码对应的值 static var successValue: String &#123; get &#125; /// 状态码对应的键 static var statusCodeKey: String &#123; get &#125; /// 请求后的提示语对应的键 static var tipStrKey: String &#123; get &#125; /// 请求后的主要模型数据的键 static var modelKey: String &#123; get &#125;&#125; 123456789101112131415// MARK:- runtimeextension Response &#123; private struct AssociatedKeys &#123; static var lxf_modelableParameterKey = \"lxf_modelableParameterKey\" &#125; var lxf_modelableParameter: ModelableParameterType.Type &#123; get &#123; let value = objc_getAssociatedObject(self, &amp;AssociatedKeys.lxf_modelableParameterKey) as AnyObject guard let type = value as? ModelableParameterType.Type else &#123; return NullParameter.self &#125; return type &#125; set &#123; objc_setAssociatedObject(self, &amp;AssociatedKeys.lxf_modelableParameterKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; &#125;&#125; 这里有个坑：_SwiftValue问题 (献上 参考链接)如果我们存储的不是OC对象，那么objc_getAssociatedObject取出来的值的类型统统为_SwiftValue，直接as? ModelableParameterType.Type绝对是nil，需要在取出来后as AnyObject再转换为其它类型才会成功～～ 现在开发者就可以创建一个类来遵守ModelableParameterType协议，并自定义解析键名123456struct NetParameter : ModelableParameterType &#123; static var successValue: String &#123; return \"false\" &#125; static var statusCodeKey: String &#123; return \"error\" &#125; static var tipStrKey: String &#123; return \"errMsg\" &#125; static var modelKey: String &#123; return \"results\" &#125;&#125; 4、插件注入Q: 厉害了，不过要在什么时机下存储这个自定义键名的NetParameter？ A: 额，这个～～～ 哦，对了，可以通过Moya提供的插件机制！ 翻出Moya中的Plugin.Swift，找到这个process方法，看看方法说明。123/// 在结束之前，可以被用来修改请求结果/// Called to modify a result before completion.func process(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) -&gt; Result&lt;Moya.Response, MoyaError&gt; 那好，我们也做一个插件MoyaMapperPlugin给开发者使用，在创建MoyaMapperPlugin时把自定义解析键名的类型传进来1234567891011121314151617public struct MoyaMapperPlugin: PluginType &#123; var parameter: ModelableParameterType.Type public init&lt;T: ModelableParameterType&gt;(_ type: T.Type) &#123; parameter = type &#125; // modify response public func process(_ result: Result&lt;Response, MoyaError&gt;, target: TargetType) -&gt; Result&lt;Response, MoyaError&gt; &#123; _ = result.map &#123; (response) -&gt; Response in // 趁机添加相关数据 response.lxf_modelableParameter = parameter return response &#125; return result &#125;&#125; 使用：开发者在创建MoyaProvider对象时，顺便注入插件。(OS: 这一步堪称“注入灵魂”)1MoyaProvider&lt;LXFNetworkTool&gt;(plugins: [MoyaMapperPlugin(NetParameter.self)]) 5、总结 以上就是主要的踩坑过程了。模型数组解析和指定解析也跟这些差不多的，这里就不再赘述。本人已经将其封装成一个开源库 MoyaMapper，包含了上述已经和未曾说明的功能，下面会讲解如何去使用。以上部分可以称为开胃菜，目的就是平滑过渡到下面MoyaMapper的具体使用。 可能单单使用MoyaMapper的默认子库Core，作用体会上并不会很深。但是，如果你也是使用RxSwift来开发项目的话，请安装&#39;MoyaMapper/Rx&#39;吧，绝对一个字：「爽」 二、MoyaMapper的使用 MoyaMapper是基于Moya和SwiftyJSON封装的工具，以Moya的plugin的方式来实现间接解析，支持RxSwift 1、定义并注入自定义键名类 定义一个遵守ModelableParameterType协议的结构体 1234567// 各参数返回的内容请参考上面JSON数据对照图struct NetParameter : ModelableParameterType &#123; static var successValue: String &#123; return \"false\" &#125; static var statusCodeKey: String &#123; return \"error\" &#125; static var tipStrKey: String &#123; return \"\" &#125; static var modelKey: String &#123; return \"results\" &#125;&#125; 此外，这里还可以做简单的路径处理，以应付各种情况，以’&gt;’隔开 12345// 假设返回的json数据关于请求状态的相关数据如下所示，error: &#123; 'errorStatus':false 'errMsg':'error Argument type'&#125; 12// 我们指明解析路径：error对象下的errMsg字段，一层层表示下去即可static var tipStrKey: String &#123; return \"error&gt;errMsg\" &#125; 以plugin的方式传递给MoyaProvider 12// MoyaMapperPlugin这里只需要传入类型MoyaProvider&lt;LXFNetworkTool&gt;(plugins: [MoyaMapperPlugin(NetParameter.self)]) 2、定义解析模型创建一个遵守Modelable协议的结构体 1234567891011121314struct MyModel: Modelable &#123; var _id = \"\" ... init(_ json: JSON) &#123; &#125; mutating func mapping(_ json: JSON) &#123; self._id = json[\"_id\"].stringValue ... &#125;&#125;遵守Modelable协议，实现协议的两个方法，在`mapping`方法中描述模型字段的具体解析 3、解析数据0x00 请求结果与模型解析123456789101112// Resultpublic func mapResult(params: ModelableParamsBlock? = nil) -&gt; MoyaMapperResult// Modelpublic func mapObject&lt;T: Modelable&gt;(_ type: T.Type, modelKey: String? = nil) -&gt; T// Result+Modelpublic func mapObjResult&lt;T: Modelable&gt;(_ type: T.Type, params: ModelableParamsBlock? = nil) -&gt; (MoyaMapperResult, T)// Modelspublic func mapArray&lt;T: Modelable&gt;(_ type: T.Type, modelKey: String? = nil) -&gt; [T]// Result+Modelspublic func mapArrayResult&lt;T: Modelable&gt;(_ type: T.Type, params: ModelableParamsBlock? = nil) -&gt; (MoyaMapperResult, [T]) 上面的五个方法，观其名，知其意，这里就不过多解释了，主要注意两点： result 1234// 元祖类型// 参数1：根据statusCodeKey取出的值与successValue是否相等// 参数2：根据tipStrKey取出的值result：(Bool, String) params 12// params: ModelableParamsBlock? = nil// 这里只有在特殊场景下才需要使用到。如：项目中需要在某处使用特定接口，但是返回的json格式跟自己项目的不一样，并且只有这么一两处用得着该额外接口，那就需要我们这个参数了，以Block的方式返回解析参数类型。 0x01、特定解析1234// Modelpublic func toJSON(modelKey: String? = nil) -&gt; JSON// 获取指定路径的值public func fetchJSONString(path: String? = nil, keys: [JSONSubscriptType]) -&gt; String 这两个方法，如果没有指定路径，默认都是针对modelKey的12345// fetchJSONString(keys: &lt;[JSONSubscriptType]&gt;)1、通过 keys 传递数组, 该数组可传入的类型为 Int 和 String2、默认是以 modelKey 所示路径，来获取相应的数值。如果modelKey并非是你所想要使用的解析路径，可以使用下方的重载方法重新指定路径即可// response.fetchJSONString(path: &lt;String?&gt;, keys: &lt;[JSONSubscriptType]&gt;) MoyaMapper也提供了Rx子库，为方便RxSwift的流式编程下便捷解析数据 12345MoyaMapper默认只安装Core下的文件pod 'MoyaMapper'RxSwift拓展pod 'MoyaMapper/Rx' 具体使用还不是很明白的同学可以下载并运行Example看看 如果MoyaMapper有什么不足的地方，欢迎提出issues，感谢大家的支持","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"},{"name":"RxSwift","slug":"RxSwift","permalink":"http://linxunfeng.top/tags/RxSwift/"}]},{"title":"iOS-面向协议方式封装空白页功能","slug":"iOS-面向协议方式封装空白页功能","date":"2018-04-07T22:21:46.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2018/04/07/iOS-面向协议方式封装空白页功能/","link":"","permalink":"http://linxunfeng.top/2018/04/07/iOS-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E6%96%B9%E5%BC%8F%E5%B0%81%E8%A3%85%E7%A9%BA%E7%99%BD%E9%A1%B5%E5%8A%9F%E8%83%BD/","excerpt":"为了良好的交互体验，相信大家在对待scrollView无数据时的提示页都会使用一些第三方来定制，最典型的就是使用DZNEmptyDataSet。但是每个界面都写一堆与DZNEmptyDataSetDelegate，DZNEmptyDataSetSource相关的代码就不太好，那一般情况下自然的就会采用继承的方式来避免。而Swift除了可以面向对象编程，它还可以面向协议编程。那可不可以也用协议来解决情况呢？嘿嘿，这个可以有，那我们接下来就来试试怎么通过协议的方式来避免上述情况，并且实现一行代码添加空白页功能 +","text":"为了良好的交互体验，相信大家在对待scrollView无数据时的提示页都会使用一些第三方来定制，最典型的就是使用DZNEmptyDataSet。但是每个界面都写一堆与DZNEmptyDataSetDelegate，DZNEmptyDataSetSource相关的代码就不太好，那一般情况下自然的就会采用继承的方式来避免。而Swift除了可以面向对象编程，它还可以面向协议编程。那可不可以也用协议来解决情况呢？嘿嘿，这个可以有，那我们接下来就来试试怎么通过协议的方式来避免上述情况，并且实现一行代码添加空白页功能 + 为了良好的交互体验，相信大家在对待scrollView无数据时的提示页都会使用一些第三方来定制，最典型的就是使用DZNEmptyDataSet。但是每个界面都写一堆与DZNEmptyDataSetDelegate，DZNEmptyDataSetSource相关的代码就不太好，那一般情况下自然的就会采用继承的方式来避免。而Swift除了可以面向对象编程，它还可以面向协议编程。那可不可以也用协议来解决情况呢？嘿嘿，这个可以有，那我们接下来就来试试怎么通过协议的方式来避免上述情况，并且实现一行代码添加空白页功能 前言如果对面向协议有疑问的同学可以看下我之前的两篇文章 iOS - Swift 面向协议编程（一） iOS - Swift 面向协议编程（二） 之前的文章中提到了，协议除了起规范作用，还有别一个用处，就是赋予能力。我们现在的目的就是让目标控制器或者目标视图在遵守我们的协议后，就可以有实现空白页的功能。 一、基本实现1、创建协议1234// MARK:- 空视图占位协议public protocol LXFEmptyDataSetable &#123; &#125; 2、确定面向类确定我们面向的类，一般tableView或者collectionView都是写在控制器里，那我们面向的类就规定为UIViewController，或许也有人写在UIView里，不过这里先按UIViewController来写吧1234// MARK:- UIViewController - 空视图占位协议public extension LXFEmptyDataSetable where Self : UIViewController &#123; // 3、的实现的方法写在这里&#125; 3、定义功能方法将scrollView传递进来，让我们定义的方法来暗地里做些操作1234func lxf_EmptyDataSet(_ scrollView: UIScrollView) &#123; scrollView.emptyDataSetDelegate = self scrollView.emptyDataSetSource = self&#125; 4、设置数据源和代理在3、定义功能方法中将delegate和source设置为了self ，而协议是无法遵守再次遵守其它协议的，那让什么来遵守对应的协议呢？要明白这里的self指的是UIViewController,考虑到UIView的可能，这里我就让万物对象之父NSObject来遵守，并实现对应的数据源方法和代理方法1234567891011extension NSObject : DZNEmptyDataSetDelegate, DZNEmptyDataSetSource &#123; public func image(forEmptyDataSet scrollView: UIScrollView!) -&gt; UIImage! &#123; // 返回提示图片 &#125; public func title(forEmptyDataSet scrollView: UIScrollView!) -&gt; NSAttributedString! &#123; // 设置富文本标题 &#125; public func verticalOffset(forEmptyDataSet scrollView: UIScrollView!) -&gt; CGFloat &#123; // 设置纵向偏移 &#125;&#125; 二、定制空白页通过上述步骤后，只要让UIViewController遵守我们的协议，再调用一下lxf_EmptyDataSet方法就可以实现数据空白页了。但是，这样直接写死的方式很不好，有时候一些场景是需要我们做出定制的，那怎么实现定制呢？协议又不能有自己的变量来存放我们的定制。 这里先做出一个限定，我们要使用重载方法来完成该功能，实现即可高定制，又可使用默认定制。 回到刚刚的话题，使用UserDefaults来实现可以吗？可以，但是比较麻烦，因为UserDefaults是单例，整个进程共用这一份资源，如果你当前controller遵守了我们的协议LXFEmptyDataSetable并做出了定制，那么当下一个controller在遵守协议后使用了默认定制时，那你要怎么办？还要区分scrollView，那就得保存当前scrollView，在退出当前controller后还要把对应的东西置空。好咯好咯，那你说到底要怎么搞才最合适？ 解决方案：拓展UIScrollView！！！有没有发现？，非常地恰巧，我们定义的方法lxf_EmptyDataSet需要外界将UIScrollView传递进来，在DZNEmptyDataSet的数据源方法和代理方法也有scrollView。那让UIScrollView来携带我们的定制就好啦。 1、定义定制相关的枚举这里我定义了常用的定制相关的枚举1234567891011121314public enum LXFEmptyDataSetAttributeKeyType &#123; /// 纵向偏移(-50) CGFloat case verticalOffset /// 提示语(暂无数据) String case tipStr /// 提示语的font(system15) UIFont case tipFont /// 提示语颜色(D2D2D2) UIColor case tipColor /// 提示图(LXFEmptyDataPic) UIImage case tipImage /// 允许滚动(true) Bool case allowScroll&#125; 2、拓展UIScrollView为UIScrollView定义一个定制相关的属性字典1234567891011121314extension UIScrollView &#123; private struct AssociatedKeys &#123; static var lxf_emptyAttributeDict:[LXFEmptyDataSetAttributeKeyType : Any]? &#125; /// 属性字典 var lxf_emptyAttributeDict: [LXFEmptyDataSetAttributeKeyType : Any]? &#123; get &#123; return objc_getAssociatedObject(self, &amp;AssociatedKeys.lxf_emptyAttributeDict) as? [LXFEmptyDataSetAttributeKeyType : Any] &#125; set &#123; objc_setAssociatedObject(self, &amp;AssociatedKeys.lxf_emptyAttributeDict, newValue as [LXFEmptyDataSetAttributeKeyType : Any]?, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; &#125;&#125; 3、完善lxf_EmptyDataSet方法这里我们让外界通过闭包的方式来定制自己的空白页12345678// MARK:- UIViewController - 空视图占位协议public extension LXFEmptyDataSetable where Self : UIViewController &#123; func lxf_EmptyDataSet(_ scrollView: UIScrollView, attributeBlock: (()-&gt;([LXFEmptyDataSetAttributeKeyType : Any]))? = nil) &#123; scrollView.lxf_emptyAttributeDict = attributeBlock != nil ? attributeBlock!() : nil scrollView.emptyDataSetDelegate = self scrollView.emptyDataSetSource = self &#125;&#125; 4、使用定制属性字典这里以返回提示图片的方法为例吧123456public func image(forEmptyDataSet scrollView: UIScrollView!) -&gt; UIImage! &#123; guard let tipImg &#x3D; scrollView.lxf_emptyAttributeDict?[.tipImage] as? UIImage else &#123; return UIImage(named: &quot;LXFEmptyDataPic&quot;) &#125; return tipImg&#125; 5、外界的使用姿势1234567891011121314151617181920212223242526class LXFEmptyDemoController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() initUI() &#125;&#125;extension LXFEmptyDemoController: LXFEmptyDataSetable &#123; fileprivate func initUI() &#123; let tableView = UITableView() // ... // 高定制 self.lxf_EmptyDataSet(tableView) &#123; () -&gt; ([LXFEmptyDataSetAttributeKeyType : Any]) in return [ .tipStr:\"哟哟哟\", .verticalOffset:-150, .allowScroll: false ] &#125; // 默认定制 // self.lxf_EmptyDataSet(tableView) &#125;&#125; 三、开源库我对这个过程进行一次整理，并做成一个名为 LXFProtocolTool 的库并上传至gitHub。可以使用Cocoapods的方式来安装使用 1pod &#39;LXFProtocolTool&#39; 我也将 iOS - Swift 面向协议编程（二） 中提及的通过协议便捷加载xib的功能也集成了进来。大家可以根据自己的需要在Podfile写明要安装的功能 Xib加载 1pod &#39;LXFProtocolTool&#x2F;LXFNibloadable&#39; 空白视图 1pod &#39;LXFProtocolTool&#x2F;LXFEmptyDataSetable&#39; 创建这个库的目的是为了通过协议的方式来方便快捷地实现一些的实用功能，目前功能不多，不过往后会逐渐增加，或许你有什么想实现的功能也可以提出来，喜欢的就给个Star鼓励下我吧 🚀 🚀 🚀","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS-组件化开发（四）：fastlane实现pod自动化","slug":"iOS-组件化开发（四）：fastlane实现pod自动化","date":"2018-04-06T19:53:20.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2018/04/06/iOS-组件化开发（四）：fastlane实现pod自动化/","link":"","permalink":"http://linxunfeng.top/2018/04/06/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Afastlane%E5%AE%9E%E7%8E%B0pod%E8%87%AA%E5%8A%A8%E5%8C%96/","excerpt":"在第一次组件化的时候，需要执行很多操作，这些操作可以在【iOS-组件化开发（一）：远程私有库的基本使用】，这里就不再赘述，在组件化后的重复性操作就是升级，而升级这个过程是一模一样的。那么，我们有什么办法可以很方便的搞定这一过程来节约我们大量的时间呢？ +","text":"在第一次组件化的时候，需要执行很多操作，这些操作可以在【iOS-组件化开发（一）：远程私有库的基本使用】，这里就不再赘述，在组件化后的重复性操作就是升级，而升级这个过程是一模一样的。那么，我们有什么办法可以很方便的搞定这一过程来节约我们大量的时间呢？ + 在第一次组件化的时候，需要执行很多操作，这些操作可以在【iOS-组件化开发（一）：远程私有库的基本使用】，这里就不再赘述，在组件化后的重复性操作就是升级，而升级这个过程是一模一样的。那么，我们有什么办法可以很方便的搞定这一过程来节约我们大量的时间呢？ 一、升级必备操作修改完核心代码后，一共还需要做以下几步：1、修改spec文件（修改s.version，s.description等）2、pod install （使Example与pod下来的库产生关联）3、提交本地仓库代码至远程仓库4、打标签，并提交至远程5、验证spec，并提至私有索引库 二、Fastlane1、简介Fastlane文档说明 Fastlane是一个ruby脚本集合，它可以按照我们指定的路线，在指定位置执行我们所要执行的操作。这里我们称这样的路线为「航道(lane)」，这样的操作称为「Action」 Action是Fastlane自动化流程中的最小执行单元，用来执行Fastlane脚本中的命令，关于更多的描述可以到Actions - fastlane docs查看，里面也介绍了常用的action有哪些，顺带附上action的源码地址，这个源码在后面自定义起参考作用 2、 安装 确保ruby为最新版本 12brew updatebrew install ruby 安装fastlane 1sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin fastlane 查看当前fastlane版本 1fastlane --version 查看所有action 1fastlane actions 三、fastlane初始化cd到你的本地组件仓库的根目录 初始化fastlanefastlane init不过这个步骤对我们来说可以跳过，在init后提示你输入一些东西，包括上传需要用到的APPLE ID什么的一堆东西，由于我们并不涉及这些，所以我们使用更方便的方式 123456# 创建一个fastlane文件夹# 进入fastlane目录# 创建一个Fastfile文件mkdir fastlanecd fastlanetouch Fastfile 1、修改Fastfile123456789desc &#39;描述航道作用&#39;lane :航道名称 do |options|&#x2F;&#x2F; options 可以用来传递参数&#x2F;&#x2F; 示例：varName &#x3D; options[:name]&#x2F;&#x2F; 航道上需要执行的操作end 航道上要扫描的操作可以到Actions上查找，可以通过关键字搜索，如下图点进去可以看到具体的使用及参数说明 这里附上本人的Fastfile内容：123456789101112131415161718192021222324252627282930313233343536373839desc &#39;LXFUpdatePodTool 航道用来自动化升级维护私有库&#39;lane : LXFUpdatePodTool do |options|tagNum &#x3D; options[:tag]podspecName &#x3D; options[:specName]# 航道上需要执行的操作# 具体action到 https:&#x2F;&#x2F;docs.fastlane.tools&#x2F;actions 上面查找# 这里的路径以仓库根目录为准# 1、修改spec文件（修改s.version，s.description等）# 2、pod install （使Example与pod下来的库产生关联）cocoapods( clean: true, podfile: &quot;.&#x2F;Example&#x2F;Podfile&quot;)# 3、提交本地仓库代码至远程仓库git_add(path: &quot;.&quot;)git_commit(path: &quot;.&quot;, message: &quot;upgrade repo&quot;)push_to_git_remote# 4、打标签，并提交至远程add_git_tag( tag: tagNum)push_git_tags# 5、验证spec，并提至私有索引库pod_lib_lint(allow_warnings: true)# 因为本地索引库repo的名字是基本上不会去改变的，所以这里直接写死 LXFSpecs# podspec的名字需要由外界传入pod_push(path: &quot;#&#123;podspecName&#125;.podspec&quot;, repo: &quot;LXFSpecs&quot;)end 2、验证Fastfile1fastlane lanes 3、执行fastlane需要在组件仓库的根目录下执行 1fastlane LXFUpdatePodTool tag:0.1.1 specName:LXFMain 整个执行过程不超过30秒～ 四、自定义Action以上的过程已经可以完成一整个自动化更新了，但是有一点需要注意的是，这个输入的tag可能会面临一个问题，那就是本地和远程都可能已经存在，即发生冲突，这个时候我们可以选择自动删除本地和远程冲突的那个tag，再重新上传当前tag 1、创建一个新的action1fastlane new_action 按要求输入Action名称 完成后fastlane目录下就会多出一个名为actions的文件夹，里面存放的就是你自定义action 2、编辑自定义action打开remove_git_tag.rb，开始自定义我们的action吧，什么？不会语法怎么办？可以参考别人的嘛，上面给出的action的源码地址就有用武之地了，比如pod_push。这里我直接贴出我已经完成的主要代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 可以使用 fastlane action remove_git_tag 来参看详细描述def self.run(params) # 这里写要执行的操作 # params[:参数名称] 参数名称与下面self.available_options中的保持一致 tagNum &#x3D; params[:tagNum] rmLocalTag &#x3D; params[:rmLocalTag] rmRemoteTag &#x3D; params[:rmRemoteTag] command &#x3D; [] if rmLocalTag # 删除本地标签 # git tag -d 标签名称 command &lt;&lt; &quot;git tag -d #&#123;tagNum&#125;&quot; end if rmRemoteTag # 删除远程标签 # git push origin :标签名称 command &lt;&lt; &quot;git push origin :#&#123;tagNum&#125;&quot; end result &#x3D; Actions.sh(command.join(&#39;&amp;&#39;)) UI.success(&quot;Successfully remove tag 🚀 &quot;) return resultenddef self.description # 对当前脚本的简单描述 &quot;删除tag&quot;enddef self.details # 对当前脚本的具体描述 &quot;使用当前action来删除本地和远程冲突的tag&quot;enddef self.available_options # 用来传递参数 [ FastlaneCore::ConfigItem.new(key: :tagNum, description: &quot;输入即将删除的tag&quot;, is_string: true), FastlaneCore::ConfigItem.new(key: :rmLocalTag, description: &quot;是否删除本地tag&quot;, optional:true, is_string: false, default_value: true), FastlaneCore::ConfigItem.new(key: :rmRemoteTag, description: &quot;是否删除远程tag&quot;, optional:true, is_string: false, default_value: true) ]enddef self.authors # 作者姓名 [&quot;LinXunFeng&quot;]end 3、查看action描述同样，这里先cd到组件库的根目录下执行，原因是这个自定义action只存在当前根目录下的fastlane中，其它fastlane的非自定义的action就不用在当前根目录下操作～1fastlane action remove_git_tag 4、测试执行先来看看当前组件库已存在的tag1git tag 可以看到，我是已经有一个0.1.1版本的了。这时我们再来执行一次LXFUpdatePodTool航道1fastlane LXFUpdatePodTool tag:0.1.1 specName:LXFMain 五、工具拿走LXFUpdatePodTool 已经传到我的GitHub上，需要的同学就拿走吧，顺手给个Star咯 Orz","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://linxunfeng.top/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://linxunfeng.top/tags/GitHub/"},{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://linxunfeng.top/tags/Cocoapods/"},{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"组件化","slug":"组件化","permalink":"http://linxunfeng.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"iOS-组件化开发（三）：加载资源文件","slug":"iOS-组件化开发（三）：加载资源文件","date":"2018-04-06T19:52:11.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2018/04/06/iOS-组件化开发（三）：加载资源文件/","link":"","permalink":"http://linxunfeng.top/2018/04/06/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/","excerpt":"经过前两篇文章的学习，相信对组件化开发有了大致的了解，那我们这篇文章就来讲讲资源文件的加载吧 +","text":"经过前两篇文章的学习，相信对组件化开发有了大致的了解，那我们这篇文章就来讲讲资源文件的加载吧 + 经过前两篇文章的学习，相信对组件化开发有了大致的了解，那我们这篇文章就来讲讲资源文件的加载吧 这里我新建了一个LXFMain组件库，主要是用来显示TabBar的玩意，然后再进行组件化抽离出来，其中的过程这里不再赘述，还没了解过的同学建议先阅读下这两篇文章吧 iOS-组件化开发（一）：远程私有库的基本使用 iOS-组件化开发（二）：远程私有库的更新与子库 这里跟之前不一样的地方在于多了图片资源，组件的核心代码放在Classes文件夹中，而图片我们则存放于Assets目录下，如图所示 一、修改Spec将关于资源加载的注释去掉1234s.resource_bundles &#x3D; &#123; # &#39;LXFMain&#39; &#x3D;&gt; [&#39;LXFMain&#x2F;Assets&#x2F;*.png&#39;] &#39;LXFMain&#39; &#x3D;&gt; [&#39;LXFMain&#x2F;Assets&#x2F;*&#39;]&#125; 回到LXFMain的模板库，我们进行一次本地的安装和测试(pod install) 可以看到，图片资源也安装进来了，但是运行的效果如下图，图片并不能成功加载出来 二、修改加载资源代码这是当前加载图片的相关代码1[UIImage imageNamed:@&quot;图片名称&quot;]; 右击显示包内容 图片就在这个LXFMain.bundle里面(这里就不截图看了)，这里主要是让大家对这个目录结构有个了解 我们对imageNamed进行跳转到定义操作 1&#x2F;&#x2F; load from main bundle 可以看到，官方注释着imageNamed加载的是main bundle中的资源,mainBundle的位置如下图 这样当然就无法加载到图片啦，我们需要让它加载自己当前所在bundle里的图片 ，所以加载图片的代码需要进行修改1234NSString *normalImgName = @\"个人@2x.png\";NSBundle *curBundle = [NSBundle bundleForClass:self.class]; // 获取当前bundleNSString *normalImgPath = [curBundle pathForResource:normalImgName ofType:nil inDirectory:@\"LXFMain.bundle\"];UIImage *normalImage = [UIImage imageWithContentsOfFile:normalImgPath]; 但是直接写LXFMain.bundle并不好，不可控，所以还需要改进一下：12345678NSString *normalImgName &#x3D; [NSString stringWithFormat:@&quot;%@@2x.png&quot;, normalImg];NSBundle *curBundle &#x3D; [NSBundle bundleForClass:self.class];&#x2F;&#x2F; *********** 重点 *********** &#x2F;&#x2F;NSString *curBundleName &#x3D; curBundle.infoDictionary[@&quot;CFBundleName&quot;];NSString *curBundleDirectory &#x3D; [NSString stringWithFormat:@&quot;%@.bundle&quot;, curBundleName];NSString *normalImgPath &#x3D; [curBundle pathForResource:normalImgName ofType:nil inDirectory:curBundleDirectory];&#x2F;&#x2F; *************************** &#x2F;&#x2F;UIImage *normalImage &#x3D; [UIImage imageWithContentsOfFile:normalImgPath]; 三、聊聊xibXib的加载也是如此1234NSBundle *curBundle &#x3D; [NSBundle bundleForClass:self.class];LXFCenterView *centerView &#x3D; (LXFCenterView *)[curBundle loadNibNamed:@&quot;LXFCenterView&quot; owner:nil options:nil].firstObject;centerView.frame &#x3D; CGRectMake(30, 140, 200, 100);[self.view addSubview:centerView];不过xib中值得一提的是，如果是直接在xib中拖入一个imageView控件来设置图片的加载，我们则需要在图片名字前加上当前bundle名称1LXFMain.bundle&#x2F;个人 这里除了当前xib要加载的图片不属于mainBundle这个原因之外，还有一点就是xib文件与bundle存放位置属于同一级别，故直接使用相对路径的方式，在图片名字前加上bundle名称即可。 虽然无法在xib上直接看到效果，不过确实是有效的 四、遇到的小问题1[!] Unable to find a pod with name, author, summary, or description matching &#96;lxfmain&#96; 我做完一切操作后发现搜索报上面那个错，解决方案是删除本地索引文件，然后再搜索一遍，系统会自动帮你再生成一切本地索引文件，然后就搞定了～12rm -rf ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json pod search lxfmain","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://linxunfeng.top/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://linxunfeng.top/tags/GitHub/"},{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://linxunfeng.top/tags/Cocoapods/"},{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"组件化","slug":"组件化","permalink":"http://linxunfeng.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"iOS-组件化开发（二）：远程私有库的更新与子库","slug":"iOS-组件化开发（二）：远程私有库的更新与子库","date":"2018-04-06T19:50:41.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2018/04/06/iOS-组件化开发（二）：远程私有库的更新与子库/","link":"","permalink":"http://linxunfeng.top/2018/04/06/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%AD%90%E5%BA%93/","excerpt":"在上一篇【iOS-组件化开发（一）：远程私有库的基本使用】中我们已经实战了远程私有库的基本操作，但是组件不可能上传一次就完事了，随着业务的增加，我们的组件可能还需要添加更多的东西，或者修复一些问题，这就需要我们对私有库代码进行升级与维护 +","text":"在上一篇【iOS-组件化开发（一）：远程私有库的基本使用】中我们已经实战了远程私有库的基本操作，但是组件不可能上传一次就完事了，随着业务的增加，我们的组件可能还需要添加更多的东西，或者修复一些问题，这就需要我们对私有库代码进行升级与维护 + 在上一篇【iOS-组件化开发（一）：远程私有库的基本使用】中我们已经实战了远程私有库的基本操作，但是组件不可能上传一次就完事了，随着业务的增加，我们的组件可能还需要添加更多的东西，或者修复一些问题，这就需要我们对私有库代码进行升级与维护 这里以对基础组件里添加了一个Cache工具为例 添加完成后我们需要更新到远程仓库 一、更新远程仓库cd 到本地仓库的位置，执行以下操作 1、代码更新123git add .git commit -m &#39;更新描述&#39;git push origin master 2、版本更新版本更新 这一步非常重要，为更新索引库做准备 12git tag -a &#39;新版本号&#39; -m &#39;注释&#39;git push --tags 查看远程仓库，标签数已经有2个了，点进去就可以看到0.2.0，这里我们就不去看了 二、修改描述文件并更新索引库1、修改Sepc打开你的xx.podspec文件，将原本的版本号改为0.2.0，与刚刚的tag保持一致1s.version &#x3D; &#39;0.2.0&#39; 2、验证远程Spec1pod spec lint --private 3、更新索引库1pod repo push 索引库名称 xxx.podspec 三、更新使用123&#x2F;&#x2F; --no-repo-update 不更新本地索引库&#x2F;&#x2F; 因为刚刚已经自己手动更新过了，所以这里我们选择跳过更新pod update --no-repo-update 四、第三方依赖当我们的私有库需要依赖其它第三方才可以正常使用时，我们就需要在spec文件中开启依赖，例如下面所示代码，表明当前仓库需要依赖AFN和SDWebImage12s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.2.0&#39;s.dependency &#39;SDWebImage&#39;, &#39;~&gt; 4.3.3&#39;修改后更新操作同上所述，这里就不再赘述了。 但是这里存在一个问题，如果来了一位新的小伙伴，他所负责的部分只需要LXFBase下的Category，而LXFBase下的Cache才需要依赖SDWebImage，此时他若是pod一整个LXFBase岂不是平白无故安装了第三方依赖库，那应该怎么做呢？ 方案就是可以通过子库Subspecs来解决因需要一个小小的工具而依赖整个基础组件的问题 五、子库Subspecs什么是Subspecs？这里我们可以搜索一下SDWebImage 1pod search &#39;SDWebImage&#39; 可以看到，如果我们只需要用到SDWebImage中的GIF功能，那么并不需要将整个SDWebImage都下载下来，在Podfile中将pod &#39;SDWebImage&#39; 改为 pod SDWebImage/GIF即可单独使用这一功能 那接下来我们就来看看怎么描述一个子库吧 子库格式123s.subspec &#39;子库名称&#39; do |别名|end 因为这里已经分离出子库了，所以s.source_files和s.dependency就不能这么使用了，需要我们在子库里分别指定，所以我们直接把原来的s.source_files和s.dependency都注释掉。写法参考如下 123456789101112131415# s.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;**&#x2F;*&#39;# s.dependency &#39;SDWebImage&#39;, &#39;~&gt; 4.3.3&#39;s.subspec &#39;Cache&#39; do |c| c.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;Cache&#x2F;**&#x2F;*&#39; c.dependency &#39;SDWebImage&#39;, &#39;~&gt; 4.3.3&#39;ends.subspec &#39;Category&#39; do |c| c.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;Category&#x2F;**&#x2F;*&#39;ends.subspec &#39;Tool&#39; do |t| t.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;Tool&#x2F;**&#x2F;*&#39;end 修改后再按之前的步骤更新索引库和组件库就可以了 ps: 在添加第三方依赖描述后做验证或者上传操作可能会很慢，因为它在克隆第三方库如SDWebImage，有兴趣的可以在命令后面加入--verbose来查看详情情况1pod spec lint --private --verbose 在成功更新组件库和索引库后我们再来搜索一下试试1pod search &#39;LXFBase&#39; 现在就可以爱装哪个就装哪个了，在Podfile中指定要安装的子库就行了1pod &#39;LXFBase&#x2F;Cache&#39; 1pod install","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://linxunfeng.top/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://linxunfeng.top/tags/GitHub/"},{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://linxunfeng.top/tags/Cocoapods/"},{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"组件化","slug":"组件化","permalink":"http://linxunfeng.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"iOS-组件化开发（一）：远程私有库的基本使用","slug":"iOS-组件化开发（一）：远程私有库的基本使用","date":"2018-04-06T19:23:15.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2018/04/06/iOS-组件化开发（一）：远程私有库的基本使用/","link":"","permalink":"http://linxunfeng.top/2018/04/06/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"随着项目功能的不断增加，越来越多的开发人员加入，业务主线也随之越来越多，造成耦合越来越严重，编译越来越慢，测试不独立等一系列问题。为了解决此类情况，我们可以考虑到使用组件化开发 +","text":"随着项目功能的不断增加，越来越多的开发人员加入，业务主线也随之越来越多，造成耦合越来越严重，编译越来越慢，测试不独立等一系列问题。为了解决此类情况，我们可以考虑到使用组件化开发 + 随着项目功能的不断增加，越来越多的开发人员加入，业务主线也随之越来越多，造成耦合越来越严重，编译越来越慢，测试不独立等一系列问题。为了解决此类情况，我们可以考虑到使用组件化开发 1.概念组件化就是将一个单一工程的项目, 分解成为各个独立的组件， 然后按照某种方式, 任意组织成一个拥有完整业务逻辑的工程。 2.优势 独立：独立编写、编译、运行、测试 重用：功能代码的重复使用。比如不同项目使用同一功能模块 高效：任意增删模块，实现高效迭代 组件化还可以配合二进制化, 提高项目编译速度 3.组件分类大体上分三类：基础组件、功能组件和业务组件 基础组件：也称为公共组件，存放平时定义的宏、常量、协议、分类、对必要的第三方的封装类，以及各种处理工具类，如：时间、日期、设备信息、文件处理、沙盒管理等 功能组件： 自定义视图控件、一些特定功能的封装（如录音、播放音频封装） 业务组件：各种业务线 本篇先来介绍下远程私有库的基本使用，建议按顺序看完之后，回来再看一遍步骤归纳，加深了解，如有不足之处，欢迎指出，感谢 : ) 步骤归纳 创建远程索引库和私有库 将远程索引库添加到本地 pod repo add 索引库名称 索引库地址 在本地创建一个pod模板库 pod lib create 组件名称将框架的核心代码添加到Classes目录下本地安装测试核心代码是否可用 pod install修改Spec描述文件将修改好的模板库上传至远程私有库 上传代码和打标签git initgit add .git commit -m &quot;提交描述&quot;git remote add origin 远程私有库地址git push origin mastergit tag &#39;0.1.0&#39;git push --tags 提交spec至私有索引库pod lib lint --privatepod spec lint --privatepod repo push 索引库的本地名称 xx.podspec 使用source 官方索引库urlsource 私有索引库urlpod &#39;组件名称&#39;pod install 接下来我们就来实战如何创建和使用私有库 一、创建私有索引库这里以码云为例，创建一个LXFSpecs的私有索引库，这玩意的作用如其名，就是用来索引的 二、本地添加私有索引库1、查看本地索引库1pod repo 如图，目前本地仅有github上的那个公有索引库 2、添加私有索引库将我们刚刚新建的私有索引库LXFSpecs添加到本地 12&#x2F;&#x2F; pod repo add 索引库名称 索引库地址pod repo add LXFSpecs https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFSpecs.git 现在本地就有两个索引库，好，索引库的事情就先放一边去了～ 三、创建组件库码云上的创建操作同上，这里以LXFBase为例，创建基础组件库 1、快速创建模版库到合适的位置创建一个与组件名相同的文件夹，cd进去后，使用如下命令12&#x2F;&#x2F; pod lib create 组件名pod lib create LXFBase 这里会让你配置一些信息，根据自己的情况自行配置即可。 2、添加组件内容创建完成后会自动帮我们打开相应的Example项目，LXFBase目录中会出现如图这些文件，我们把基础组件相关的东西丢到Classes文件夹中，并且把ReplaceMe.m文件删除 默认Classes文件夹中存放的文件就是pod install时要下载下来的文件，当然可以通过修改spec文件的配置来更改位置 3、安装与测试本地库在Example项目的Podfile文件中可以看到1pod &#39;LXFBase&#39;, :path &#x3D;&gt; &#39;..&#x2F;&#39;模板库已经默认帮我们在Podfile中指定了LXFBase.podspec的位置，使组件LXFBase可以正常安装使用和方便测试 1pod install 可以看到我们已经将本地的组件添加进Example中了，现在可以尽情地做你想做的测试，确保组件的可用。 测试组件没有问题后，我们接下来就要将podspec文件上传至私有索引库，不过在此之前，需要对spec进行修改。 4、 修改Spec具体的配置说明可以参考Cocoapods-创建第三方框架 主要的修改内容 123456789 s.name &#x3D; &#39;LXFBase&#39; s.version &#x3D; &#39;0.1.0&#39; s.summary &#x3D; &#39;LXFBase.&#39; s.description &#x3D; &lt;&lt;-DESCLXFBase是基础组件库，包括分类和常用工具 DESC s.homepage &#x3D; &#39;https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFBase&#39; s.source &#x3D; &#123; :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFBase.git&#39;, :tag &#x3D;&gt; s.version.to_s &#125; s.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;**&#x2F;*&#39; 四、上传组件代码1、将代码提交到组件仓库123456git add .git commit -m &#39;firstCommit&#39;git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFBase.git&#x2F;&#x2F; 第一次push如果报错的话可以加上-f&#x2F;&#x2F; git push -f origin mastergit push origin master 2、打标签标签0.1.0与spec中的s.version保持一致12git tag &#39;0.1.0&#39;git push --tags 五、提交podspec到私有索引库在上传spec文件前我们可以做一个验证来节省时间，不然每次都推送很久结果还是验证失败，会气死人的～ 1、本地验证Spec的必填字段12&#x2F;&#x2F; 本地验证不会验证 s.source 中的tagpod lib lint 2、远程验证12&#x2F;&#x2F; 远程验证会验证 s.source 中的tag，如果此时没有打上相应的标签则会报错pod spec lint 如果你刚才没有打标签并上传至远程私有库就来进行远程验证，肯定是会报错的 在打完并上传tag后再进行远程验证，就会验证成功了，验证成功后我们就可以进行下一步操作：提交podspec文件到索引库 验证私有库提示如果验证的是私有库，则在后面加上--private,否则会有警告，你可以选择--allow-warnings来忽略该警告12pod lib lint --privatepod spec lint --private 3、提交podspec12&#x2F;&#x2F; pod repo push 私有索引库名称 spec名称.podspec pod repo push LXFSpecs LXFBase.podspec 这里的操作过程：先将我们的代码直接push到本地索引库LXFSpecs，推送后会自动帮我们同步到远程索引库 再来看看码云上的私有索引库LXFSpecs 来测试下搜索我们的组件1pod search &#39;LXFBase&#39; 六、使用私有库这时我们可以来试试通过pod形式来添加组件LXFBase，创建一个新的项目 1、添加Podfile文件1pod init 2、在Podfile的最顶部添加如下描述123&#x2F;&#x2F; 第二行是为了保证公有库的正常使用source &#39;https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFSpecs.git&#39;source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39; 3、添加使用组件LXFBase1pod &#39;LXFBase&#39; 4、安装组件1pod install","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://linxunfeng.top/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://linxunfeng.top/tags/GitHub/"},{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://linxunfeng.top/tags/Cocoapods/"},{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"组件化","slug":"组件化","permalink":"http://linxunfeng.top/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"}]},{"title":"Cocoapods-创建第三方框架","slug":"Cocoapods-创建第三方框架","date":"2018-04-06T19:10:01.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2018/04/06/Cocoapods-创建第三方框架/","link":"","permalink":"http://linxunfeng.top/2018/04/06/Cocoapods-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/","excerpt":"将框架中的主要文件放入到一个指定文件夹中，比如叫Classes或者Lib都可以 +","text":"将框架中的主要文件放入到一个指定文件夹中，比如叫Classes或者Lib都可以 + 一、上传项目到github将框架中的主要文件放入到一个指定文件夹中，比如叫Classes或者Lib都可以 打开终端，cd到框架目录 1cd &#x2F;Users&#x2F;lxf&#x2F;xxxx&#x2F;LXFPhotoHelper 初始化仓库 1git init 将当前目录添加到缓存区 1git add . 提交到本地仓库 1git commit -m &#39;描述&#39; 添加远程仓库地址 1git remote add origin https:&#x2F;&#x2F;github.com&#x2F;LinXunFeng&#x2F;xxx.git 提交到远程仓库 1git push origin master 如果出现如下提示1fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.git&#x2F;&#39;: The requested URL returned error: 403原因是本地缓存了用户名和密码编辑.git目录下的config文件1vi .git&#x2F;config找到url那一行，在github.com前加上用户名后保存，再重新执行推送操作1url &#x3D; https:&#x2F;&#x2F;LinXunFeng@github.com&#x2F;LinXunFeng&#x2F;xxx.git 打标签 1234&#x2F;&#x2F; 具体说明可以执行&#96;git tag --help&#96;后查看&#x2F;&#x2F; git tag -a &#39;版本号&#39; -m &#39;tag描述&#39;&#x2F;&#x2F; 注意一下，这里打的标签只是在本地git tag &#39;0.0.1&#39; 推着所有标签至远程仓库 123&#x2F;&#x2F; 只推着指定版本&#x2F;&#x2F; git push origin 版本号 git push --tags 二、创建并修改podspec文件 创建Spec文件12&#x2F;&#x2F; 名称一般与工程名称保持一致pod spec create 框架名称 修改Spec文件123456789101112131415s.name &#x3D; &quot;LXFPhotoHelper（仓库名称）&quot;s.version &#x3D; &quot;0.0.1（版本号，这里跟下面s.source中的tag有关）&quot;s.summary &#x3D; &quot;对你自己仓库的简单描述，不要写太多字&quot;s.description &#x3D; &quot;这个是详细描述，这里需要注意的是，这里文字的长度需要比 s.summary的要长，不然会出现警告&quot;s.homepage &#x3D; &quot;仓库首页地址，如https:&#x2F;&#x2F;github.com&#x2F;LinXunFeng&#x2F;LXFPhotoHelper&quot;s.license &#x3D; &quot;MIT&quot;s.author &#x3D; &#123; &quot;LinXunFeng&quot; &#x3D;&gt; &quot;598600855@qq.com&quot; &#125;# source存放的地址是代码的真正地址s.source &#x3D; &#123; :git &#x3D;&gt; &quot;仓库对应的git地址，如https:&#x2F;&#x2F;github.com&#x2F;LinXunFeng&#x2F;LXFPhotoHelper.git&quot;, :tag &#x3D;&gt; &quot;#&#123;s.version&#125;&quot; &#125;# pod install时真正下载下来的文件路径，这里指定的是你仓库下的Classes目录中的所有.h和.m文件（填写的是相对地址）# ** 通配目录s.source_files &#x3D; &quot;Classes&quot;, &quot;Classes&#x2F;**&#x2F;*.&#123;h,m&#125;&quot;# s.library &#x3D; &quot;sqlite3&quot; # 框架依赖系统的sqlite3 也可以上官网的手册【Podspec Syntax Reference】上查看 这里需要我们注意的是s.version= &quot;0.0.1&quot;，这里的版本号要与刚刚打的tag一致 三、注册trunk123&#x2F;&#x2F; --verbose 打印详情信息&#x2F;&#x2F; pod trunk register 邮箱 &#39;你的名称&#39; --verbosepod trunk register 598600855@qq.com &#39;LinXunFeng&#39; --verbose 然后去验证邮箱验证成功后会提示我们回到终端，并敲入pod trunk push 名称.podspec 四、上传Spec执行pod trunk push后会有一个审核的过程，如果提示没有通过，有ERROR就修改好后重新push，如果只是WARN可以选择在pod trunk push后面加上--allow-warnings来忽略它们1pod trunk push LXFPhotoHelper.podspec --allow-warnings 如果出现如下信息，则说明你的框架名字已被占用，得重新改个名字～所以，在创建你自己的cocoapods仓库时最好是到cocoapods.org上先查一下有没有相同名字的1[!] You (xxx@qq.com) are not allowed to push new versions for this pod. The owners of this pod are yyy@qq.com. 上传成功后会自动帮我们更新本地仓库，如果无法搜索到自己的框架，可以先删掉本地的索引文件后再搜索一次1rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json 当使用pod search 命令可以搜索自己的框架时, 那么就意味着审核通过了","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://linxunfeng.top/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://linxunfeng.top/tags/GitHub/"},{"name":"Cocoapods","slug":"Cocoapods","permalink":"http://linxunfeng.top/tags/Cocoapods/"}]},{"title":"Python-虚拟环境","slug":"Python-虚拟环境","date":"2018-04-02T16:26:22.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2018/04/02/Python-虚拟环境/","link":"","permalink":"http://linxunfeng.top/2018/04/02/Python-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","excerpt":"平时在开发时我们都会先安装一些python需要的包，每次安装都会有一个版本，如果不同项目需要不同版本的包时就会出现不兼容的情况。应对这种情况我们就可以搭建多个虚拟环境来应对不同的环境需求，在虚拟环境中搭建一个Python项目运行所需要的那些包，将来根据运行的项目来切换不同环境即可 +","text":"平时在开发时我们都会先安装一些python需要的包，每次安装都会有一个版本，如果不同项目需要不同版本的包时就会出现不兼容的情况。应对这种情况我们就可以搭建多个虚拟环境来应对不同的环境需求，在虚拟环境中搭建一个Python项目运行所需要的那些包，将来根据运行的项目来切换不同环境即可 + 平时在开发时我们都会先安装一些python需要的包，每次安装都会有一个版本，如果不同项目需要不同版本的包时就会出现不兼容的情况。应对这种情况我们就可以搭建多个虚拟环境来应对不同的环境需求，在虚拟环境中搭建一个Python项目运行所需要的那些包，将来根据运行的项目来切换不同环境即可 我们可以在当前用户的家目录中找到【.virtualenvs】文件夹，查看当前所有的虚拟环境 创建虚拟环境 创建：mkvirtualenv [虚拟环境名称] 1mkvirtualenv lxfenv1 注：创建的过程需要联网 1Installing setuptools, pkg_resources, pip, wheel...done. 刚刚安装时提示安装的这些东西就存放在你创建好的虚拟环境下的【lib/python2.7/site-packages/】目录中 退出：deactivate当我们安装好虚拟环境后默认就使用了该虚拟环境，如图标识处可以看出 如果你想退出当前的虚拟环境，或以使用如下命令： 1deactivate 进入：workon [虚拟环境名称] 使用指定的虚拟环境则使用如下命令： 1workon lxfenv1 删除：rmvirtualenv [虚拟环境名称] 1rmvirtualenv lxfenv1 安装拓展包 查看当前安装好的包 123pip list或者pip freeze ps: 上图pip list中列出的四个包是安装虚拟环境必定会安装的包如图，pip list会列出所有的包，而pip freeze只会列出扩展的包 安装指定包12pip install django&#x3D;&#x3D;1.8.2# &#x3D;&#x3D;1.8.2 为指定版本号，不写则直接安装最新的包 注： pip install xxx 会自动删除旧版本，再安装新版本 如果不知道包名可以到pypi上搜索","categories":[{"name":"Python","slug":"Python","permalink":"http://linxunfeng.top/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://linxunfeng.top/tags/python/"}]},{"title":"RxSwift + MJRefresh 打造自动处理刷新控件状态","slug":"RxSwift-MJRefresh-打造自动处理刷新控件状态","date":"2017-10-24T08:51:20.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2017/10/24/RxSwift-MJRefresh-打造自动处理刷新控件状态/","link":"","permalink":"http://linxunfeng.top/2017/10/24/RxSwift-MJRefresh-%E6%89%93%E9%80%A0%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E5%88%B7%E6%96%B0%E6%8E%A7%E4%BB%B6%E7%8A%B6%E6%80%81/","excerpt":"MVVM的模式中，多出了ViewModel这个角色，将逻辑处理、网络请求等繁杂操作中ViewController中抽离出来，ViewController得以瘦身。结合RxSwift架构，我们一般就会在ViewModel中定义一个input收集繁杂操作所需的信息，通过一个transform方法将input作为参数传入，进而得到一个output供controller使用。 在使用RxSwift开发时会大量的使用到这种形式，其中就包括我们的网络请求。 +","text":"MVVM的模式中，多出了ViewModel这个角色，将逻辑处理、网络请求等繁杂操作中ViewController中抽离出来，ViewController得以瘦身。结合RxSwift架构，我们一般就会在ViewModel中定义一个input收集繁杂操作所需的信息，通过一个transform方法将input作为参数传入，进而得到一个output供controller使用。 在使用RxSwift开发时会大量的使用到这种形式，其中就包括我们的网络请求。 + 本文是基于 iOS-RxSwift项目实战记录 所述，如果你还未阅读过，建议你最好还先阅读一遍，并下载Demo熟悉一下 : ) 前言MVVM的模式中，多出了ViewModel这个角色，将逻辑处理、网络请求等繁杂操作中ViewController中抽离出来，ViewController得以瘦身。结合RxSwift架构，我们一般就会在ViewModel中定义一个input收集繁杂操作所需的信息，通过一个transform方法将input作为参数传入，进而得到一个output供controller使用。 在使用RxSwift开发时会大量的使用到这种形式，其中就包括我们的网络请求。结合 iOS-RxSwift项目实战记录 中所述的“MJRefresh在RxSwift中的使用”，在output中定义了一个变量1let refreshStatus = Variable&lt;LXFRefreshStatus&gt;(.none)controller通过output将其进行监听，从而当值发生变化时，controller就能实时获取当前应所处的刷新状态12345678910111213141516vmOutput.refreshStatus.asObservable().subscribe(onNext: &#123;[weak self] status in switch status &#123; case .beingHeaderRefresh: self?.tableView.mj_header.beginRefreshing() case .endHeaderRefresh: self?.tableView.mj_header.endRefreshing() case .beingFooterRefresh: self?.tableView.mj_footer.beginRefreshing() case .endFooterRefresh: self?.tableView.mj_footer.endRefreshing() case .noMoreData: self?.tableView.mj_footer.endRefreshingWithNoMoreData() default: break &#125;&#125;).addDisposableTo(rx_disposeBag) 如果在一个项目多处使用到了这种方式，我们就可以看到弊端——重复代码，过于冗余。 难道我们每次都要在controller中进行如此操作吗？ 面向协议关于协议的内容可以看下我之前的这两篇文章iOS - Swift 面向协议编程（一） iOS - Swift 面向协议编程（二） 总结协议的两大作用：1、规范 2、定制能力 定义协议 Refreshable 1234567891011121314151617/* ============================ Refreshable ================================ */// 需要使用 MJExtension 的控制器使用protocol Refreshable &#123; &#125;extension Refreshable where Self : UIViewController &#123; func initRefreshHeader(_ scrollView: UIScrollView, _ action: @escaping () -&gt; Void) -&gt; MJRefreshHeader &#123; scrollView.mj_header = MJRefreshNormalHeader(refreshingBlock: &#123; action() &#125;) return scrollView.mj_header &#125; func initRefreshFooter(_ scrollView: UIScrollView, _ action: @escaping () -&gt; Void) -&gt; MJRefreshFooter &#123; scrollView.mj_footer = MJRefreshAutoNormalFooter(refreshingBlock: &#123; action() &#125;) return scrollView.mj_footer &#125;&#125; 在controller中遵循 Refreshable 协议，通过initRefreshHeader方法或者initRefreshFooter方法给tableView或者collectionView赋予头部或尾部刷新的能力，并且书写下拉刷新时需要执行的代码12345// 以下拉刷新为例let refreshHeader = initRefreshHeader(liveCollectionView) &#123; [weak self] in // 下拉后需要执行的操作 self?.vmOutput?.requestCommand.onNext(())&#125; 接下来再讲讲output，只要有网络请求的地方，就会需要需要监听请求状态，既然这样，那么可以为output定义一个协议OutputRefreshProtocol，专门用来规范必需声明的属性1234567/* ============================ OutputRefreshProtocol ================================ */// viewModel 中 output使用protocol OutputRefreshProtocol &#123; // 告诉外界的tableView当前的刷新状态 var refreshStatus : Variable&lt;LXFRefreshStatus&gt; &#123;get&#125;&#125;接着让output去遵循该协议，并进行初始化刷新状态的值为.none123456789struct LXFLiveOutput: OutputRefreshProtocol &#123; var refreshStatus: Variable&lt;LXFRefreshStatus&gt; let sections: Driver&lt;[LXFLiveSection]&gt; init(sections: Driver&lt;[LXFLiveSection]&gt;) &#123; self.sections &#x3D; sections refreshStatus &#x3D; Variable&lt;LXFRefreshStatus&gt;(.none) &#125;&#125;到此为止，其实跟之前没啥两样，只是使controller更方便初始化刷新控件而已。接下来才是本文的重点。 重点刷新的状态无非也就那么几种，下拉重载数据，上拉加载更多，请求完成时结束下拉或上拉等等。。。那我们何必要在每个controller中再去管理这等琐事？？而至此，刷新控件的状态是由变量 refreshStatus 来决定，此时 refreshStatus 又声明在 OutputRefreshProtocol 协议中，我们何不再定义一个方法，将刷新控件的状态交给refreshStatus自己来帮我们处理呢～ 1234567891011121314151617181920extension OutputRefreshProtocol &#123; func autoSetRefreshHeaderStatus(header: MJRefreshHeader?, footer: MJRefreshFooter?) -&gt; Disposable &#123; return refreshStatus.asObservable().subscribe(onNext: &#123; (status) in switch status &#123; case .beingHeaderRefresh: header?.beginRefreshing() case .endHeaderRefresh: header?.endRefreshing() case .beingFooterRefresh: footer?.beginRefreshing() case .endFooterRefresh: footer?.endRefreshing() case .noMoreData: footer?.endRefreshingWithNoMoreData() default: break &#125; &#125;) &#125;&#125; 这时需要我们将刷新控件的对象 header / footer 传入到方法中，实现自动控制刷新控件状态。 总结使用一、output中遵守协议 OutputRefreshProtocol， 并初始化 refreshStatus 的值为 none 123456789struct LXFLiveOutput: OutputRefreshProtocol &#123; var refreshStatus: Variable&lt;LXFRefreshStatus&gt; let sections: Driver&lt;[LXFLiveSection]&gt; init(sections: Driver&lt;[LXFLiveSection]&gt;) &#123; self.sections = sections refreshStatus = Variable&lt;LXFRefreshStatus&gt;(.none) &#125;&#125; 二、controller 遵守协议 Refreshable，通过协议中的方法初始化刷新控件及对应的操作，并将刷新控件对象作为参数传入到自动处理状态方法中1extension LXFLiveViewController: Refreshable1234let refreshHeader = initRefreshHeader(liveCollectionView) &#123; [weak self] in self?.vmOutput?.requestCommand.onNext(())&#125;vmOutput?.autoSetRefreshHeaderStatus(header: refreshHeader, footer: nil).disposed(by: rx.disposeBag) 三、viewModel中根据实际情况实时更新 refreshStatus 的刷新状态 案例协议：Refreshable.swiftViewModel：LXFLiveViewModelController：LXFLiveViewController LXFBiliBili","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"},{"name":"RxSwift","slug":"RxSwift","permalink":"http://linxunfeng.top/tags/RxSwift/"}]},{"title":"iOS - 视频采集详解","slug":"iOS-视频采集详解","date":"2017-10-16T23:26:38.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/10/16/iOS-视频采集详解/","link":"","permalink":"http://linxunfeng.top/2017/10/16/iOS-%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86%E8%AF%A6%E8%A7%A3/","excerpt":"苹果官方文档-AVFoundation 为了管理从相机或者麦克风等这样的设备捕获到的信息，我们需要输入对象(input)和输出对象(output)，并且使用一个会话(AVCaptureSession)来管理 input 和 output 之前的数据流 +","text":"苹果官方文档-AVFoundation 为了管理从相机或者麦克风等这样的设备捕获到的信息，我们需要输入对象(input)和输出对象(output)，并且使用一个会话(AVCaptureSession)来管理 input 和 output 之前的数据流 + 苹果官方文档-AVFoundation 为了管理从相机或者麦克风等这样的设备捕获到的信息，我们需要输入对象(input)和输出对象(output)，并且使用一个会话(AVCaptureSession)来管理 input 和 output 之前的数据流： 类名 简介 AVCaptureDevice 输入设备，例如 摄像头 麦克风 AVCaptureInput 输入端口 [使用其子类] AVCaptureOutput 设备输出 [使用其子类]，输出视频文件或者静态图像 AVCaptureSession 管理输入到输出的数据流 AVCaptureVideoPreviewLayer 展示采集 预览View 如图，通过单个 session，也可以管理多个 input 和 output 对象之间的数据流，从而得到视频、静态图像和预览视图 如图，input 可以有一个或多个输入端口，output 也可以有一个或多个数据来源（如：一个 AVCaptureMovieFileOutput 对象可以接收视频数据和音频数据） 当添加 input 和 output 到 session 中时，session 会自动建立起一个连接(AVCaptureConnection)。我们可以使用这个 connection 来设置从 input 或者 从 output 得到的数据的有效性，也可以用来监控在音频信道中功率的平均值和峰值。 使用 Session 来管理数据流创建一个 session 用来管理捕获到的数据，需要先将 inputs 和 outputs 添加到 session 中，当 session 执行 [startRunning] 方法后就会开始将数据流发送至 session，通过执行[stopRunning] 方法来结束数据流的发送。12345AVCaptureSession *captureSession = [[AVCaptureSession alloc] init];// 添加 inputs 和 outputs[session startRunning];在 [session startRunning] 之前我们需要进行一些基本的配置 (如：设备分辨率，添加输入输出对象等) 设置分辨率1234// 设置分辨率 720P 标清if ([captureSession canSetSessionPreset:AVCaptureSessionPreset1280x720]) &#123; captureSession.sessionPreset = AVCaptureSessionPreset1280x720;&#125; 附苹果官方文档中可供配置的分辨率列表 其中高分辨率(AVCaptureSessionPresetHigh) 为默认值，会根据当前设备进行自适应，但是这样之后导出来的文件就会很大，一般情况下设置为标清(AVCaptureSessionPreset1280x720) 就可以了 输入对象12&#x2F;&#x2F; 直接使用后置摄像头AVCaptureDevice *videoDevice &#x3D; [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; 12345&#x2F;&#x2F; 在这个方法中的 mediaType 有三个选项供我们使用&#x2F;&#x2F; AVMediaTypeVideo 视频&#x2F;&#x2F; AVMediaTypeAudio 音频&#x2F;&#x2F; AVMediaTypeMuxed 混合(视频 + 音频)+ (nullable AVCaptureDevice *)defaultDeviceWithMediaType:(AVMediaType)mediaType; 但是这种方式只能获取到后置摄像头，如果想要获取前置摄像头，可使用12345678AVCaptureDevice *videoDevice;NSArray *devices &#x3D; [AVCaptureDevice devices];for (AVCaptureDevice *device in devices) &#123; if(device.position &#x3D;&#x3D; AVCaptureDevicePositionFront) &#123; &#x2F;&#x2F; 前置摄像头 videoDevice &#x3D; device; &#125;&#125;123456&#x2F;&#x2F; 通过设备获取输入对象AVCaptureDeviceInput *videoInput &#x3D; [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:nil];&#x2F;&#x2F; 给会话添加输入if([captureSession canAddInput:videoInput]) &#123; [captureSession addInput:videoInput];&#125; 输出对象1234567891011121314151617&#x2F;&#x2F; 视频输出：设置视频原数据格式：YUV, RGB &#x2F;&#x2F; 苹果不支持YUV的渲染，只支持RGB渲染，这意味着： YUV &#x3D;&gt; RGBAVCaptureVideoDataOutput *videoOutput &#x3D; [[AVCaptureVideoDataOutput alloc] init];&#x2F;&#x2F; videoSettings: 设置视频原数据格式 YUV FULLvideoOutput.videoSettings &#x3D; @&#123;(NSString *)kCVPixelBufferPixelFormatTypeKey:@(kCVPixelFormatType_420YpCbCr8BiPlanarFullRange)&#125;;&#x2F;&#x2F; 设置代理：获取帧数据&#x2F;&#x2F; 队列：串行&#x2F;并行，这里使用串行，保证数据顺序 dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;LinXunFengSerialQueue&quot;, DISPATCH_QUEUE_SERIAL);[videoOutput setSampleBufferDelegate:self queue:queue];&#x2F;&#x2F; 给会话添加输出对象if([captureSession canAddOutput:videoOutput]) &#123; &#x2F;&#x2F; 给会话添加输入输出就会自动建立起连接 [captureSession addOutput:videoOutput];&#125; 在这里，输出对象可以设置帧率 12&#x2F;&#x2F; 帧率：1秒10帧就差不多比较流畅了videoOutput.minFrameDuration &#x3D; CMTimeMake(1, 10); 输出对象在设置视频原数据格式时使用 videoSettings 属性，需要赋值的类型是字典格式有两种，一种是YUV，另一种是RGB（一般我们都使用YUV，因为体积比RGB小） 123456789101112&#x2F;&#x2F; keykCVPixelBufferPixelFormatTypeKey 指定解码后的图像格式&#x2F;&#x2F; valuekCVPixelFormatType_420YpCbCr8BiPlanarVideoRange : YUV420 用于标清视频[420v]kCVPixelFormatType_420YpCbCr8BiPlanarFullRange : YUV422 用于高清视频[420f] kCVPixelFormatType_32BGRA : 输出的是BGRA的格式，适用于OpenGL和CoreImage区别：1、前两种是相机输出YUV格式，然后转成RGBA，最后一种是直接输出BGRA，然后转成RGBA;2、420v 输出的视频格式为NV12；范围： (luma&#x3D;[16,235] chroma&#x3D;[16,240])3、420f 输出的视频格式为NV12；范围： (luma&#x3D;[0,255] chroma&#x3D;[1,255]) 预览图层123AVCaptureVideoPreviewLayer *previewLayer &#x3D; [AVCaptureVideoPreviewLayer layerWithSession:captureSession];previewLayer.frame &#x3D; self.view.bounds;[self.view.layer addSublayer:previewLayer]; 实时显示摄像头捕获到的图像，但不适用于滤镜渲染 代理方法12345678910111213#pragma mark - AVCaptureVideoDataOutputSampleBufferDelegate&#x2F;* CMSampleBufferRef: 帧缓存数据，描述当前帧信息 CMSampleBufferGetXXX : 获取帧缓存信息 CMSampleBufferGetDuration : 获取当前帧播放时间 CMSampleBufferGetImageBuffer : 获取当前帧图片信息 *&#x2F;&#x2F;&#x2F; 获取帧数据- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123; &#x2F;&#x2F; captureSession 会话如果没有强引用，这里不会得到执行 NSLog(@&quot;----- sampleBuffer ----- %@&quot;, sampleBuffer);&#125; 12// 获取帧播放时间CMTime duration = CMSampleBufferGetDuration(sampleBuffer); 在代理方法中，可以把 sampleBuffer 数据渲染出来去显示画面。适用于滤镜渲染12345678&#x2F;&#x2F; 获取图片帧数据CVImageBufferRef imageBuffer &#x3D; CMSampleBufferGetImageBuffer(sampleBuffer);CIImage *ciImage &#x3D; [CIImage imageWithCVImageBuffer:imageBuffer];UIImage *image &#x3D; [UIImage imageWithCIImage:ciImage];dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image &#x3D; image;&#125;);需要注意的是：代理方法中的所有动作所在队列都是在异步串行队列中，所以更新UI的操作需要回到主队列中进行！！ 但是此时会发现，画面是向左旋转了90度，因为默认采集的视频是横屏的，需要我们进一步做调整。以下步骤添加在[session startRunning];之前即可，但是一定要在添加了 input 和 output之后～123456&#x2F;&#x2F; 获取输入与输出之间的连接AVCaptureConnection *connection &#x3D; [videoOutput connectionWithMediaType:AVMediaTypeVideo];&#x2F;&#x2F; 设置采集数据的方向connection.videoOrientation &#x3D; AVCaptureVideoOrientationPortrait;&#x2F;&#x2F; 设置镜像效果镜像connection.videoMirrored &#x3D; YES; DemoLXFAudioVideo","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://linxunfeng.top/tags/Objective-C/"}]},{"title":"iOS - 采集音视频及写入文件","slug":"iOS-采集音视频及写入文件","date":"2017-09-26T11:50:32.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/26/iOS-采集音视频及写入文件/","link":"","permalink":"http://linxunfeng.top/2017/09/26/iOS-%E9%87%87%E9%9B%86%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8F%8A%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/","excerpt":"音视频采集包括两部分：视频采集和音频采集。在iOS中可以同步采集视频与音频，通过系统框架AVFoundation，可以帮助我们采集音频与视频，对于视频还可以进行切换前后摄像头，最终我们将录制好的视频写入沙盒中 +","text":"音视频采集包括两部分：视频采集和音频采集。在iOS中可以同步采集视频与音频，通过系统框架AVFoundation，可以帮助我们采集音频与视频，对于视频还可以进行切换前后摄像头，最终我们将录制好的视频写入沙盒中 + \b音视频采集包括两部分：视频采集和音频采集。在iOS中可以同步采集视频与音频，通过系统框架AVFoundation，可以帮助我们采集音频与视频，对于视频还可以进行切换前后摄像头，最终我们将录制好的视频写入沙盒中 音视频数据的采集与展示一、初始化视频的输入与输出12345678// 懒加载一个session，所有的操作都需要session来执行fileprivate lazy var session: AVCaptureSession = AVCaptureSession()// 保存\b视频输出fileprivate var videoOutput: AVCaptureVideoDataOutput?// 保存视频输入fileprivate var videoInput: AVCaptureDeviceInput?// 保存预览图层fileprivate var previewLayer: AVCaptureVideoPreviewLayer? 设置视频输入源与输出源12345678910111213// 设置视频输入源guard let devices = AVCaptureDevice.devices() as? [AVCaptureDevice] else &#123; return &#125;// 获取我们的前置摄像头(后置为.back)guard let device = devices.filter(&#123; $0.position == .front &#125;).first else &#123; return &#125;guard let input = try? AVCaptureDeviceInput(device: device) else &#123; return &#125;self.videoInput = input// 设置视频输出源let output = AVCaptureVideoDataOutput()let queue = DispatchQueue.global()// 设置代理，并在代理中获取采集到的数据，需要遵守 AVCaptureVideoDataOutputSampleBufferDelegateoutput.setSampleBufferDelegate(self, queue: queue)self.videoOutput = output设置音频的输入源与输出源123456789// 设置音频的输入源guard let device = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeAudio) else &#123; return &#125;guard let input = try? AVCaptureDeviceInput(device: device) else &#123;return&#125;// 设置音频输出源let output = AVCaptureAudioDataOutput()let queue = DispatchQueue.global()// 需要遵守 AVCaptureAudioDataOutputSampleBufferDelegateoutput.setSampleBufferDelegate(self, queue: queue)添加音频与视频的输入与输出到session中，但是每次添加之前需要先判断是否可以添加 123456789101112// 添加输入与输出// 注意：每次对session进行设置之前都需要调用session的【beginConfiguration】方法// 来告诉系统你现在要开始进行配置，结束配置后再调用【commitConfiguration】方法来提交配置session.beginConfiguration()if session.canAddInput(input) &#123; session.addInput(input)&#125;if session.canAddOutput(output) &#123; session.addOutput(output)&#125;session.commitConfiguration() 二、实现音视频的采集代理音视频虽然需要遵守的代理名称不一样，但是需要实现的方法是一致的，所以要拿到音频或者视频就得先进行判断，需要用到AVCaptureOutput的这个方法12345&#x2F;&#x2F; This convenience method returns the first AVCaptureConnection in the receiver&#39;s&#x2F;&#x2F; connections array that has an AVCaptureInputPort of the specified mediaType. If &#x2F;&#x2F; no connection with the specified mediaType is found, nil is returned.open func connection(withMediaType mediaType: String!) -&gt; AVCaptureConnection!123456789extension ViewController: AVCaptureVideoDataOutputSampleBufferDelegate, AVCaptureAudioDataOutputSampleBufferDelegate &#123; func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputSampleBuffer sampleBuffer: CMSampleBuffer!, from connection: AVCaptureConnection!) &#123; if videoOutput?.connection(withMediaType: AVMediaTypeVideo) == connection &#123; print(\"视频数据\") &#125; else &#123; print(\"音频数据\") &#125; &#125;&#125; 三、初始化一个预览图层用来显示采集到的视频（非采集所必须的步骤）1234567// 创建预览图层guard let previewLayer = AVCaptureVideoPreviewLayer(session: session) else &#123;return&#125;previewLayer.frame = view.bounds// 将图层添加到控制器的view的layer中view.layer.insertSublayer(previewLayer, at: 0)self.previewLayer = previewLayer 现在基本功能都有了，如果想要开始采集音视频只需要调用1234// 开始录制session.startRunning()// 结束录制session.stopRunning() 切换镜头其实就是换掉当前的视频输入法制，这里的过程跟上面的设置输入源一样。123456789101112131415161718// 1.取出之前镜头的方向guard let videoInput = videoInput else &#123; return &#125;let position: AVCaptureDevicePosition = videoInput.device.position == .front ? .back : .frontguard let devices = AVCaptureDevice.devices() as? [AVCaptureDevice] else &#123; return &#125;guard let device = devices.filter(&#123; $0.position == position &#125;).first else &#123; return &#125;guard let newInput = try? AVCaptureDeviceInput(device: device) else &#123; return &#125;// 2.移除之前的input，添加新的inputsession.beginConfiguration()session.removeInput(videoInput)if session.canAddInput(newInput) &#123; session.addInput(newInput)&#125;session.commitConfiguration()// 3.保存最新的inputself.videoInput = newInput 录制视频写入文件1fileprivate var movieOutput: AVCaptureMovieFileOutput? 在开始采集音视频的时候就要开始写入文件 123456789101112131415161718// 开始写入文件 // 1、创建写入文件的输出let fileOutput = AVCaptureMovieFileOutput()self.movieOutput = fileOutput // 保存起来，用于停止写入文件// 设置类型，不然报错(这两句很重要)let connection = fileOutput.connection(withMediaType: AVMediaTypeVideo)connection?.automaticallyAdjustsVideoMirroring = trueif session.canAddOutput(fileOutput) &#123; session.addOutput(fileOutput)&#125;// 2、直接开始写入文件let filePath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first! + \"/abc.mp4\"let fileUrl = URL(fileURLWithPath: filePath)fileOutput.startRecording(toOutputFileURL: fileUrl, recordingDelegate: self) 在停止采集音视频的时候停止写入文件 12&#x2F;&#x2F; 停止写入文件movieOutput?.stopRecording() 详情请看 DEMO","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS - LXFDrawBoard 多功能小画板","slug":"iOS-LXFDrawBoard-多功能小画板","date":"2017-09-25T18:38:12.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/25/iOS-LXFDrawBoard-多功能小画板/","link":"","permalink":"http://linxunfeng.top/2017/09/25/iOS-LXFDrawBoard-%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%B0%8F%E7%94%BB%E6%9D%BF/","excerpt":"将LXFDrawBoard拖入项目中，导入头文件LXFDrawBoard.h，需要什么笔刷可以在Brush文件夹中找到即可使用，具体使用方法可以参考Demo+","text":"将LXFDrawBoard拖入项目中，导入头文件LXFDrawBoard.h，需要什么笔刷可以在Brush文件夹中找到即可使用，具体使用方法可以参考Demo+ LXFDrawBoard多功能小画板 GitHub: Demo Usage 将LXFDrawBoard拖入项目中，导入头文件LXFDrawBoard.h，需要什么笔刷可以在Brush文件夹中找到即可使用，具体使用方法可以参考Demo LXFDrawBoardDelegate 返回需要添加的描述 1- (NSString *)LXFDrawBoard:(LXFDrawBoard *)drawBoard textForDescLabel:(UILabel *)descLabel; 当添加或修改描述时调用 1- (void)LXFDrawBoard:(LXFDrawBoard *)drawBoard clickDescLabel:(UILabel *)descLabel; 笔刷2017–09-25 更新橡皮擦 LXFEraserBrush 铅笔 LXFPencilBrush 箭头 LXFArrowBrush 直线 LXFLineBrush 文本 LXFTextBrush 矩形 LXFRectangleBrush 马赛克 LXFMosaicBrush 撤销与反撤销","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://linxunfeng.top/tags/Objective-C/"},{"name":"iOS项目","slug":"iOS项目","permalink":"http://linxunfeng.top/tags/iOS%E9%A1%B9%E7%9B%AE/"}]},{"title":"iOS-RxSwift项目实战记录","slug":"iOS-RxSwift-项目实战记录","date":"2017-09-12T10:02:27.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-RxSwift-项目实战记录/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-RxSwift-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/","excerpt":"最近刚刚把接手的OC项目搞定，经过深思熟虑后，本人决定下个项目起就使用Swift(学了这么久的Swift还没真正用到实际项目里。。。)，而恰巧RxSwift已经出来有一些时间了，语法也基本上稳定，遂只身前来试探试探这RxSwift，接着就做了个小Demo，有兴趣的同学可以瞧一瞧~ +","text":"最近刚刚把接手的OC项目搞定，经过深思熟虑后，本人决定下个项目起就使用Swift(学了这么久的Swift还没真正用到实际项目里。。。)，而恰巧RxSwift已经出来有一些时间了，语法也基本上稳定，遂只身前来试探试探这RxSwift，接着就做了个小Demo，有兴趣的同学可以瞧一瞧~ + 最近刚刚把接手的OC项目搞定，经过深思熟虑后，本人决定下个项目起就使用Swift(学了这么久的Swift还没真正用到实际项目里。。。)，而恰巧RxSwift已经出来有一些时间了，语法也基本上稳定，遂只身前来试探试探这RxSwift，接着就做了个小Demo，有兴趣的同学可以瞧一瞧~ 结构1234567891011121314151617.├── Controller│ └── LXFViewController.swift &#x2F;&#x2F; 主视图控制器├── Extension│ └── Response+ObjectMapper.swift &#x2F;&#x2F; Response分类，Moya请求完进行Json转模型或模型数组├── Model│ └── LXFModel.swift &#x2F;&#x2F; 模型├── Protocol│ └── LXFViewModelType.swift &#x2F;&#x2F; 定义了模型协议├── Tool│ ├── LXFNetworkTool.swift &#x2F;&#x2F; 封装Moya请求│ └── LXFProgressHUD.swift &#x2F;&#x2F; 封装的HUD├── View│ ├── LXFViewCell.swift &#x2F;&#x2F; 自定义cell│ └── LXFViewCell.xib &#x2F;&#x2F; cell的xib文件└── ViewModel └── LXFViewModel.swift &#x2F;&#x2F; 视图模型 第三方库123456789101112RxSwift &#x2F;&#x2F; 想玩RxSwift的必备库RxCocoa &#x2F;&#x2F; 对 UIKit Foundation 进行 Rx 化NSObject+Rx &#x2F;&#x2F; 为我们提供 rx_disposeBag Moya&#x2F;RxSwift &#x2F;&#x2F; 为RxSwift专用提供，对Alamofire进行封装的一个网络请求库ObjectMapper &#x2F;&#x2F; Json转模型之必备良品RxDataSources &#x2F;&#x2F; 帮助我们优雅的使用tableView的数据源方法Then &#x2F;&#x2F; 提供快速初始化的语法糖Kingfisher &#x2F;&#x2F; 图片加载库SnapKit &#x2F;&#x2F; 视图约束库Reusable &#x2F;&#x2F; 帮助我们优雅的使用自定义cell和view,不再出现OptionalMJRefresh &#x2F;&#x2F; 上拉加载、下拉刷新的库SVProgressHUD &#x2F;&#x2F; 简单易用的HUD 敲黑板Moya的使用Moya是基于Alamofire的网络请求库，这里我使用了Moya/Swift，它在Moya的基础上添加了对RxSwift的接口支持。接下来我们来说下Moya的使用 一、创建一个枚举，用来存放请求类型，这里我顺便设置相应的路径，等下统一取出来直接赋值即可123456789enum LXFNetworkTool &#123; enum LXFNetworkCategory: String &#123; case all = \"all\" case android = \"Android\" case ios = \"iOS\" case welfare = \"福利\" &#125; case data(type: LXFNetworkCategory, size:Int, index:Int)&#125;二、为这个枚举写一个扩展，并遵循塄 TargetType，这个协议的Moya这个库规定的协议，可以按住Commond键+单击左键进入相应的文件进行查看1234567891011121314151617181920212223242526272829303132333435363738394041424344extension LXFNetworkTool: TargetType &#123; /// baseURL 统一基本的URL var baseURL: URL &#123; return URL(string: \"http://gank.io/api/data/\")! &#125; /// path字段会追加至baseURL后面 var path: String &#123; switch self &#123; case .data(let type, let size, let index): return \"\\(type.rawValue)/\\(size)/\\(index)\" &#125; &#125; /// HTTP的请求方式 var method: Moya.Method &#123; return .get &#125; /// 请求参数(会在请求时进行编码) var parameters: [String: Any]? &#123; return nil &#125; /// 参数编码方式(这里使用URL的默认方式) var parameterEncoding: ParameterEncoding &#123; return URLEncoding.default &#125; /// 这里用于单元测试，不需要的就像我一样随便写写 var sampleData: Data &#123; return \"LinXunFeng\".data(using: .utf8)! &#125; /// 将要被执行的任务(请求：request 下载：upload 上传：download) var task: Task &#123; return .request &#125; /// 是否执行Alamofire验证，默认值为false var validate: Bool &#123; return false &#125;&#125;三、定义一个全局变量用于整个项目的网络请求1let lxfNetTool = RxMoyaProvider&lt;LXFNetworkTool&gt;()至此，我们就可以使用这个全局变量来请求数据了 RxDataSources如果你想用传统的方式也行，不过这就失去了使用RxSwift的意义。好吧，我们接下来说说如何优雅的来实现tableView的数据源。其实RxDataSources官网上已经有很明确的使用说明，不过我还是总结一下整个过程吧。 概念点RxDataSources是以section来做为数据结构来传输，这点很重要，可能很多同学会比较疑惑这句话吧，我在此举个例子，在传统的数据源实现的方法中有一个numberOfSection，我们在很多情况下只需要一个section，所以这个方法可实现，也可以不实现，默认返回的就是1，这给我们带来的一个迷惑点：【tableView是由row来组成的】，不知道在坐的各位中有没有是这么想的呢？？有的话那从今天开始就要认清楚这一点，【tableView其实是由section组成的】，所以在使用RxDataSources的过程中，即使你的setion只有一个，那你也得返回一个section的数组出去！！！ 一、自定义Section在我们自定义的Model中创建一个Section的结构体，并且创建一个扩展，遵循SectionModelType协议，实现相应的协议方法。约定俗成的写法呢请参考如下方式12345678910111213141516171819LXFModel.swiftstruct LXFSection &#123; // items就是rows var items: [Item] // 你也可以这里加你需要的东西，比如 headerView 的 title&#125;extension LXFSection: SectionModelType &#123; // 重定义 Item 的类型为 LXFModel typealias Item = LXFModel // 实现协议中的方式 init(original: LXFSection, items: [LXFSection.Item]) &#123; self = original self.items = items &#125;&#125;二、在控制器下创建一个数据源属性 以下代码均在 LXFViewController.swift 文件中12// 创建一个数据源属性，类型为自定义的Section类型let dataSource = RxTableViewSectionedReloadDataSource&lt;LXFSection&gt;()使用数据源属性绑定我们的cell12345678910// 绑定celldataSource.configureCell = &#123; ds, tv, ip, item in // 这个地方使用了Reusable这个库，在LXFViewCell中遵守了相应的协议 // 使其方便转换cell为非可选型的相应的cell类型 let cell = tv.dequeueReusableCell(for: ip) as LXFViewCell cell.picView.kf.setImage(with: URL(string: item.url)) cell.descLabel.text = \"描述: \\(item.desc)\" cell.sourceLabel.text = \"来源: \\(item.source)\" return cell&#125;三、将sections序列绑定给我们的rows1output.sections.asDriver().drive(tableView.rx.items(dataSource:dataSource)).addDisposableTo(rx_disposeBag)大功告成，接下来说说section序列的产生 ViewModel的规范我们知道MVVM思想就是将原本在ViewController的视图显示逻辑、验证逻辑、网络请求等代码存放于ViewModel中，让我们手中的ViewController瘦身。这些逻辑由ViewModel负责，外界不需要关心，外界只需要结果，ViewModel也只需要将结果给到外界，基于此，我们定义了一个协议LXFViewModelType 一、创建一个LXFViewModelType.swift123456789LXFViewModelType.swift// associatedtype 关键字 用来声明一个类型的占位符作为协议定义的一部分protocol LXFViewModelType &#123; associatedtype Input associatedtype Output func transform(input: Input) -&gt; Output&#125;二、viewModel遵守LXFViewModelType协议 我们可以为XFViewModelType的Input和Output定义别名，以示区分，如：你这个viewModel的用于请求首页模块相关联的，则可以命名为：HomeInput 和 HomeOutput 我们可以丰富我们的 Input 和 Output 。可以看到我为Output添加了一个序列，类型为我们自定义的LXFSection数组，在Input里面添加了一个请求类型(即要请求什么数据，比如首页的数据) 我们通过 transform 方法将input携带的数据进行处理，生成了一个Output 注意： 以下代码为了方便阅读，进行了部分删减 12345678910111213141516171819202122232425262728293031323334353637383940LXFViewModel.swiftextension LXFViewModel: LXFViewModelType &#123; // 存放着解析完成的模型数组 let models = Variable&lt;[LXFModel]&gt;([]) // 为LXFViewModelType的Input和Output定义别名 typealias Input = LXFInput typealias Output = LXFOutput // 丰富我们的Input和Output struct LXFInput &#123; // 网络请求类型 let category: LXFNetworkTool.LXFNetworkCategory init(category: LXFNetworkTool.LXFNetworkCategory) &#123; self.category = category &#125; &#125; struct LXFOutput &#123; // tableView的sections数据 let sections: Driver&lt;[LXFSection]&gt; init(sections: Driver&lt;[LXFSection]&gt;) &#123; self.sections = sections &#125; &#125; func transform(input: LXFViewModel.LXFInput) -&gt; LXFViewModel.LXFOutput &#123; let sections = models.asObservable().map &#123; (models) -&gt; [LXFSection] in // 当models的值被改变时会调用，这是Variable的特性 return [LXFSection(items: models)] // 返回section数组 &#125;.asDriver(onErrorJustReturn: []) let output = LXFOutput(sections: sections) // 接下来的代码是网络请求，请结合项目查看，不然会不方便阅读和理解 &#125;&#125; 接着我们在ViewController中初始化我们的input，通过transform得到output，然后将我们output中的sections序列绑定tableView的items12345678LXFViewController.swift// 初始化inputlet vmInput = LXFViewModel.LXFInput(category: .welfare)// 通过transform得到outputlet vmOutput = viewModel.transform(input: vmInput)vmOutput.sections.asDriver().drive(tableView.rx.items(dataSource: dataSource)).addDisposableTo(rx_disposeBag) RxSwift中使用MJRefresh一、定义一个枚举LXFRefreshStatus，用于标志当前刷新状态12345678enum LXFRefreshStatus &#123; case none case beingHeaderRefresh case endHeaderRefresh case beingFooterRefresh case endFooterRefresh case noMoreData&#125;二、在LXFOutput添加一个refreshStatus序列，类型为LXFRefreshStatus12// 给外界订阅，告诉外界的tableView当前的刷新状态let refreshStatus = Variable&lt;LXFRefreshStatus&gt;(.none)我们在进行网络请求并得到结果之后，修改refreshStatus的value为相应的LXFRefreshStatus项 三、外界订阅output的refreshStatus 外界订阅output的refreshStatus，并且根据接收到的值进行相应的操作12345678910111213141516vmOutput.refreshStatus.asObservable().subscribe(onNext: &#123;[weak self] status in switch status &#123; case .beingHeaderRefresh: self?.tableView.mj_header.beginRefreshing() case .endHeaderRefresh: self?.tableView.mj_header.endRefreshing() case .beingFooterRefresh: self?.tableView.mj_footer.beginRefreshing() case .endFooterRefresh: self?.tableView.mj_footer.endRefreshing() case .noMoreData: self?.tableView.mj_footer.endRefreshingWithNoMoreData() default: break &#125;&#125;).addDisposableTo(rx_disposeBag)四、output提供一个requestCommond用于请求数据 PublishSubject 的特点：即可以作为Observable，也可以作为Observer，说白了就是可以发送信号，也可以订阅信号12// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）let requestCommond = PublishSubject&lt;Bool&gt;()在transform中，我们对生成的output的requestCommond进行订阅1234567891011121314output.requestCommond.subscribe(onNext: &#123;[unowned self] isReloadData in self.index = isReloadData ? 1 : self.index+1 lxfNetTool.request(.data(type: input.category, size: 10, index: self.index)).mapArray(LXFModel.self).subscribe(&#123; [weak self] (event) in switch event &#123; case let .next(modelArr): self?.models.value = isReloadData ? modelArr : (self?.models.value ?? []) + modelArr LXFProgressHUD.showSuccess(\"加载成功\") case let .error(error): LXFProgressHUD.showError(error.localizedDescription) case .completed: output.refreshStatus.value = isReloadData ? .endHeaderRefresh : .endFooterRefresh &#125; &#125;).addDisposableTo(self.rx_disposeBag)&#125;).addDisposableTo(rx_disposeBag)五、在ViewController中初始化刷新控件 为tableView设置刷新控件，并且在创建刷新控件的回调中使用output的requestCommond发射信号123456tableView.mj_header = MJRefreshNormalHeader(refreshingBlock: &#123; vmOutput.requestCommond.onNext(true)&#125;)tableView.mj_footer = MJRefreshAutoNormalFooter(refreshingBlock: &#123; vmOutput.requestCommond.onNext(false)&#125;)总结流程： ViewController已经拿到output，当下拉加载数据的时候，使用output的requestCommond发射信息，告诉viewModel我们要加载数据 viewModel请求数据，在处理完json转模型或模型数组后修改models，当models的值被修改的时候会发信号给sections，sections在ViewController已经绑定到tableView的items了，所以此时tableView的数据会被更新。接着我们根据请求结果，修改output的refreshStatus属性的值 当output的refreshStatus属性的值改变后，会发射信号，由于外界之前已经订阅了output的refreshStatus，此时就会根据refreshStatus的新值来处理刷新控件的状态 好了，附上RxSwiftDemo。完结撒花","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"},{"name":"RxSwift","slug":"RxSwift","permalink":"http://linxunfeng.top/tags/RxSwift/"}]},{"title":"Ubuntu安装nginx来搭建推流服务器","slug":"Ubuntu-安装nginx-来搭建推流服务器","date":"2017-09-12T09:54:14.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/Ubuntu-安装nginx-来搭建推流服务器/","link":"","permalink":"http://linxunfeng.top/2017/09/12/Ubuntu-%E5%AE%89%E8%A3%85nginx-%E6%9D%A5%E6%90%AD%E5%BB%BA%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"如果安装命令回车之后出现如下信息，请参考【Ubuntu “无法获得锁”解决方案】解决，但是我亲测对我没用，直接重启搞定 +","text":"如果安装命令回车之后出现如下信息，请参考【Ubuntu “无法获得锁”解决方案】解决，但是我亲测对我没用，直接重启搞定 + 安装nginx安装两个依赖库12sudo apt-get install autoconf automakesudo apt-get install libpcre3 libpcre3-dev安装zlib库12sudo apt-get install opensslsudo apt-get install libssl-dev如果安装命令回车之后出现如下信息，请参考【Ubuntu “无法获得锁”解决方案】解决，但是我亲测对我没用，直接重启搞定12E: 无法获得锁 &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open (11: 资源暂时不可用)E: 无法锁定管理目录(&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;)，是否有其他进程正占用它？ 进入家目录，新建一个文件夹，这里以lxf为例12cd ~mkdir lxf 下载所需源码1234// 下载nginx-rtmp源码wget https://github.com/arut/nginx-rtmp-module/archive/master.zip// 修改压缩包的名字mv master.zip module.zip 12// 下载nginxwget https://github.com/nginx/nginx/archive/master.zip 12// 下载nginx的依赖pcre源码wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz 下载完成之后使用unzip命令进行解压123unzip master.zip unzip module.ziptar -zxvf pcre-8.39.tar.gz配置编译文件，准备编译安装12// 先进入nginx-master目录cd nginx-master/在nginx-master目录下有一个auto文件夹，里面有一个名为configure的配置文件，我们先来\b通过它进行一些配置123// prefix:指定安装目录// add-module:指定模块文件夹auto/configure --prefix=/usr/local/nginx --with-pcre=../pcre-8.39 --with-http_ssl_module --with-http_v2_module --with-http_flv_module --with-http_mp4_module --add-module=../nginx-rtmp-module-master/配置好之后会多出一个Makefile文件(一种配置文件，定义了一系列的规则来指定编译操作)与objs文件夹 1234// 编译make// 安装sudo make install 当你make后，看到则\b代表编译成功再执行【sudo make install】，看到这个则代表安装完成 现在我们去测试一下12 cd /usr/local/nginx/sbin/sudo ./nginx -t看到successful说明配置文件正确！，如果是failed的话看看你是不是没加sudo 启动nginx服务器1sudo ./nginx默认端口是80，所以直接到浏览器中直接敲入本地地址 127.0.0.1，显示【Welcome to nginx!】就代表nginx已经成功安装 配置nginx创建推流存放文件夹123&#x2F;&#x2F; 为里以 &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;hls 为例cd &#x2F;usr&#x2F;localsudo mkdir -p var&#x2F;www&#x2F;hls进入nginx的conf目录，使用vim编辑nginx.conf文件12cd /usr/local/nginx/confsudo vim nginx.conf配置Nginx，支持http协议拉流12345678location /hls &#123; types &#123; application/vnd.apple.mpegurl m3u8; video/mp2t ts; &#125; root /usr/local/var/www; add_header Cache-Control no-cache;&#125; 配置Nginx，支持rtmp协议推流123456789101112131415rtmp &#123; server &#123; listen 1935; application rtmplive &#123; live on; max_connections 1024; &#125; application hls&#123; live on; hls on; hls_path /usr/local/var/www/hls; hls_fragment 1s; &#125; &#125;&#125; 重启nginx服务器12cd /usr/local/nginx/sbin/sudo ./nginx -s reload 如果执行【sudo ./nginx -s reload】出现下面这个问题1nginx: [error] open() \"/usr/local/nginx/logs/nginx.pid\" failed (2: No such file or directory)就使用nginx -c的参数指定nginx.conf文件的位置，接着再reload一下就好了1sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 我Ubuntu地址为192.168.123.191 推流至RTMP到服务器 rtmp://192.168.123.191:1935/rtmplive/lxf1ffmpeg -re -i 异形.契约.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp:&#x2F;&#x2F;192.168.123.191:1935&#x2F;rtmplive&#x2F;lxf推流至HLS到服务器 http://192.168.123.191/hls/lxf.m3u81ffmpeg -re -i 异形.契约.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp:&#x2F;&#x2F;192.168.123.191:1935&#x2F;hls&#x2F;lxf 如果出现如下错误说明你的电脑没安装ffmpeg1-bash: ffmpeg: command not found使用Homebrew来安装FFmpeg1234// 安装Homebrewruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"// 安装FFmpegbrew install ffmpeg 开始推流，终端上就开始不断的刷新推流信息 我们可以用电脑上的VLC这个软件来测试是否推流成功 OK，rmtp打开正常，hls就不演示了，一样的","categories":[{"name":"Linux","slug":"Linux","permalink":"http://linxunfeng.top/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://linxunfeng.top/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"http://linxunfeng.top/tags/Linux/"}]},{"title":"iOS-给高仿微信添加直播聊天功能","slug":"iOS-给高仿微信添加直播聊天功能","date":"2017-09-12T09:47:36.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-给高仿微信添加直播聊天功能/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-%E7%BB%99%E9%AB%98%E4%BB%BF%E5%BE%AE%E4%BF%A1%E6%B7%BB%E5%8A%A0%E7%9B%B4%E6%92%AD%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD/","excerpt":"抽空给之前做的开源项目【\b高仿微信】添加直播功能，由于时间有限，做得不是很完美，有空再去完善吧，能用就好~~ +","text":"抽空给之前做的开源项目【\b高仿微信】添加直播功能，由于时间有限，做得不是很完美，有空再去完善吧，能用就好~~ + 抽空给之前做的开源项目【\b高仿微信】添加直播功能，由于时间有限，做得不是很完美，有空再去完善吧，能用就好~~ 在此提供存放于百度云的完整项目【\b高仿微信】- 百度云希望各位能在我的GitHub上献出一个宝贵的Star 【\b高仿微信】- GitHub谢谢 注意：直播功能的使用（对方需要先进入到对应的聊天界面） 两个测试账号： lxf lqr 密码都是123456 推流首先第一件事\b当然就是搭建一个推流服务器，\b这里请跳转参考我之前写好的文章吧【Ubuntu安装nginx来搭建推流服务器】，这里我的服务器的ip地址是：192.168.123.191 APP上推流我使用的是第三方的库 LFLiveKit，这个第三方库已经帮我们处理了很多事情，而且还包括美颜~~。当然，有时间我们还是要去了解一下底层的东西，这里就先不赘述，过几天抽空再做总结。 关键代码如下 123456789// 初始化配置let audioConfiguration = LFLiveAudioConfiguration.default()let videoConfiguration = LFLiveVideoConfiguration.defaultConfiguration(for: .low2, outputImageOrientation: .portrait)// 初始化sessionlet session = LFLiveSession(audioConfiguration: audioConfiguration, videoConfiguration: videoConfiguration)// 设置代理// session?.delegate = self// 设置展示的Viewsession?.preView = self.view 12345let stream = LFLiveStreamInfo()stream.url = \"rtmp://192.168.123.191:1935/rtmplive/lxf\"; // 服务器地址session.startLive(stream)// 开始推流session.running = true 拉流这里我使用的是B站的开源库 ijkplayer 为了方便可以用这个 编译好的B站开源库 需要注意的是：IJKPlayer默认使用的是软解码(FFMpeng)，如果需要使用硬解码需要我们进行相应的设置123456789101112// 设置\"videotoolbox\"的值为0为软解码(默认)，设置为1则是硬解码let options = IJKFFOptions.byDefault()options?.setOptionIntValue(1, forKey: \"videotoolbox\", of: kIJKFFOptionCategoryPlayer)let ijkPlayer = IJKFFMoviePlayerController(contentURLString: \"rtmp://192.168.123.191:1935/rtmplive/lxf\", with: options)// 需保存起来self.ijkPlayer = ijkPlayerijkPlayer?.view.frame = view.boundsview.addSubview(ijkPlayer!.view)// 准备播放，当视频准备好的时候会自动进行播放ijkPlayer?.prepareToPlay() 将IJKPlayer打包从B站的gitHub上下载的 ijkplayer 需要手动编译出来，跟着说明走就可以了，这里就不赘述咯，接下来我们将它打包，方便使用 如果你不跟着说明走的话会提示找不到 avformat.h 这个头文件 这时你需要在终端cd到ijkplayer这个目录，然后执行 init-ios.sh文件，如图 然后经过一段漫长的时间之后，在ios目录下就多出了这些ffmpeg相关的目录 这个操作是在下载ffmpeg源码，然缺失的avformat.h就在里面 打开项目 IJKMediaPlayer 设置为 release，这样打出来的包会小些 选择真机和模拟器，各Command+B编译一次 右击，Show in Finder 如图，就有两个文件夹，里面存放着的就是我们编译出来的库 可以使用如下命令查看信息1lipo -info IJKMediaFramework默认模拟器编译出来的包是不支持i386，如果希望支持的话进入项目的 Build Settings，将 Build Active Architecture Only 设置为NO 好，现在对编译出来的包进行合并，这样就即支持真机，也支持模拟器1234// 格式// lipo -create path1 path2 -output frameNamelipo -create Release-iphoneos/IJKMediaFramework.framework/IJKMediaFramework Release-iphonesimulator/IJKMediaFramework.framework/IJKMediaFramework -output IJKMediaFramework 将合并出来的IJKMediaFramework替换 IJKMediaFramework.framework中的IJKMediaFramework，最后将替换好的 IJKMediaFramework.framework 拖入到项目中使用即可。 最后，附上编译好的IJKMediaFramework链接:https://pan.baidu.com/s/1eRYlJ7W 密码:9iaw","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS-揭露Block的内部实现原理","slug":"iOS-揭露Block的内部实现原理","date":"2017-09-12T09:42:47.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-揭露Block的内部实现原理/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-%E6%8F%AD%E9%9C%B2Block%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"想必大家对block都很熟悉了，\b虽然都会用，但是你真的知道它的原理吗？比如为什么要加上__block，这个修饰符到底有什么用？不加会有什么后果？block又是如何实现的等等。。。该篇文章就为大家揭晓关于Block的实现原理~ +","text":"想必大家对block都很熟悉了，\b虽然都会用，但是你真的知道它的原理吗？比如为什么要加上__block，这个修饰符到底有什么用？不加会有什么后果？block又是如何实现的等等。。。该篇文章就为大家揭晓关于Block的实现原理~ + 想必大家对block都很熟悉了，\b虽然都会用，但是你真的知道它的原理吗？比如为什么要加上__block，这个修饰符到底有什么用？不加会有什么后果？block又是如何实现的等等。。。该篇文章就为大家揭晓关于Block的实现原理~ 抛砖引玉先给出问题，大家思考下结果吧，如果分别调用以下两个方法，结果如何？123456789void blockFunc1()&#123; int num = 100; void (^block)() = ^&#123; NSLog(@\"num equal %d\", num); &#125;; num = 200; block();&#125;123456789void blockFunc2()&#123; __block int num = 100; void (^block)() = ^&#123; NSLog(@\"num equal %d\", num); &#125;; num = 200; block();&#125;答案是12blockFunc1 : num equal 100blockFunc2 : num equal 200是不是有人答错了？再来两个函数。这两个的结果与blockFunc2一样，打印出来的 num 为 20012345678910// 全局变量int num = 100;void blockFunc3()&#123; void (^block)() = ^&#123; NSLog(@\"num equal %d\", num); &#125;; num = 200; block();&#125;123456789void blockFunc4()&#123; static int num = 100; void (^block)() = ^&#123; NSLog(@\"num equal %d\", num); &#125;; num = 200; block();&#125; 疑问：我们发现num做为局部变量时加上 _ _block 修饰符、num做为全局变量以及num为静态局部变量时在block中输出结果是一样的，皆为被修改之后的值，而做为局部变量并且未加上__block的num在block中输出的值却还是未赋值之前的值。这是为什么呢？探索这个问题我们就需要看看底层结构是如何实现的了 探索内部原理Objective-C是一个全动态语言，它的一切都是基于runtime实现的！在运行时会将OC转换成C，我们可以利用这个来查看关于block在内部是如何实现的新建一个Command Line Tool项目，将以上代码放入main.m中，如图 这里我们打开终端，cd到项目目录下，然后将用下面的命令将OC重写为C1clang -rewrite-objc main.m 这时我们可以发现当前目录下多了一个main.cpp文件，打开它并滚到最下面 这里我们可以看到blockFunc1的C语言实现方法 1234567void blockFunc1()&#123; int num = 100; void (*block)() = ((void (*)())&amp;__blockFunc1_block_impl_0((void *)__blockFunc1_block_func_0, &amp;__blockFunc1_block_desc_0_DATA, num)); num = 200; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);&#125; 去掉类型转换123456789void blockFunc1()&#123; int num = 100; // *************************重点句*********************** void (*block)() = &amp;__blockFunc1_block_impl_0(__blockFunc1_block_func_0, &amp;__blockFunc1_block_desc_0_DATA, num)); // ***************************************************** num = 200; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);&#125;这里我们可以看到 block实际上是指向结构体的指针 该结构体为 我们来看下带__block的blockFunc2 在 blockFunc1 中，block指向了一个名为blockFunc1_block_impl_0的结构体，并且在初始化时输入了三个参数(blockFunc1_block_impl_0最后的flags有默认参数，所以可以不用传参)，第三个参数就是我们写的num，与blockFunc2相比较，这里的num并没有带*号，所以说在这里它只是传值而非传址，而下面的【num = 200;】也就没什么卵用了。这就是blockFunc2、blockFunc3与blockFunc4为什么能打印出num改变后的值，而blockFunc1不行的原因。 在这里我们也可以看出： 编译器会将block的内部代码生成对应的函数 SO 我们总结下，block在内部会作为一个指向结构体的指针，当调用block的时候其实就是根据block对\b应的指针找到相应的函数，进而进行调用，并传入自身 __block的实现我们再来看看 _ block， _block也被转换成了结构体，并含有5个变量1234567struct __Block_byref_num_0 &#123; void *__isa; &#x2F;&#x2F; isa指针__Block_byref_num_0 *__forwarding; &#x2F;&#x2F; 实例本身 int __flags; int __size; int num; &#x2F;&#x2F; 我们的num值&#125;; 图片对应着blockFunc2中的 1__block int num &#x3D; 100; 当创建num并用block修饰的时候，会初始化这五个变量当我们执行1num &#x3D; 200;对应着1(num.__forwarding-&gt;num) &#x3D; 200;上面刚刚提到过 _ _forwarding是实例本身，\b即类型结构体Block_byref_num_0的&amp;num，再找到对应的num变量，将其原来的100修改为200~~ 到此，关于Block内部实现的揭晓也就到此结束了，希望本文能让你对block有更深的理解，感谢你耐心的阅读！","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://linxunfeng.top/tags/Objective-C/"}]},{"title":"iOS-Swift面向协议编程（二）","slug":"iOS-Swift-面向协议编程（二）","date":"2017-09-12T09:32:49.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-Swift-面向协议编程（二）/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"上一篇文章iOS - Swift 面向协议编程（一） 已经对Swift的面向协议编程做了介绍，接下来该篇文章将使用面向协议开发(POP)来做下实际的应用 +","text":"上一篇文章iOS - Swift 面向协议编程（一） 已经对Swift的面向协议编程做了介绍，接下来该篇文章将使用面向协议开发(POP)来做下实际的应用 + 上一篇文章iOS - Swift 面向协议编程（一） 已经对Swift的面向协议编程做了介绍，接下来该篇文章将使用面向协议开发(POP)来做下实际的应用 在实际开发中，自定义View基本上是必须的，相信这对我们来说都是比较简单，不过我们还是来回顾一下下~ 面向对象开发1 新建一个UIView的FirstTypeView 2 创建一个View的xib文件3 设置xib对应的class进行绑定 4 在FirstTypeView.swift 中实现一个类方法，方便我们外部用xib来初始化FirstTypeView1234567891011import UIKitclass FirstTypeView: UIView &#123; &#125;extension FirstTypeView &#123; class func loadFromNib() -&gt; FirstTypeView &#123; return Bundle.main.loadNibNamed(\"\\(self)\", owner: nil, options: nil)?.first as! FirstTypeView &#125;&#125;在外部只要调用FirstTypeView的loadFromNib方法就可以初始化一个View来使用了。好，现在又有一个类SecondTypeView，也是要求使用xib来初始化view。这时我们就会想，一样的加载xib的方法，那我们就把它抽取出来放到父类就可以了。这里的父类以BaseView.swift为例父类的主要实现代码12345extension BaseView &#123; class func loadFromNib() -&gt; BaseView &#123; return Bundle.main.loadNibNamed(\"\\(self)\", owner: nil, options: nil)?.first as! BaseView &#125;&#125;那我们的FirstTypeView和SecondTypeView只需要直接继承于BaseView就可以了，在其它地方初始化view也很方便12345let firstView &#x3D; FirstTypeView.loadFromNib()view.addSubview(firstView)let secondView &#x3D; SecondTypeView.loadFromNib()view.addSubview(secondView)好，现在FirstTypeView里声明了一个属性name，SecondTypeView声明的属性为age，假如我们现在要使用各自对应的属性，这时是直接点不出来的，需要先进行强转1234567let firstView = FirstTypeView.loadFromNib() as! FirstTypeViewfirstView.name = \"LXF\"view.addSubview(firstView)let secondView = SecondTypeView.loadFromNib() as! SecondTypeViewsecondView.age = 100view.addSubview(secondView) 但是这样觉得不是很方便，还需要进行强转，我们能不能在BaseView里面搞定它呢？如果是Swift 2.x 的话是可以的12345extension BaseView &#123; class func loadFromNib() -&gt; Self &#123; &#x2F;&#x2F; 注意这里是大写的S return Bundle.main.loadNibNamed(&quot;\\(self)&quot;, owner: nil, options: nil)?.first as! Self &#125;&#125;但是现在Swift 3.0已经不支持这种写法了，会报错。这个时候如果使用面向协议的开发就很方便了。 面向协议开发 将BaseView删除，FirstTypeView和SecondTypeView改回继承于UIView 1 新建一个Swift文件 Nibloadable.swift 2 实现协议方法 协议中不允许定义类方法，需改为静态方法1234567891011import UIKitprotocol Nibloadable &#123; &#125;extension Nibloadable &#123; static func loadFromNib() -&gt; Self &#123; return Bundle.main.loadNibNamed(&quot;\\(self)&quot;, owner: nil, options: nil)?.first as! Self &#125;&#125; 3 遵守协议123class SecondTypeView: UIView, Nibloadable &#123; var age: Int &#x3D; 10&#125; 这样就可以了，而且你在调用loadFromNib方法时可以发现，类型是对应上的 好了，面向协议开发的应用就\b记录到这里，希望能帮助到大家！ Demo","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS - Swift 面向协议编程（一）","slug":"iOS-Swift-面向协议编程（一）","date":"2017-09-12T09:30:29.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-Swift-面向协议编程（一）/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"传统的面向对象开发思维方式是将类中实现的相似方法抽取出来，接着放入一个Base类，然后继承于Base类后各个类即可找拥有相同的方法，不用再一个个手动实现。比如：一个Person类，一个Dog类，它们都拥有方法eat，那么就可以新建一个Animal类，将eat方法抽取出来放入其中，然后将Person类和Dog类都继承于Animal。但是，如果现在又有一个Robot类，也需要拥有eat方法，而此时也将其继承于Animal的话显然是不合理的，于是我们就需要转换思维，面向协议开发~ +","text":"传统的面向对象开发思维方式是将类中实现的相似方法抽取出来，接着放入一个Base类，然后继承于Base类后各个类即可找拥有相同的方法，不用再一个个手动实现。比如：一个Person类，一个Dog类，它们都拥有方法eat，那么就可以新建一个Animal类，将eat方法抽取出来放入其中，然后将Person类和Dog类都继承于Animal。但是，如果现在又有一个Robot类，也需要拥有eat方法，而此时也将其继承于Animal的话显然是不合理的，于是我们就需要转换思维，面向协议开发~ + OC无法做到面向协议开发，而Swift可以，因为Swift可以做到协议方法的具体实现，而OC不行 面向对象开发传统的面向对象开发思维方式是将类中实现的相似方法抽取出来，接着放入一个Base类，然后继承于Base类后各个类即可找拥有相同的方法，不用再一个个手动实现。比如：一个Person类，一个Dog类，它们都拥有方法eat，那么就可以新建一个Animal类，将eat方法抽取出来放入其中，然后将Person类和Dog类都继承于Animal。但是，如果现在又有一个Robot类，也需要拥有eat方法，而此时也将其继承于Animal的话显然是不合理的，于是我们就需要转换思维，面向协议开发~ 面向协议开发面向协议开发的核心是： 模块化（组件化） 我们先来回顾下协议的一般使用，新建一个Swift文件LXFProtocol.swift12345import Foundationprotocol LXFProtocol &#123; func eat()&#125;我们的Person类遵守协议LXFProtocol，需要我们实现协议中的方法，如：12345class Person: NSObject, LXFProtocol &#123; func eat() &#123; &#x2F;&#x2F; &#125;&#125;那我们每个类都这样做的话跟直接复制粘贴代码并没什么不同~~而开头已经提到一点： Swift可以做到协议方法的具体实现 \b那么现在，我们新建一个Swift文件Eatable.swift，以区分LXFProtocol.swiftEatable.swift中的代码实现如下：1234567891011import Foundationprotocol Eatable &#123; &#x2F;&#x2F; 可声明变量&#125;extension Eatable &#123; func eat() &#123; &#x2F;&#x2F; 实现具体的功能 &#125;&#125;有2个注意点 protocol中可以声明变量，\b方便在协议方法中使用 协议方法的具体实现需要在extension中来实现 使Dog类遵守Eatable123class Dog: NSObject, Eatable &#123;&#125;这样我们就可以在其它地方轻松调用dog的eat方法，Person类与Robot类也是如法炮制 至此，我们就可以通过面向协议的方式给类定制不同的功能，也就是模块化。可以发现Swift的面向协议编程跟c++的多继承很相似 约束现在的这个Eatable协议是可以被\b任意遵守的，如果我们\b有这么个需求，我们创建的协议只是被UIViewController遵守，那我们该怎么做呢？【当然，Eatable协议只能被UIViewController遵守很扯淡，这里只是举例，不要太在意咯~~】 在 extension 后面加上约束关键字【where】，并注明该协议只能被UIViewController这个类（包括子类）所遵守，而且此时我们还可以拿到遵守该协议的控制器的view 123456789101112&#x2F;&#x2F;import Foundationimport UIKitprotocol Eatable &#123; &#125;extension Eatable where Self : UIViewController &#123; func eat() &#123; view.backgroundColor &#x3D; UIColor.red &#125;&#125; Demo接下来以一个实际应用来巩固下吧 iOS - Swift 面向协议编程（二）","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS - Swift 高仿微信","slug":"iOS-Swift-高仿微信","date":"2017-09-12T09:29:00.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-Swift-高仿微信/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-Swift-%E9%AB%98%E4%BB%BF%E5%BE%AE%E4%BF%A1/","excerpt":"从2016年12月份开始做到 2017年2月16，虽说这个项目看起来不大，但是锻炼人的地方还真是很多的，微信通讯录联系人的按拼音排序，自定义表情键盘中遇到的分页滚动，微信聊天界面的图片显示、语音信息的动画等。挑战着各种各样的需求，本人也将遇到的问题的解决方案做了记录并整理了一下，希望能给iOS程序员同胞们带来帮助。目前基本的聊天已完成，实现了一部分个人信息的修改，功能我会尽快完善的！ +","text":"从2016年12月份开始做到 2017年2月16，虽说这个项目看起来不大，但是锻炼人的地方还真是很多的，微信通讯录联系人的按拼音排序，自定义表情键盘中遇到的分页滚动，微信聊天界面的图片显示、语音信息的动画等。挑战着各种各样的需求，本人也将遇到的问题的解决方案做了记录并整理了一下，希望能给iOS程序员同胞们带来帮助。目前基本的聊天已完成，实现了一部分个人信息的修改，功能我会尽快完善的！ + LXFWeChatSwift 3.0 高仿微信 两个测试账号： lxf lqr 密码都是123456 源码地址码云http://git.oschina.net/LinXunFeng/LXFWeChat GitHubhttps://github.com/LinXunFeng/LXFWeChat 在此提供存放于百度云的完整项目【\b高仿微信】- 百度云希望各位能在我的项目上献出一个宝贵的Star谢谢 从2016年12月份开始做到现在，虽说这个项目看起来不大，但是锻炼人的地方还真是很多的，微信通讯录联系人的按拼音排序，自定义表情键盘中遇到的分页滚动，微信聊天界面的图片显示、语音信息的动画等。挑战着各种各样的需求，本人也将遇到的问题的解决方案做了记录并整理了一下，希望能给iOS程序员同胞们带来帮助。目前基本的聊天已完成，实现了一部分个人信息的修改，功能我会尽快完善的！ 模仿微信的导航栏在navigationBar底部添加一个添加了渐变层的view1234567891011121314151617let blurBackView = UIView()blurBackView.frame = CGRect(x: 0, y: -20, width: kScreenW, height: 64)let gradintLayer = CAGradientLayer()gradintLayer.frame = CGRect(x: 0, y: 0, width: kScreenW, height: 64)gradintLayer.colors = [ UIColor.hexInt(0x040012).withAlphaComponent(0.76).cgColor, UIColor.hexInt(0x040012).withAlphaComponent(0.28).cgColor]gradintLayer.startPoint = CGPoint(x: 0, y: 0)gradintLayer.endPoint = CGPoint(x: 0, y: 1.0)blurBackView.layer.addSublayer(gradintLayer)blurBackView.isUserInteractionEnabled = falseblurBackView.alpha = 0.5// 设置导航栏样式navigationBar.barStyle = .blacknavigationBar.insertSubview(blurBackView, at: 0) 表情面板和更多面板遇到的问题总结了一下，可以参考下以下总结的文章 《iOS - Swift UICollectionView横向分页滚动，cell左右排版》 《iOS-Swift-UICollectionView横向分页的问题》 聊天界面《iOS-Swift 仿微信聊天图片显示》 《iOS-Swift-UITableView的scrollToRow的”坑”》 《iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗》 首页《iOS - Swift 仿微信小红点(无数字)》 目前完成的功能微信界面 显示右上角的菜单 显示最近联系人 最近联系人信息未读数的显示 通讯录界面 联系人的排序 联系人总数显示 发现界面 动态小红点的显示 购物选项的链接跳转 我界面 个人头像的上传与设置，及头像的保存 我的二维码界面的显示及二维码的保存 聊天界面 小视频的录制与发送 小视频的播放 聊天时间 图片的发送与显示 未发送成功的重发功能 语音的录制与发送 语音的播放动态效果 已知BUG 小视频和图片发送出去后不能立即更新显示缩略图 更换头像模拟器测试正常，真机无效。。 2017-07-24 更新抽空出来添加了一个简单的直播功能（对方需要先进入到对应的聊天界面）相关博文：iOS-给高仿微信添加直播聊天功能需要用到编译好的B站开源库ijkplayer ，由于打包好的文件太大，传不上来，所以需要各位去自己编译集成进去。 效果图动态图 静态图","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"},{"name":"iOS项目","slug":"iOS项目","permalink":"http://linxunfeng.top/tags/iOS%E9%A1%B9%E7%9B%AE/"}]},{"title":"iOS-ARC与MRC的单例设计模式","slug":"iOS-ARC与MRC的单例设计模式","date":"2017-09-12T09:25:47.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-ARC与MRC的单例设计模式/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-ARC%E4%B8%8EMRC%E7%9A%84%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"单例设计模式(Singleton) 就是保证某个类创建出来的对象从始到终只有一个的一种方案 +","text":"单例设计模式(Singleton) 就是保证某个类创建出来的对象从始到终只有一个的一种方案 + 单例设计模式(Singleton)\b定义就是保证某个类创建出来的对象从始到终只有一个的一种方案 作用 节省内存开销 保证整个程序中使用同一份资源 实现首先将我们的环境设置为非ARC环境，即MRC，如图 在MRC模式下，我们得自己手动释放资源，所以得重写一些与资源创建与释放相关的方法，以保证单例对象的唯一。 新建一个继承于NSObject的类 LXFFileTool，我直接上代码，并写上注释LXFFileTool.h123@interface LXFFileTool : NSObject+ (instancetype)sharedFileTool;@endLXFFileTool.m12345678910111213141516171819202122232425262728293031323334353637383940414243#import \"LXFFileTool.h\"@implementation LXFFileToolstatic LXFFileTool *_fileTools = nil;/** * alloc方法内部会调用allocWithZone: * @param zone 系统分配给app的内存 */+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; if (_fileTools == nil) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 安全(这个代码只会被调用一次) _fileTools = [super allocWithZone:zone]; &#125;); &#125; return _fileTools;&#125;- (oneway void)release &#123; // 在allocWithZone中使用了GCD令创建对象的代码只执行一次，如果_fileTools被释放则无法再创建 // 重写release方法，防止_fileTools被释放&#125;// 重写retain方法- (instancetype)retain &#123; return self;&#125;// 重写retainCount锁定引用计数- (NSUInteger)retainCount &#123; return 1;&#125;// 重写init方法，防止单例所拥有的属性值被重置// 让初始化的方法只能执行一次，自然属性值就没有机会被重置- (instancetype)init &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _fileTools = [super init]; // init会先调用alloc方法 &#125;); return _fileTools;&#125;// 仿造系统的单例创建方式，提供类方法+ (instancetype)sharedFileTool &#123; // 由于我们已经重写了init方法保证了单例对象的唯一了，所以这里直接调用init方法即可。 return [[self alloc] init];&#125;@end MRC下就是这样，我们的目的就是只能创建和初始化一次对象，不给机会释放，也不给机会重新初始化，从而保证了该对象的唯一。 那现在来看看ARC下是如何实现单例的吧。其实ARC下与MRC的区别就是ARC下我们不用自己再手动去释放资源了，从而使代码上大同小异，如下所示。123456789101112131415161718192021222324#import \"LXFFileTool.h\"@implementation LXFFileToolstatic LXFFileTool *_fileTools = nil;+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; if (_fileTools == nil) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _fileTools = [super allocWithZone:zone]; &#125;); &#125; return _fileTools;&#125;- (instancetype)init &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _fileTools = [super init]; &#125;); return _fileTools;&#125;+ (instancetype)sharedFileTool &#123; return [[self alloc] init];&#125; 批量创建单例 现在我们已经知道了ARC与MRC下分别是如何创建单例的了，但是如果我们一个项目里需要多个单例，那我们只能把代码复制粘贴再改改就完事吗？这未免也太麻烦了吧。那我们能不能做到快速且方便的创建单例对象呢？可以的，利用宏 首先先说下一些关于宏的知识吧 使用 #define 关键字来定义宏 宏定义只能是单行的，不能换行 那现在来讨论下一些疑惑吧，你说宏只能单行，可是创建单例的代码可是有很多行呀！还有我们如何做到自定义类方法名(就是 sharedXXX )？好，我们来介绍下宏下的两个特殊符号 宏的特殊符号 \b \b作用 \\ 用来转译换行符，即屏蔽换行符 ## 将两个相邻的标记(token)连接为一个单独的标记 想了解其它关于宏的预处理命令可以自行百度参考”C语言的预处理命令” 简单来说，\\用于取消换行，##用来连接，而我们就用##来实现自定义类方法名 创建一个头文件Singleton.h用来存放宏定义先来看看定义.h中 sharedXXX 是如何通过宏来定义的12// .h文件的实现#define SingletonH(methodName) + (instancetype)shared##methodName;现在回到LXFFileTool.h中，直接一行定义sharedFileTool这个类方法1234#import \"Singleton.h\"@interface LXFFileTool : NSObjectSingletonH(FileTool)@end我们只需要将方法名FileTool传入SingletonH()中就可以拼接为sharedFileTool 那现在再来看看定义.m中创建单例的方式，以ARC为例1234567891011121314151617181920212223#define SingletonM(methodName) \\static id _instance = nil; \\+ (instancetype)allocWithZone:(struct _NSZone *)zAone &#123; \\ if (_instance == nil) &#123; \\ static dispatch_once_t onceToken; \\ dispatch_once(&amp;onceToken, ^&#123; \\ _instance = [super allocWithZone:zone]; \\ &#125;); \\ &#125; \\ return _instance; \\&#125; \\\\- (instancetype)init &#123; \\ static dispatch_once_t onceToken; \\ dispatch_once(&amp;onceToken, ^&#123; \\ _instance = [super init]; \\ &#125;); \\ return _instance; \\&#125; \\\\+ (instancetype)shared##methodName &#123; \\ return [[self alloc] init]; \\&#125; 在每一个行后面加上(反斜杠)取消换行，使用##来拼接传入的方法名，但还有一点需要注意：最后一行不能加反斜杠 回到LXFFileTool.m中，\b一行实现创建单例1234#import \"LXFFileTool.h\"@implementation LXFFileToolSingletonM(FileTool)@end好，现在还有一个问题，就是如果我的项目中有个别文件是需要MRC环境的，那我该怎么办才能让创建单例也是如此简单呢？很简单，加个判断就好了，大致判断如下，详情看文章最后附上的Demo12345#if __has_feature(objc_arc) // ARC// 写上ARC下的定义代码#else // 非ARC// 写上MRC下的定义代码#endif 好了，现在用起来是不是方便多了？我们只要创建一个类，然后在.h文件中写SingletonH(XXX)，再在.m文件中写SingletonM(XXX)就可以实现单例了~ 指定环境顺便提下如何在MRC下指定某个类文件使用的环境为ARC如图，可以在 Build Phases -&gt; Compile Sources 中双击某个需要ARC环境的类文件，然后写上 1-fobjc-arc 如果是指定MRC，则写上1-fno-objc-arc Demo最后，附上Demo: LXFSingleton","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://linxunfeng.top/tags/Objective-C/"}]},{"title":"iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗","slug":"iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗","date":"2017-09-12T09:22:32.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-Swift-UIButton%E4%B8%ADImageView%E7%9A%84animationImages%E5%8A%A8%E7%94%BB%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E5%9B%BE%E6%A0%87%E5%8F%98%E6%9A%97/","excerpt":"查看官方文档的说明 当该属性设置为true时，按钮在高亮状态下，图片会绘制成高亮（\b前提是没有手动设置高亮图片）。并且该值的默认值为true所以我们也可以将属性adjustsImageWhenHighlighted设置为false，不让系统自动帮我们设置高亮状态下显示的图片即可。 +","text":"查看官方文档的说明 当该属性设置为true时，按钮在高亮状态下，图片会绘制成高亮（\b前提是没有手动设置高亮图片）。并且该值的默认值为true所以我们也可以将属性adjustsImageWhenHighlighted设置为false，不让系统自动帮我们设置高亮状态下显示的图片即可。 + 情况贴出重要代码 123456// 设置按钮图片动画数组voiceButton.imageView?.animationImages = [ #imageLiteral(resourceName: \"message_voice_sender_playing_1\"), #imageLiteral(resourceName: \"message_voice_sender_playing_2\"), #imageLiteral(resourceName: \"message_voice_sender_playing_3\")] 12// 开始动画voiceButton.imageView?.startAnimating() 12// 停止动画voiceButton.imageView?.stopAnimating() 原因这个按钮在结束动画之后之所以会变暗，是因为它在动画结束之后自动显示为高亮图\b片，不信？那只好上证据了~12// 设置语音按钮的高亮图片voiceButton.setImage(#imageLiteral(resourceName: \"message_voice_sender_normal\"), for: .highlighted) 那知道原因之后就很好解决了 解决方案方案一：设置按钮的高亮图片将按钮的高亮图片与普通状态下的一致即可。这里就再赘述了 方案二：adjustsImageWhenHighlighted = false在UIButton中有这么一个属性1adjustsImageWhenHighlighted查看官方文档的说明当该属性设置为true时，按钮在高亮状态下，图片会绘制成高亮（\b前提是没有手动设置高亮图片）。并且该值的默认值为true所以我们也可以将属性adjustsImageWhenHighlighted设置为false，不让系统自动帮我们设置高亮状态下显示的图片即可。 效果 附上相关项目：Swift 3.0 高仿微信","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"Swift 3.0 高仿喜马拉雅FM","slug":"Swift-3-0-高仿喜马拉雅FM","date":"2017-09-12T09:20:37.000Z","updated":"2021-03-03T04:54:43.560Z","comments":true,"path":"2017/09/12/Swift-3-0-高仿喜马拉雅FM/","link":"","permalink":"http://linxunfeng.top/2017/09/12/Swift-3-0-%E9%AB%98%E4%BB%BF%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85FM/","excerpt":"基于Swift 3.0 编写而成,运行环境要求: Xcode 8.0 +","text":"基于Swift 3.0 编写而成,运行环境要求: Xcode 8.0 + 高仿喜马拉雅FMgitHub: https://github.com/LinXunFeng/LXFFM 说明基于Swift 3.0 编写而成,运行环境要求: Xcode 8.0 LXFFM原OC版: https://github.com/Eastwu5788/XMLYFM从原版作者的源代码上学到了很多,十分感谢.由于只是本人OC转Swift的试练项目,所以有些内容并没有实现,哈哈 效果图","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS - Swift UITableView的scrollToRow的坑","slug":"iOS-Swift-UITableView的scrollToRow的坑","date":"2017-09-12T09:16:39.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-Swift-UITableView的scrollToRow的坑/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-Swift-UITableView%E7%9A%84scrollToRow%E7%9A%84%E5%9D%91/","excerpt":"今天鄙人使用SnapKit来布局cell，然后用scrollToRow来滚到底部就遇到了一个很奇葩的现象。我设置了在键盘弹出后聊天消息列表会自动滚到底部。1.随便输入一条消息，点发送后，在聊天消息列表中并没有滚到最新消息那一行。2.退出键盘不做任何操作再打开键盘也是滚到刚才那里(即最新消息的上一条所在位置)3.只有在退出键盘后把聊天消息列表的消息向上拉一点距离露出最新消息所在的cell之后，再点击才有用 +","text":"今天鄙人使用SnapKit来布局cell，然后用scrollToRow来滚到底部就遇到了一个很奇葩的现象。我设置了在键盘弹出后聊天消息列表会自动滚到底部。1.随便输入一条消息，点发送后，在聊天消息列表中并没有滚到最新消息那一行。2.退出键盘不做任何操作再打开键盘也是滚到刚才那里(即最新消息的上一条所在位置)3.只有在退出键盘后把聊天消息列表的消息向上拉一点距离露出最新消息所在的cell之后，再点击才有用 + 简介在tableView中，我们一般会用到scrollToRow这个来控制tableView滚到指定的某一行。一般写法如下所示123456// MARK: 滚到底部func scrollToBottom(animated: Bool = false) &#123; if dataArr.count &gt; 0 &#123; tableView.scrollToRow(at: IndexPath(row: dataArr.count - 1, section: 0), at: .bottom, animated: animated) &#125;&#125; 情况今天鄙人使用SnapKit来布局cell，然后用scrollToRow来滚到底部就遇到了一个很奇葩的现象。我设置了在键盘弹出后聊天消息列表会自动滚到底部。1.随便输入一条消息，点发送后，在聊天消息列表中并没有滚到最新消息那一行。2.退出键盘不做任何操作再打开键盘也是滚到刚才那里(即最新消息的上一条所在位置)3.只有在退出键盘后把聊天消息列表的消息向上拉一点距离露出最新消息所在的cell之后，再点击才有用 分析在无奈之下，经过了一步步的探索，终于发现了问题的所在首先我们要了解一下scrollToRow执行后会调用哪些函数及顺序会调用这两个方法1func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell1func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat 步骤一我在 heightForRow 中写了具体的数据，也就是把高度写死，不再是动态获取。接着执行程序得到如下结果比如我原本有10条数据，现在加入了一条后执行了scrollToRow，它会1.先调用 heightForRow 11次，即包括最新加入的那一条2.然后再调用 cellForRow3.最后在调一次 heightForRow后面的2和3是针对最新消息的 步骤二我在 heightForRow 中不再写死高度，\b而是从模型数据中动态获取高度(高度是在cell布局后获取的，再赋值到模型数据中的cellHeight变量)1执行程序得到\b这个结果：调用 heightForRow 11次，然后就没了好吧，问题就出现在对heightForRow的第11次调用，前10次都有返回具体的高度，而最后一次是0~。 结论\b现在清楚了，要想在调用 scrollToRow 到指定的那一行，前提条件是那一行的高度不能为0。所以在上面的情况中，发送完消息后，最新消息的cell的确是插入到了tableView，也有显示出来(后面我自己测的)，但就是无法滚到最新消息那一行，就是因为 heightForRow 返回的高度为0在上面的情况中，向上拉一点距离露出cell后scrollToRow才有效就是因为此时heightForRow返回的高度不再为0 解决方案按本人自身的情况来说，有两种解决方法 第一种在传入的模型数据中给予明确计算出来的数值就好。 第二种我使用SnapKit来自动布局cell的\b位置然后再来获取高度，这做法主要就是为了避免运算。所以我不选用第一种解决方法好了，方法如下：1234// dataArr是用来存放模型的数组let indexPath = IndexPath(row: dataArr.count - 1, section: 0)// 调用tableView的数据源办法_ = self.tableView(tableView, cellForRowAt: indexPath)在插入\b最新消息后，调用tableView的数据源\b方法来让它先对cell进行布局，这样就获取到了cell的高度，然后再执行 scrollToRow 就好了。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS-Swift 仿微信聊天图片显示","slug":"iOS-Swift-仿微信聊天图片显示","date":"2017-09-12T08:57:35.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-Swift-仿微信聊天图片显示/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-Swift-%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/","excerpt":"其实原理比较简单，准备一张图片MaskImgae，先对其进行拉伸，然后按照其轮廓对图片进行裁剪就行了 +","text":"其实原理比较简单，准备一张图片MaskImgae，先对其进行拉伸，然后按照其轮廓对图片进行裁剪就行了 + 效果图如图所示，图片左侧有个小箭头 原理其实原理比较简单，准备一张图片MaskImgae，先对其进行拉伸，然后按照其轮廓对图片进行裁剪就行了 步骤这里摘重点说，布局什么的按自己意愿去弄吧。我固定了图片的显示大小为 102 * 152 1、对MaskImgae进行拉伸123456// 设置拉伸范围let stretchInsets = UIEdgeInsetsMake(30, 28, 23, 28)// 待拉伸的图片let stretchImage = UIImage(named: \"SenderImageNodeMask\")// 进行拉伸let bubbleMaskImage = stretchImage.resizableImage(withCapInsets: stretchInsets, resizingMode: .stretch) 拉伸的效果如图 2、对imageView设置裁剪区域这里我的 imageView 叫 chatImgView上面的拉伸效果图是临时把拉伸好的图片赋值给了chatImgView，只是为了给大家看到效果而已，\b各位看官如果有赋值请记得改回来~~ 好，下面进行裁剪12345678910111213141516// 新建一个图层let layer = CALayer()// 设置图层显示的内容为拉伸过的MaskImgaelayer.contents = bubbleMaskImage.cgImage// 设置拉伸范围(注意：这里contentsCenter的CGRect是比例（不是绝对坐标）)layer.contentsCenter = self.CGRectCenterRectForResizableImage(bubbleMaskImage)// 设置图层大小与chatImgView相同layer.frame = CGRect(x: 0, y: 0, width: 102, height: 152)// 设置比例layer.contentsScale = UIScreen.main.scale// 设置不透明度layer.opacity = 1// 设置裁剪范围self.chatImgView.layer.mask = layer// 设置裁剪掉超出的区域self.chatImgView.layer.masksToBounds = true12345678910func CGRectCenterRectForResizableImage(_ image: UIImage) -&gt; CGRect &#123; // LXFLog(\"\\(image.capInsets)\") // 这里的image.capInsets就是UIEdgeInsetsMake(30, 28, 23, 28) return CGRect( x: image.capInsets.left / image.size.width, y: image.capInsets.top / image.size.height, width: (image.size.width - image.capInsets.right - image.capInsets.left) / image.size.width, height: (image.size.height - image.capInsets.bottom - image.capInsets.top) / image.size.height )&#125;这样就完成了 解释一下下UIEdgeInsetsMakeMaskImgae 的大小为 56 * 5012// UIEdgeInsetsMake(top: CGFloat, left: CGFloat, bottom: CGFloat, right: CGFloat)UIEdgeInsetsMake(30, 28, 23, 28)红色范围就是要拉伸的范围(随手一扣，不太准确，意思意思下就好了~~) contentsCenter这是对某个区域进行全面拉伸，如果不设置的话默认值为1CGRect(x: 0, y: 0, width: 1, height: 1)就是直接进行缩放那我们先来看看，如果不对contentsCenter这个值进行设置会是什么效果我们来看下官方解释 1234var contentsCenter: CGRect &#123; get set &#125;Description The rectangle that defines how the layer contents are scaledif the layer’s contents are resized. Animatable. 翻译：如果图层的内容是重新设置了尺寸的，那定义的这个矩形(contentsCenter)是为了告诉图层，图层的内容是如何被缩放的 那明了，我们的图片是被拉伸后再绘制到layer上的，为了正确显示我们的图片，我们得告诉layer它是怎么被进行拉伸的。是的，就是下面代码所指定的范围1UIEdgeInsetsMake(30, 28, 23, 28)\b但是，正如上面提到过的，contentsCenter所要赋值的CGRect是比例，不是绝对坐标，所以现在我们得\b通过(30, 28, 23, 28)\b获取比例值，转换方法已经在上面给出了，就是CGRectCenterRectForResizableImage我们来打印下 image.capInsets的内容12345LXFLog(\"\\(image.capInsets)\")LXFLog(\"\\(image.capInsets.top)\")LXFLog(\"\\(image.capInsets.bottom)\")LXFLog(\"\\(image.capInsets.left)\")LXFLog(\"\\(image.capInsets.right)\")打印结果12345UIEdgeInsets(top: 30.0, left: 28.0, bottom: 23.0, right: 28.0)30.023.028.028.0\b好，现在结合 下面的图 与 CGRectCenterRectForResizableImage 方法中的代码就很明确比例是怎么取到的了 附上相关项目：Swift 3.0 高仿微信","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS-Swift-UICollectionView横向分页的问题","slug":"iOS-Swift-UICollectionView横向分页的问题","date":"2017-09-12T08:53:55.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-Swift-UICollectionView横向分页的问题/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-Swift-UICollectionView%E6%A8%AA%E5%90%91%E5%88%86%E9%A1%B5%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"有两种方式可以解决，数据只有11个，要分两页需要16个，那我们可以直接添加数据到16个，然后在dataSource中返回cell时进行判断及处理即可。不过对于现在来说太小题大做了，我选第二种方式~ +","text":"有两种方式可以解决，数据只有11个，要分两页需要16个，那我们可以直接添加数据到16个，然后在dataSource中返回cell时进行判断及处理即可。不过对于现在来说太小题大做了，我选第二种方式~ + UICollectionView横向分页的问题情况直接看图已经设置collectionView的isPagingEnabled为true了，可是出现了这种情况，原因就是collectionView的contentSize不够。 12345678&lt;UICollectionView: 0x7fc565076000; frame &#x3D; (0 0; 375 197); clipsToBounds &#x3D; YES; gestureRecognizers &#x3D; &lt;NSArray: 0x6180000557e0&gt;; layer &#x3D; &lt;CALayer: 0x61000022a5a0&gt;; contentOffset: &#123;187.5, 0&#125;; contentSize: &#123;562.5, 192.25&#125;&gt; 解决方案有两种方式可以解决，数据只有11个，要分两页需要16个，那我们可以直接添加数据到16个，然后在dataSource中返回cell时进行判断及处理即可。不过对于现在来说太小题大做了，我选第二种方式~ 直接修改contentSize我自定义了一个继承于UICollectionViewFlowLayout的Layout(LXFChatMoreCollectionLayout)，让UICollectionView在创建的时候使用了它 在 LXFChatMoreCollectionLayout.swift 中我们需要重写父类的collectionViewContentSize，将contentSize取出来修改为我们自己创建的newSize就可以了代码如下1234567override var collectionViewContentSize: CGSize &#123; let size: CGSize = super.collectionViewContentSize let collectionViewWidth: CGFloat = self.collectionView!.frame.size.width let nbOfScreen: Int = Int(ceil(size.width / collectionViewWidth)) let newSize: CGSize = CGSize(width: collectionViewWidth * CGFloat(nbOfScreen), height: size.height) return newSize&#125;注：ceil函数的作用是求不小于给定实数的最小整数。ceil(2)=ceil(1.2)=cei(1.5)=2.00 效果 至于如何让item水平布局，请参考《iOS - Swift UICollectionView横向分页滚动，cell左右排版》 附上相关项目：Swift 3.0 高仿微信","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS - Swift UICollectionView横向分页滚动，cell左右排版","slug":"iOS-Swift-UICollectionView横向分页滚动，cell左右排版","date":"2017-09-12T08:49:37.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-Swift-UICollectionView横向分页滚动，cell左右排版/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-Swift-UICollectionView%E6%A8%AA%E5%90%91%E5%88%86%E9%A1%B5%E6%BB%9A%E5%8A%A8%EF%BC%8Ccell%E5%B7%A6%E5%8F%B3%E6%8E%92%E7%89%88/","excerpt":"最近在做表情键盘时遇到一个问题，我用UICollectionView来布局表情，使用横向分页滚动，但在最后一页出现了如图所示的情况 +","text":"最近在做表情键盘时遇到一个问题，我用UICollectionView来布局表情，使用横向分页滚动，但在最后一页出现了如图所示的情况 + 情况最近在做表情键盘时遇到一个问题，我用UICollectionView来布局表情，使用横向分页滚动，但在最后一页出现了如图所示的情况 情况分析图是的，现在的item分布就是这个鬼样子现在想要做的，就是将现在这个鬼样子变成另外一种样子，如图那怎么办？只好重新布局item了 解决方案我是自定了一个Layout(LXFChatEmotionCollectionLayout)，让UICollectionView在创建的时候使用了它 在 LXFChatEmotionCollectionLayout.swift 中 添加一个属性来保存所有item的attributes12// 保存所有item的attributesfileprivate var attributesArr: [UICollectionViewLayoutAttributes] = [] 重新布局12345678910111213141516171819202122232425262728293031323334353637// MARK:- 重新布局override func prepare() &#123; super.prepare() let itemWH: CGFloat = kScreenW / CGFloat(kEmotionCellNumberOfOneRow) // 设置itemSize itemSize = CGSize(width: itemWH, height: itemWH) minimumLineSpacing = 0 minimumInteritemSpacing = 0 scrollDirection = .horizontal // 设置collectionView属性 collectionView?.isPagingEnabled = true collectionView?.showsHorizontalScrollIndicator = false collectionView?.showsVerticalScrollIndicator = true let insertMargin = (collectionView!.bounds.height - 3 * itemWH) * 0.5 collectionView?.contentInset = UIEdgeInsetsMake(insertMargin, 0, insertMargin, 0) /// 重点在这里 var page = 0 let itemsCount = collectionView?.numberOfItems(inSection: 0) ?? 0 for itemIndex in 0..&lt;itemsCount &#123; let indexPath = IndexPath(item: itemIndex, section: 0) let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath) page = itemIndex / (kEmotionCellNumberOfOneRow * kEmotionCellRow) // 通过一系列计算, 得到x, y值 let x = itemSize.width * CGFloat(itemIndex % Int(kEmotionCellNumberOfOneRow)) + (CGFloat(page) * kScreenW) let y = itemSize.height * CGFloat((itemIndex - page * kEmotionCellRow * kEmotionCellNumberOfOneRow) / kEmotionCellNumberOfOneRow) attributes.frame = CGRect(x: x, y: y, width: itemSize.width, height: itemSize.height) // 把每一个新的属性保存起来 attributesArr.append(attributes) &#125;&#125; 返回所有当前可见的Attributes123456789override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? &#123; var rectAttributes: [UICollectionViewLayoutAttributes] = [] _ = attributesArr.map(&#123; if rect.contains($0.frame) &#123; rectAttributes.append($0) &#125; &#125;) return rectAttributes&#125; 大功告成 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import UIKitlet kEmotionCellNumberOfOneRow = 8let kEmotionCellRow = 3class LXFChatEmotionCollectionLayout: UICollectionViewFlowLayout &#123; // 保存所有item fileprivate var attributesArr: [UICollectionViewLayoutAttributes] = [] // MARK:- 重新布局 override func prepare() &#123; super.prepare() let itemWH: CGFloat = kScreenW / CGFloat(kEmotionCellNumberOfOneRow) // 设置itemSize itemSize = CGSize(width: itemWH, height: itemWH) minimumLineSpacing = 0 minimumInteritemSpacing = 0 scrollDirection = .horizontal // 设置collectionView属性 collectionView?.isPagingEnabled = true collectionView?.showsHorizontalScrollIndicator = false collectionView?.showsVerticalScrollIndicator = true let insertMargin = (collectionView!.bounds.height - 3 * itemWH) * 0.5 collectionView?.contentInset = UIEdgeInsetsMake(insertMargin, 0, insertMargin, 0) var page = 0 let itemsCount = collectionView?.numberOfItems(inSection: 0) ?? 0 for itemIndex in 0..&lt;itemsCount &#123; let indexPath = IndexPath(item: itemIndex, section: 0) let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath) page = itemIndex / (kEmotionCellNumberOfOneRow * kEmotionCellRow) // 通过一系列计算, 得到x, y值 let x = itemSize.width * CGFloat(itemIndex % Int(kEmotionCellNumberOfOneRow)) + (CGFloat(page) * kScreenW) let y = itemSize.height * CGFloat((itemIndex - page * kEmotionCellRow * kEmotionCellNumberOfOneRow) / kEmotionCellNumberOfOneRow) attributes.frame = CGRect(x: x, y: y, width: itemSize.width, height: itemSize.height) // 把每一个新的属性保存起来 attributesArr.append(attributes) &#125; &#125; override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? &#123; var rectAttributes: [UICollectionViewLayoutAttributes] = [] _ = attributesArr.map(&#123; if rect.contains($0.frame) &#123; rectAttributes.append($0) &#125; &#125;) return rectAttributes &#125; &#125; 附上相关项目：Swift 3.0 高仿微信","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"}]},{"title":"iOS - 通过runtime获取某个类中所有的变量和方法","slug":"iOS-通过runtime获取某个类中所有的变量和方法","date":"2017-09-12T08:32:11.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-通过runtime获取某个类中所有的变量和方法/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-%E9%80%9A%E8%BF%87runtime%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E7%B1%BB%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95/","excerpt":"苹果官方的类中只提供给我们一小部分成员变量和方法,但有时候我们需要的恰好就没有提供,这样就会令开发人员十分懊恼了,那怎样才能获取该类中所有的变量及方法,用来查找是否有相对应的变量和方法呢?我们可以使用苹果自带的 运行时(runtime) 来获取+","text":"苹果官方的类中只提供给我们一小部分成员变量和方法,但有时候我们需要的恰好就没有提供,这样就会令开发人员十分懊恼了,那怎样才能获取该类中所有的变量及方法,用来查找是否有相对应的变量和方法呢?我们可以使用苹果自带的 运行时(runtime) 来获取+ 苹果官方的类中只提供给我们一小部分成员变量和方法,但有时候我们需要的恰好就没有提供,这样就会令开发人员十分懊恼了,那怎样才能获取该类中所有的变量及方法,用来查找是否有相对应的变量和方法呢?我们可以使用苹果自带的 运行时(runtime) 来获取 运行时(Runtime): 苹果官方一套C语言库 能做很多底层操作(比如访问隐藏的一些成员变量\\成员方法….) 以下以 UITextField 为例 一. 包含运行时头文件1#import &lt;objc/runtime.h&gt; 二. 获取所有的成员变量123456789101112131415161718unsigned int count = 0; // 拷贝出所胡的成员变量列表Ivar *ivars = class_copyIvarList([UITextField class], &amp;count); for (int i = 0; i&lt;count; i++) &#123; // 取出成员变量 Ivar ivar = *(ivars + i); // 打印成员变量名字 LXFLog(@\"%s\", ivar_getName(ivar)); // 打印成员变量的数据类型 LXFLog(@\"%s\", ivar_getTypeEncoding(ivar));&#125; // 释放free(ivars); Swift的写法如下1234567var count: UInt32 = 0let ivars = class_copyIvarList(UIViewController.self, &amp;count)!for i in 0..&lt;count &#123; let namePoint = ivar_getName(ivars[Int(i)])! let name = String(cString: namePoint) print(name)&#125; 三. 获取所有的成员方法// 下面的UITextField改为你想获取所有属性的类名// methCount: 这个类所有属性的个数123456789101112131415unsigned int methCount = 0;Method *meths = class_copyMethodList([UITextField class], &amp;methCount); for(int i = 0; i &lt; methCount; i++) &#123; Method meth = meths[i]; SEL sel = method_getName(meth); const char *name = sel_getName(sel); NSLog(@\"%s\", name);&#125; free(meths);最后,通过KVC的方式给相应的成员变量赋值即可!如:12345// 修改点位文字颜色UILabel *placeholderLabel = [self valueForKeyPath:@\"_placeholderLabel\"];placeholderLabel.textColor = [UIColor redColor];// 或者这样[self setValue:[UIColor grayColor] forKeyPath:@\"_placeholderLabel.textColor\"];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://linxunfeng.top/tags/Objective-C/"}]},{"title":"iOS - 实现UINavigation全屏动返回(二)","slug":"iOS-实现UINavigation全屏动返回-二","date":"2017-09-12T01:05:03.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/12/iOS-实现UINavigation全屏动返回-二/","link":"","permalink":"http://linxunfeng.top/2017/09/12/iOS-%E5%AE%9E%E7%8E%B0UINavigation%E5%85%A8%E5%B1%8F%E5%8A%A8%E8%BF%94%E5%9B%9E-%E4%BA%8C/","excerpt":"在 iOS - 实现UINavigation全屏滑\b动返回(一) 中我们实现了滑动返回的功能，但不是全屏滑动返回，得在左侧边缘轻扫才能滑动返回~UINavigationController自带的只能在边缘轻扫才能滑动返回，这用户体验是不好的，接下来实现全屏滑动返回! +","text":"在 iOS - 实现UINavigation全屏滑\b动返回(一) 中我们实现了滑动返回的功能，但不是全屏滑动返回，得在左侧边缘轻扫才能滑动返回~UINavigationController自带的只能在边缘轻扫才能滑动返回，这用户体验是不好的，接下来实现全屏滑动返回! + 回顾在 iOS - 实现UINavigation全屏滑\b动返回(一) 中我们实现了滑动返回的功能，但不是全屏滑动返回，得在左侧边缘轻扫才能滑动返回~UINavigationController自带的只能在边缘轻扫才能滑动返回，这用户体验是不好的，接下来实现全屏滑动返回! 思路既然自带的滑动返回只能是在边缘，那我们能不能修改使它触摸范围变大甚至全屏呢？先来看下系统手势有没有提供属性或方法供我们使用1NSLog(@\"%@\", self.interactivePopGestureRecognizer);打印信息：123456/*&lt;UIScreenEdgePanGestureRecognizer: 0x7fd542611e20; state = Possible; delaysTouchesBegan = YES; view = &lt;UILayoutContainerView 0x7fd542706300&gt;; target= &lt;(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition 0x7fd542611ce0&gt;)&gt;&gt;*/原来系统手势的类型为 UIScreenEdgePanGestureRecognizer ，转到定义，发现有一个属性1UIRectEdge edges是个结构体12345678typedef NS_OPTIONS(NSUInteger, UIRectEdge) &#123; UIRectEdgeNone = 0, UIRectEdgeTop = 1 &lt;&lt; 0, UIRectEdgeLeft = 1 &lt;&lt; 1, UIRectEdgeBottom = 1 &lt;&lt; 2, UIRectEdgeRight = 1 &lt;&lt; 3, UIRectEdgeAll = UIRectEdgeTop | UIRectEdgeLeft | UIRectEdgeBottom | UIRectEdgeRight&#125;只提供了这几样，都是边缘的，这样就只好另寻他路了。既然没有提供方式给我们现实要求，那我们就自己添加一个拖动手势 UIPanGestureRecognizer来替它执行滑动返回功能。12UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)];[self.view addGestureRecognizer:pan];添加一个拖动手势，让他执行系统手势的操作，调用handleNavigationTransition:方法（刚才打印的信息中可以得知），现在的问题就是target是谁？我们可以看看UIScreenEdgePanGestureRecognizer中是否有线索呢？1UIScreenEdgePanGestureRecognizer *gest = self.interactivePopGestureRecognizer;找了半天没找着，但是UIScreenEdgePanGestureRecognizer继承于UIPanGestureRecognizer，而UIPanGestureRecognizer又继承于UIGestureRecognizer，在UIGestureRecognizer提供的方法中我们可以推断出一定有target，而且还是强引用的私有属性！那我们就可以用OC强大的杀手锏KVC来得到这个属性，但是前提是我们得知道target所指属性是什么名字参照我的另一篇文章：iOS - 通过runtime获取某个类中所有的变量和方法1234567891011121314151617// OC runtime 机制// 只能动态获取当前类的成员属性，不能获取其子类，或者父类的属性unsigned int count = 0;// 拷贝出所胡的成员变量列表Ivar *ivars = class_copyIvarList([UIGestureRecognizer class], &amp;count);for (int i = 0; i&lt;count; i++) &#123; // 取出成员变量 Ivar ivar = *(ivars + i); // 打印成员变量名字 NSLog(@\"%s\", ivar_getName(ivar)); // 打印成员变量的数据类型 NSLog(@\"%s\", ivar_getTypeEncoding(ivar));&#125; // 释放 free(ivars);在打印中我们找到了UIGestureRecognizer的私有属性 _targets，是个数组，而且只有一个元素，元素的类型如图所示那就好办了，这样我们就可以得到target了12NSArray *targets = [gest valueForKeyPath:@\"_targets\"]; // 打印可以发现里面就一个元素id target = [targets[0] valueForKeyPath:@\"_target\"];这样我们就差不多实现全屏滑动返回的功能，但是有个bug如图所示，在最后里回到根控制器界面后我再一次向右滑动，接着点击Button，它没有将FirstVC弹出，这就是传说中的bug，那我们现在在做的，就是在根控制器不让滑动返回生效，即禁用手势。监听手势，遵守协议UIGestureRecognizerDelegate，实现代理方法 12// 当当前控制器是是根控制器时不让移除当前控制器(换句话说就是禁止手势)pan.delegate = self; 1234567#pragma mark - UIGestureRecognizerDelegate// 当开始滑动时调用- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; // 当为根控制器是不让移除当前控制器，非根控制器时允许移除 NSLog(@\"%ld\", self.viewControllers.count); BOOL open = self.viewControllers.count &gt; 1; return open;&#125; 最后说两句这样就可以全屏滑动了，不过让我们来看看我们添加手势的习惯123UIPanGestureRecognizer *myPan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan)];[self.view addGestureRecognizer:myPan];myPan.delegate = self;我们在添加手势时设置了target为self，而delegate也为self那是不是可以推断出系统手势的delegate就是我们刚刚想要的target呢，答案是是的1id target = self.interactivePopGestureRecognizer.delegate;所以我们的target就可以通过这种方式获得，不用KVC的方式哦，最后别忘了禁用系统手势12// 禁止系统的手势self.interactivePopGestureRecognizer.enabled = NO;这样，我们就实现了全屏滑动返回的功能了~ 源码 Objective-C 记得遵守协议： UIGestureRecognizerDelegateLXFNavigationController.m12345678910111213- (void)viewDidLoad &#123; [super viewDidLoad]; // 系统的手势 UIScreenEdgePanGestureRecognizer *gest = self.interactivePopGestureRecognizer; // target id target = self.interactivePopGestureRecognizer.delegate; // 禁止系统的手势 self.interactivePopGestureRecognizer.enabled = NO; UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:target action:@selector(handleNavigationTransition:)]; [self.view addGestureRecognizer:pan]; // 监听代理 pan.delegate = self;&#125;12345678#pragma mark - UIGestureRecognizerDelegate// 当开始滑动时调用- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer &#123; // 当为根控制器是不让移除当前控制器，非根控制器时允许移除 NSLog(@\"%ld\", self.viewControllers.count); BOOL open = self.viewControllers.count &gt; 1; return open;&#125; Swift LXFNavigationController.swift1234567891011override func viewDidLoad() &#123; super.viewDidLoad() guard let targets &#x3D; interactivePopGestureRecognizer!.value(forKey: &quot;_targets&quot;) as? [NSObject] else &#123; return &#125; let targetObjc &#x3D; targets.first let target &#x3D; targetObjc?.value(forKey: &quot;target&quot;) let action &#x3D; Selector((&quot;handleNavigationTransition:&quot;)) let panGes &#x3D; UIPanGestureRecognizer(target: target, action: action) view.addGestureRecognizer(panGes)&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://linxunfeng.top/tags/Objective-C/"}]},{"title":"iOS - 实现UINavigation全屏动返回(一)","slug":"iOS-实现UINavigation全屏动返回-一","date":"2017-09-11T21:53:59.000Z","updated":"2021-03-03T04:54:43.564Z","comments":true,"path":"2017/09/11/iOS-实现UINavigation全屏动返回-一/","link":"","permalink":"http://linxunfeng.top/2017/09/11/iOS-%E5%AE%9E%E7%8E%B0UINavigation%E5%85%A8%E5%B1%8F%E5%8A%A8%E8%BF%94%E5%9B%9E-%E4%B8%80/","excerpt":"interactivePopGestureRecognizer 是UINavigationController自带手势，当我们自定义了导航条的返回按钮后，这个手势就自动失效了，也就是说无法滑动返回。+","text":"interactivePopGestureRecognizer 是UINavigationController自带手势，当我们自定义了导航条的返回按钮后，这个手势就自动失效了，也就是说无法滑动返回。+ 要点interactivePopGestureRecognizer 是UINavigationController自带手势，当我们自定义了导航条的返回按钮后，这个手势就自动失效了，也就是说无法滑动返回。 条件很多情况下我们不得不自定义导航条的返回按钮，但是我们也要滑动返回上一级的效果。 思路既然自动失效，那我们就告诉它什么时候生效。 在非根控制器下生效(用于滑动返回上一级) 在根控制器下失效(防止根控制器被移除，当然系统不会让我们把它移除，只是会出现bug)翻译：第一个被添加的控制器成为永远不会被出栈的根控制器 步骤自定义一个 UINavigationController ，即继承于 UINavigationController ，名字为 LXFNavigationController ，将代理设为自己，遵守协议 UINavigationControllerDelegate ，\b实现代理方法 navigationController:didShowViewController:animated: 代码LXFNavigationController.m 12/** 系统手势代理 */@property(nonatomic, strong) id popGesture; 1234567- (void)viewDidLoad &#123; [super viewDidLoad]; // 记录系统手势代理 self.popGesture = self.interactivePopGestureRecognizer; self.delegate = self;&#125; 123456789101112131415161718#pragma mark - UINavigationControllerDelegate// 当控制器显示完毕的时候调用- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; // 根据 栈 先进后出 if (self.viewControllers[0] == viewController) &#123; // 根控制器 // 还原代理 self.interactivePopGestureRecognizer.delegate = self.popGesture; &#125; else &#123; // 非控制器 // 清空手势代理就能实现滑动返回，iOS6不支持 self.interactivePopGestureRecognizer.delegate = nil; &#125; // 如果当前控制器为根控制器，则使手势失效，不然手势会将根控制器移除 if (self.viewControllers.count == 1) &#123; self.interactivePopGestureRecognizer.enabled = NO; &#125; else &#123; self.interactivePopGestureRecognizer.enabled = YES; &#125;&#125; 附上Demo 最后说两句这样就可以了，但是注意了，现在实现的是滑动返回功能，并没有全屏滑动返回~~接下来看下一篇吧 iOS - 实现UINavigation全屏滑\b动返回(二)","categories":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://linxunfeng.top/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://linxunfeng.top/tags/Swift/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://linxunfeng.top/tags/Objective-C/"}]}]}