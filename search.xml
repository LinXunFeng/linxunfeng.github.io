<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Cocoapods-创建第三方框架</title>
    <url>/2018/04/06/Cocoapods-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p><Excerpt in index | 首页摘要><br>将框架中的主要文件放入到一个指定文件夹中，比如叫Classes或者Lib都可以</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="一、上传项目到github"><a href="#一、上传项目到github" class="headerlink" title="一、上传项目到github"></a>一、上传项目到github</h2><p>将框架中的主要文件放入到一个指定文件夹中，比如叫Classes或者Lib都可以<br><img src= "/img/loading.gif" data-src="/images/2018/04/Cocoapods-创建第三方框架/目录结构.png" alt="目录结构"></p>
<ul>
<li>打开终端，cd到框架目录 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;Users&#x2F;lxf&#x2F;xxxx&#x2F;LXFPhotoHelper</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<ul>
<li>将当前目录添加到缓存区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<ul>
<li>提交到本地仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &#39;描述&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加远程仓库地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;LinXunFeng&#x2F;xxx.git</span><br></pre></td></tr></table></figure>
<ul>
<li>提交到远程仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>如果出现如下提示<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;xxx&#x2F;xxx.git&#x2F;&#39;: The requested URL returned error: 403</span><br></pre></td></tr></table></figure><br>原因是本地缓存了用户名和密码<br>编辑.git目录下的config文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi .git&#x2F;config</span><br></pre></td></tr></table></figure><br>找到url那一行，在github.com前加上用户名后保存，再重新执行推送操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url &#x3D; https:&#x2F;&#x2F;LinXunFeng@github.com&#x2F;LinXunFeng&#x2F;xxx.git</span><br></pre></td></tr></table></figure></p>
<ul>
<li>打标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 具体说明可以执行&#96;git tag --help&#96;后查看</span><br><span class="line">&#x2F;&#x2F; git tag -a &#39;版本号&#39; -m &#39;tag描述&#39;</span><br><span class="line">&#x2F;&#x2F; 注意一下，这里打的标签只是在本地</span><br><span class="line">git tag &#39;0.0.1&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>推着所有标签至远程仓库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 只推着指定版本</span><br><span class="line">&#x2F;&#x2F; git push origin 版本号 </span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<h2 id="二、创建并修改podspec文件"><a href="#二、创建并修改podspec文件" class="headerlink" title="二、创建并修改podspec文件"></a>二、创建并修改podspec文件</h2><ul>
<li>创建Spec文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 名称一般与工程名称保持一致</span><br><span class="line">pod spec create 框架名称</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="/images/2018/04/Cocoapods-创建第三方框架/podspec文件.png" alt="podspec文件"></p>
<ul>
<li>修改Spec文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.name         &#x3D; &quot;LXFPhotoHelper（仓库名称）&quot;</span><br><span class="line">s.version      &#x3D; &quot;0.0.1（版本号，这里跟下面s.source中的tag有关）&quot;</span><br><span class="line">s.summary      &#x3D; &quot;对你自己仓库的简单描述，不要写太多字&quot;</span><br><span class="line">s.description  &#x3D; &quot;这个是详细描述，这里需要注意的是，这里文字的长度需要比  </span><br><span class="line">s.summary的要长，不然会出现警告&quot;</span><br><span class="line">s.homepage     &#x3D; &quot;仓库首页地址，如https:&#x2F;&#x2F;github.com&#x2F;LinXunFeng&#x2F;LXFPhotoHelper&quot;</span><br><span class="line">s.license      &#x3D; &quot;MIT&quot;</span><br><span class="line">s.author       &#x3D; &#123; &quot;LinXunFeng&quot; &#x3D;&gt; &quot;598600855@qq.com&quot; &#125;</span><br><span class="line"># source存放的地址是代码的真正地址</span><br><span class="line">s.source       &#x3D; &#123; :git &#x3D;&gt; &quot;仓库对应的git地址，如https:&#x2F;&#x2F;github.com&#x2F;LinXunFeng&#x2F;LXFPhotoHelper.git&quot;, :tag &#x3D;&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br><span class="line"># pod install时真正下载下来的文件路径，这里指定的是你仓库下的Classes目录中的所有.h和.m文件（填写的是相对地址）</span><br><span class="line"># ** 通配目录</span><br><span class="line">s.source_files  &#x3D; &quot;Classes&quot;, &quot;Classes&#x2F;**&#x2F;*.&#123;h,m&#125;&quot;</span><br><span class="line"></span><br><span class="line"># s.library &#x3D; &quot;sqlite3&quot; # 框架依赖系统的sqlite3</span><br></pre></td></tr></table></figure>
也可以上官网的手册【<a href="https://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="noopener">Podspec Syntax Reference</a>】上查看</li>
</ul>
<p>这里需要我们注意的是<code>s.version= &quot;0.0.1&quot;</code>，这里的版本号要与刚刚打的tag一致</p>
<h2 id="三、注册trunk"><a href="#三、注册trunk" class="headerlink" title="三、注册trunk"></a>三、注册trunk</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; --verbose 打印详情信息</span><br><span class="line">&#x2F;&#x2F; pod trunk register 邮箱 &#39;你的名称&#39; --verbose</span><br><span class="line">pod trunk register 598600855@qq.com &#39;LinXunFeng&#39; --verbose</span><br></pre></td></tr></table></figure>
<p>然后去验证邮箱<br><img src= "/img/loading.gif" data-src="/images/2018/04/Cocoapods-创建第三方框架/验证成功.png" alt="验证成功"><br>验证成功后会提示我们回到终端，并敲入<code>pod trunk push 名称.podspec</code></p>
<h2 id="四、上传Spec"><a href="#四、上传Spec" class="headerlink" title="四、上传Spec"></a>四、上传Spec</h2><p>执行<code>pod trunk push</code>后会有一个审核的过程，如果提示没有通过，有ERROR就修改好后重新push，如果只是WARN可以选择在<code>pod trunk push</code>后面加上<code>--allow-warnings</code>来忽略它们<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk push LXFPhotoHelper.podspec --allow-warnings</span><br></pre></td></tr></table></figure></p>
<p>如果出现如下信息，则说明你的框架名字已被占用，得重新改个名字～<br>所以，在创建你自己的cocoapods仓库时最好是到<a href="https://cocoapods.org/" target="_blank" rel="noopener">cocoapods.org</a>上先查一下有没有相同名字的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[!] You (xxx@qq.com) are not allowed to push new versions for this pod. The owners of this pod are yyy@qq.com.</span><br></pre></td></tr></table></figure></p>
<p>上传成功后会自动帮我们更新本地仓库，如果无法搜索到自己的框架，可以先删掉本地的索引文件后再搜索一次<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json</span><br></pre></td></tr></table></figure></p>
<p>当使用pod search 命令可以搜索自己的框架时, 那么就意味着审核通过了</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-虚拟环境</title>
    <url>/2018/04/02/Python-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>平时在开发时我们都会先安装一些python需要的包，每次安装都会有一个版本，如果不同项目需要不同版本的包时就会出现不兼容的情况。应对这种情况我们就可以搭建多个虚拟环境来应对不同的环境需求，在虚拟环境中搭建一个Python项目运行所需要的那些包，将来根据运行的项目来切换不同环境即可</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>


<blockquote>
<p>平时在开发时我们都会先安装一些python需要的包，每次安装都会有一个版本，如果不同项目需要不同版本的包时就会出现不兼容的情况。应对这种情况我们就可以搭建多个虚拟环境来应对不同的环境需求，在虚拟环境中搭建一个Python项目运行所需要的那些包，将来根据运行的项目来切换不同环境即可</p>
</blockquote>
<p>我们可以在当前用户的家目录中找到【.virtualenvs】文件夹，查看当前所有的虚拟环境</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/virtualenvs.png" alt="virtualenvs"></p>
<h2 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h2><ul>
<li>创建：mkvirtualenv [虚拟环境名称]</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkvirtualenv lxfenv1</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/mkvirtualenv.png" alt="安装成功"></p>
<p>注：创建的过程需要联网</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/目录结构.png" alt="目录结构"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installing setuptools, pkg_resources, pip, wheel...done.</span><br></pre></td></tr></table></figure>
<p>刚刚安装时提示安装的这些东西就存放在你创建好的虚拟环境下的【lib/python2.7/site-packages/】目录中</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/lib目录.png" alt="lib目录"></p>
<ul>
<li>退出：deactivate<br>当我们安装好虚拟环境后默认就使用了该虚拟环境，如图标识处可以看出</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/当前环境.png" alt="当前环境"></p>
<p>如果你想退出当前的虚拟环境，或以使用如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/退出环境.png" alt="退出环境"></p>
<ul>
<li>进入：workon [虚拟环境名称]</li>
</ul>
<p>使用指定的虚拟环境则使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workon lxfenv1</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/workon.png" alt="workon"></p>
<ul>
<li>删除：rmvirtualenv [虚拟环境名称]</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmvirtualenv lxfenv1</span><br></pre></td></tr></table></figure>
<h2 id="安装拓展包"><a href="#安装拓展包" class="headerlink" title="安装拓展包"></a>安装拓展包</h2><ul>
<li>查看当前安装好的包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip list</span><br><span class="line">或者</span><br><span class="line">pip freeze</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/查看当前安装好的包.png" alt="查看当前安装好的包"></p>
<p>ps: 上图<code>pip list</code>中列出的四个包是安装虚拟环境必定会安装的包<br>如图，<code>pip list</code>会列出所有的包，而<code>pip freeze</code>只会列出扩展的包</p>
<ul>
<li>安装指定包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install django&#x3D;&#x3D;1.8.2</span><br><span class="line"># &#x3D;&#x3D;1.8.2 为指定版本号，不写则直接安装最新的包</span><br></pre></td></tr></table></figure>
<strong>注： pip install xxx 会自动删除旧版本，再安装新版本</strong></li>
</ul>
<p>如果不知道包名可以到<a href="https://pypi.python.org" target="_blank" rel="noopener">pypi</a>上搜索</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/Python-虚拟环境/安装指定的包.png" alt="安装指定的包"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 3.0 高仿喜马拉雅FM</title>
    <url>/2017/09/12/Swift-3-0-%E9%AB%98%E4%BB%BF%E5%96%9C%E9%A9%AC%E6%8B%89%E9%9B%85FM/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>基于Swift 3.0 编写而成,运行环境要求: Xcode 8.0</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h1 id="高仿喜马拉雅FM"><a href="#高仿喜马拉雅FM" class="headerlink" title="高仿喜马拉雅FM"></a>高仿喜马拉雅FM</h1><p>gitHub: <a href="https://github.com/LinXunFeng/LXFFM" target="_blank" rel="noopener">https://github.com/LinXunFeng/LXFFM</a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>基于Swift 3.0 编写而成,运行环境要求: Xcode 8.0</p>
<h2 id="LXFFM"><a href="#LXFFM" class="headerlink" title="LXFFM"></a>LXFFM</h2><p>原OC版: <a href="https://github.com/Eastwu5788/XMLYFM" target="_blank" rel="noopener">https://github.com/Eastwu5788/XMLYFM</a><br>从原版作者的源代码上学到了很多,十分感谢.<br>由于只是本人OC转Swift的试练项目,所以有些内容并没有实现,哈哈</p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFFM/raw/master/Screenshots/1.gif" alt="推荐"></p>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFFM/raw/master/Screenshots/2.gif" alt="分类"></p>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFFM/raw/master/Screenshots/3.gif" alt="广播"></p>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFFM/raw/master/Screenshots/4.gif" alt="榜单"></p>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFFM/raw/master/Screenshots/5.gif" alt="主播"></p>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFFM/raw/master/Screenshots/6.gif" alt="订阅听"></p>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFFM/raw/master/Screenshots/7.gif" alt="下载听"></p>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFFM/raw/master/Screenshots/8.gif" alt="我的"></p>
<div class="github-widget" data-repo="LinXunFeng/LXFFM"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 优雅的适配大小</title>
    <url>/2018/10/24/Swift-%E4%BC%98%E9%9B%85%E7%9A%84%E9%80%82%E9%85%8D%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<blockquote>
<p>在日常开发中常常会对设备进行一定的适配，为了方便在多个项目里统一管理和使用，所以封装并开源了<code>SwiftyFitsize</code>这个库，可用于适配视图及字体大小，同时也支持 xib 和 storyboard</p>
</blockquote>
<p>GitHub: <a href="https://github.com/LinXunFeng/SwiftyFitsize" target="_blank" rel="noopener">SwiftyFitsize</a></p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>在日常开发中常常会对设备进行一定的适配，为了方便在多个项目里统一管理和使用，所以封装并开源了<code>SwiftyFitsize</code>这个库，可用于适配视图及字体大小，同时也支持 xib 和 storyboard</p>
</blockquote>
<p>GitHub: <a href="https://github.com/LinXunFeng/SwiftyFitsize" target="_blank" rel="noopener">SwiftyFitsize</a></p>
<p>最终的效果如下图所示</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-优雅的适配大小/exhibition.png" alt="效果图"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Cocoapods安装，或手动拖入项目<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;SwiftyFitsize&#39;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>SwiftyFitsize</code>在默认状况下所使用的参照宽度为<code>iphone6</code>的<code>375</code><br>如果设计图所选用设备的宽度与默认值不同，可以在<code>AppDelegate</code>下初始化所参照的宽度</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SwiftyFitsize</span>.reference(width: <span class="number">414</span>)</span><br></pre></td></tr></table></figure>
<p>下面列出一些设备对应的分辨率，方便查找</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>逻辑分辨率(point)</th>
<th>设备分辨率(pixel)</th>
</tr>
</thead>
<tbody>
<tr>
<td>SE</td>
<td>320x568</td>
<td>640x1136</td>
</tr>
<tr>
<td>6(S)／7／8</td>
<td>375x667</td>
<td>750x1334</td>
</tr>
<tr>
<td>6(S)+／7+／8+</td>
<td>414x736</td>
<td>1080x1920</td>
</tr>
<tr>
<td>X(S)</td>
<td>375x812</td>
<td>1125x2436</td>
</tr>
<tr>
<td>XR</td>
<td>414x896</td>
<td>828x1792</td>
</tr>
<tr>
<td>XS Max</td>
<td>414x896</td>
<td>1242x2688</td>
</tr>
</tbody>
</table>
<p>使用也是非常方便的，只需要在<code>Number</code>、<code>UIFont</code>、<code>CGPoint</code>、<code>CGSize</code>、<code>UIEdgeInsetsMake</code>这些类型的值后面加上<code>~</code>即可<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>~</span><br><span class="line"><span class="type">UIFont</span>.systemFont(ofSize: <span class="number">14</span>)~</span><br><span class="line"><span class="type">CGPoint</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)~</span><br><span class="line"><span class="type">CGSize</span>(width: <span class="number">100</span>, height: <span class="number">100</span>)~</span><br><span class="line"><span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)~</span><br><span class="line"><span class="type">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)~</span><br></pre></td></tr></table></figure></p>
<h5 id="xib-storyboard-字体适配"><a href="#xib-storyboard-字体适配" class="headerlink" title="xib / storyboard 字体适配"></a>xib / storyboard 字体适配</h5><p>支持控件 <code>UILabel</code> <code>UIButton</code> <code>UITextView</code> <code>UITextField</code></p>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/SwiftyFitsize/raw/master/Screenshots/xib-font.png" alt="xib-font"></p>
<h5 id="xib-storyboard-约束适配"><a href="#xib-storyboard-约束适配" class="headerlink" title="xib / storyboard 约束适配"></a>xib / storyboard 约束适配</h5><p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/SwiftyFitsize/raw/master/Screenshots/xib-constraint.png" alt="xib-font"></p>
<p>##### </p>
<p>注：<code>~</code>请不要相互嵌套使用，如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">CGPoint</span>(x: <span class="number">10</span>~, y: <span class="number">10</span>~)~</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-ARC与MRC的单例设计模式</title>
    <url>/2017/09/12/iOS-ARC%E4%B8%8EMRC%E7%9A%84%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>单例设计模式(Singleton) 就是保证某个类创建出来的对象从始到终只有一个的一种方案</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="单例设计模式-Singleton"><a href="#单例设计模式-Singleton" class="headerlink" title="单例设计模式(Singleton)"></a>单例设计模式(Singleton)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>就是保证某个类创建出来的对象从始到终只有一个的一种方案</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>节省内存开销</li>
<li>保证整个程序中使用同一份资源</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先将我们的环境设置为非ARC环境，即MRC，如图<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-ARC与MRC的单例设计模式/1.png" alt="MRC环境"></p>
<blockquote>
<p>在MRC模式下，我们得自己手动释放资源，所以得重写一些与资源创建与释放相关的方法，以保证单例对象的唯一。</p>
</blockquote>
<p>新建一个继承于NSObject的类 LXFFileTool，我直接上代码，并写上注释<br>LXFFileTool.h<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LXFFileTool</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedFileTool;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br>LXFFileTool.m<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LXFFileTool.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LXFFileTool</span></span></span><br><span class="line"><span class="keyword">static</span> LXFFileTool *_fileTools = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  alloc方法内部会调用allocWithZone:</span></span><br><span class="line"><span class="comment"> *  @param zone 系统分配给app的内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">if</span> (_fileTools == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;    <span class="comment">// 安全(这个代码只会被调用一次)</span></span><br><span class="line">            _fileTools = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _fileTools;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release &#123;</span><br><span class="line">    <span class="comment">// 在allocWithZone中使用了GCD令创建对象的代码只执行一次，如果_fileTools被释放则无法再创建</span></span><br><span class="line">    <span class="comment">// 重写release方法，防止_fileTools被释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写retain方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写retainCount锁定引用计数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写init方法，防止单例所拥有的属性值被重置</span></span><br><span class="line"><span class="comment">// 让初始化的方法只能执行一次，自然属性值就没有机会被重置</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _fileTools = [<span class="keyword">super</span> init];  <span class="comment">// init会先调用alloc方法</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _fileTools;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 仿造系统的单例创建方式，提供类方法</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedFileTool &#123;</span><br><span class="line">    <span class="comment">// 由于我们已经重写了init方法保证了单例对象的唯一了，所以这里直接调用init方法即可。</span></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>MRC下就是这样，我们的目的就是只能创建和初始化一次对象，不给机会释放，也不给机会重新初始化，从而保证了该对象的唯一。</p>
</blockquote>
<p>那现在来看看ARC下是如何实现单例的吧。其实ARC下与MRC的区别就是ARC下我们不用自己再手动去释放资源了，从而使代码上大同小异，如下所示。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LXFFileTool.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LXFFileTool</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> LXFFileTool *_fileTools = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">if</span> (_fileTools == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">            _fileTools = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _fileTools;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _fileTools = [<span class="keyword">super</span> init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _fileTools;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedFileTool &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="批量创建单例"><a href="#批量创建单例" class="headerlink" title="批量创建单例"></a>批量创建单例</h2><blockquote>
<p>现在我们已经知道了ARC与MRC下分别是如何创建单例的了，但是如果我们一个项目里需要多个单例，那我们只能把代码复制粘贴再改改就完事吗？这未免也太麻烦了吧。那我们能不能做到快速且方便的创建单例对象呢？可以的，利用宏</p>
</blockquote>
<p>首先先说下一些关于宏的知识吧</p>
<ul>
<li>使用 #define 关键字来定义宏</li>
<li>宏定义只能是单行的，不能换行</li>
</ul>
<p>那现在来讨论下一些疑惑吧，你说宏只能单行，可是创建单例的代码可是有很多行呀！还有我们如何做到自定义类方法名(就是 sharedXXX )？好，我们来介绍下宏下的两个特殊符号</p>
<h3 id="宏的特殊符号"><a href="#宏的特殊符号" class="headerlink" title="宏的特殊符号"></a>宏的特殊符号</h3><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">用来转译换行符，即屏蔽换行符</td>
</tr>
<tr>
<td style="text-align:center">##</td>
<td style="text-align:center">将两个相邻的标记(token)连接为一个单独的标记</td>
</tr>
</tbody>
</table>
<p>想了解其它关于宏的预处理命令可以自行百度参考”C语言的预处理命令”</p>
<blockquote>
<p>简单来说，\用于取消换行，##用来连接，而我们就用##来实现自定义类方法名</p>
</blockquote>
<p>创建一个头文件Singleton.h用来存放宏定义<br>先来看看定义.h中 sharedXXX 是如何通过宏来定义的<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h文件的实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SingletonH(methodName) + (instancetype)shared##methodName;</span></span><br></pre></td></tr></table></figure><br>现在回到LXFFileTool.h中，直接一行定义sharedFileTool这个类方法<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Singleton.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LXFFileTool</span> : <span class="title">NSObject</span></span></span><br><span class="line">SingletonH(FileTool)</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br>我们只需要将方法名FileTool传入SingletonH()中就可以拼接为sharedFileTool</p>
<p>那现在再来看看定义.m中创建单例的方式，以ARC为例<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SingletonM(methodName) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance = <span class="literal">nil</span>; \</span><br><span class="line">+ (<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zAone &#123; \</span><br><span class="line">    <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123; \</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">        <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone]; \</span><br><span class="line">        &#125;); \</span><br><span class="line">    &#125; \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">\</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123; \</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; \</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [<span class="keyword">super</span> init]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    <span class="keyword">return</span> _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">\</span><br><span class="line">+ (<span class="keyword">instancetype</span>)shared##methodName &#123; \</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init]; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在每一个行后面加上(反斜杠)取消换行，使用##来拼接传入的方法名，但还有一点需要注意：最后一行不能加反斜杠</p>
</blockquote>
<p>回到LXFFileTool.m中，一行实现创建单例<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LXFFileTool.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LXFFileTool</span></span></span><br><span class="line">SingletonM(FileTool)</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><br>好，现在还有一个问题，就是如果我的项目中有个别文件是需要MRC环境的，那我该怎么办才能让创建单例也是如此简单呢？很简单，加个判断就好了，大致判断如下，详情看文章最后附上的Demo<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(objc_arc) <span class="comment">// ARC</span></span></span><br><span class="line"><span class="comment">// 写上ARC下的定义代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>   <span class="comment">// 非ARC</span></span></span><br><span class="line"><span class="comment">// 写上MRC下的定义代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>好了，现在用起来是不是方便多了？我们只要创建一个类，然后在.h文件中写SingletonH(XXX)，再在.m文件中写SingletonM(XXX)就可以实现单例了~</p>
</blockquote>
<h3 id="指定环境"><a href="#指定环境" class="headerlink" title="指定环境"></a>指定环境</h3><p>顺便提下如何在MRC下指定某个类文件使用的环境为ARC<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-ARC与MRC的单例设计模式/2.png" alt="指定环境"><br>如图，可以在 Build Phases -&gt; Compile Sources 中双击某个需要ARC环境的类文件，然后写上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-fobjc-arc</span><br></pre></td></tr></table></figure>
<p>如果是指定MRC，则写上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-fno-objc-arc</span><br></pre></td></tr></table></figure></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>最后，附上Demo: <a href="https://github.com/LinXunFeng/LXFSingleton" target="_blank" rel="noopener">LXFSingleton</a></p>
<div class="github-widget" data-repo="LinXunFeng/LXFSingleton"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - LXFDrawBoard 多功能小画板</title>
    <url>/2017/09/25/iOS-LXFDrawBoard-%E5%A4%9A%E5%8A%9F%E8%83%BD%E5%B0%8F%E7%94%BB%E6%9D%BF/</url>
    <content><![CDATA[<p><Excerpt in index | 首页摘要><br>将LXFDrawBoard拖入项目中，导入头文件LXFDrawBoard.h，需要什么笔刷可以在Brush文件夹中找到即可使用，具体使用方法可以参考Demo<br>+<a id="more"></a></p>
<The rest of contents | 余下全文>



<h1 id="LXFDrawBoard"><a href="#LXFDrawBoard" class="headerlink" title="LXFDrawBoard"></a>LXFDrawBoard</h1><p>多功能小画板 GitHub: <a href="https://github.com/LinXunFeng/LXFDrawBoard" target="_blank" rel="noopener">Demo</a></p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><blockquote>
<p>将LXFDrawBoard拖入项目中，导入头文件LXFDrawBoard.h，需要什么笔刷可以在Brush文件夹中找到即可使用，具体使用方法可以参考Demo</p>
</blockquote>
<p><strong>LXFDrawBoardDelegate</strong></p>
<p>返回需要添加的描述</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)LXFDrawBoard:(LXFDrawBoard *)drawBoard textForDescLabel:(<span class="built_in">UILabel</span> *)descLabel;</span><br></pre></td></tr></table></figure>
<p>当添加或修改描述时调用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)LXFDrawBoard:(LXFDrawBoard *)drawBoard clickDescLabel:(<span class="built_in">UILabel</span> *)descLabel;</span><br></pre></td></tr></table></figure>
<h2 id="笔刷"><a href="#笔刷" class="headerlink" title="笔刷"></a>笔刷</h2><h3 id="2017–09-25-更新"><a href="#2017–09-25-更新" class="headerlink" title="2017–09-25 更新"></a>2017–09-25 更新</h3><p>橡皮擦 LXFEraserBrush<br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFDrawBoard/raw/master/Screenshots/橡皮擦.gif" alt="LXFEraserBrush"></p>
<hr>
<p>铅笔 LXFPencilBrush<br><img src= "/img/loading.gif" data-src="http://upload-images.jianshu.io/upload_images/2144614-db7ee9b3b6dc7d3c.gif?imageMogr2/auto-orient/strip" alt="LXFPencilBrush"></p>
<p>箭头 LXFArrowBrush<br><img src= "/img/loading.gif" data-src="http://upload-images.jianshu.io/upload_images/2144614-52f9e8c9b036669a.gif?imageMogr2/auto-orient/strip" alt="LXFArrowBrush"></p>
<p>直线 LXFLineBrush<br><img src= "/img/loading.gif" data-src="http://upload-images.jianshu.io/upload_images/2144614-17043979b48ec450.gif?imageMogr2/auto-orient/strip" alt="LXFLineBrush"></p>
<p>文本 LXFTextBrush<br><img src= "/img/loading.gif" data-src="http://upload-images.jianshu.io/upload_images/2144614-9b9e9406b075d68a.gif?imageMogr2/auto-orient/strip" alt="LXFTextBrush"></p>
<p>矩形 LXFRectangleBrush</p>
<p><img src= "/img/loading.gif" data-src="http://upload-images.jianshu.io/upload_images/2144614-d4bfbe94682acafb.gif?imageMogr2/auto-orient/strip" alt="LXFRectangleBrush"></p>
<p>马赛克 LXFMosaicBrush<br><img src= "/img/loading.gif" data-src="http://upload-images.jianshu.io/upload_images/2144614-a0d920442de28de4.gif?imageMogr2/auto-orient/strip" alt="LXFMosaicBrush"></p>
<p>撤销与反撤销<br><img src= "/img/loading.gif" data-src="http://upload-images.jianshu.io/upload_images/2144614-5e0390d0baff8047.gif?imageMogr2/auto-orient/strip" alt="撤销与反撤销"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>iOS项目</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗</title>
    <url>/2017/09/12/iOS-Swift-UIButton%E4%B8%ADImageView%E7%9A%84animationImages%E5%8A%A8%E7%94%BB%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E5%9B%BE%E6%A0%87%E5%8F%98%E6%9A%97/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>查看官方文档的说明 当该属性设置为true时，按钮在高亮状态下，图片会绘制成高亮（前提是没有手动设置高亮图片）。并且该值的默认值为true<br>所以我们也可以将属性adjustsImageWhenHighlighted设置为false，不让系统自动帮我们设置高亮状态下显示的图片即可。</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h2><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗/1.gif" alt="变暗"><br>贴出重要代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置按钮图片动画数组</span></span><br><span class="line">voiceButton.imageView?.animationImages = [</span><br><span class="line">    #imageLiteral(resourceName: <span class="string">"message_voice_sender_playing_1"</span>),</span><br><span class="line">    #imageLiteral(resourceName: <span class="string">"message_voice_sender_playing_2"</span>),</span><br><span class="line">    #imageLiteral(resourceName: <span class="string">"message_voice_sender_playing_3"</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始动画</span></span><br><span class="line">voiceButton.imageView?.startAnimating()</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 停止动画</span></span><br><span class="line">voiceButton.imageView?.stopAnimating()</span><br></pre></td></tr></table></figure>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这个按钮在结束动画之后之所以会变暗，是因为它在动画结束之后自动显示为高亮图片，不信？那只好上证据了~<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置语音按钮的高亮图片</span></span><br><span class="line">voiceButton.setImage(#imageLiteral(resourceName: <span class="string">"message_voice_sender_normal"</span>), <span class="keyword">for</span>: .highlighted)</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗/2.gif" alt=""></p>
<p>那知道原因之后就很好解决了</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：设置按钮的高亮图片"><a href="#方案一：设置按钮的高亮图片" class="headerlink" title="方案一：设置按钮的高亮图片"></a>方案一：设置按钮的高亮图片</h3><p>将按钮的高亮图片与普通状态下的一致即可。这里就再赘述了</p>
<h3 id="方案二：adjustsImageWhenHighlighted-false"><a href="#方案二：adjustsImageWhenHighlighted-false" class="headerlink" title="方案二：adjustsImageWhenHighlighted = false"></a>方案二：adjustsImageWhenHighlighted = false</h3><p>在UIButton中有这么一个属性<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">adjustsImageWhenHighlighted</span><br></pre></td></tr></table></figure><br>查看官方文档的说明<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗/3.png" alt=""><br>当该属性设置为true时，按钮在高亮状态下，图片会绘制成高亮（前提是没有手动设置高亮图片）。并且该值的默认值为true<br>所以我们也可以将属性adjustsImageWhenHighlighted设置为false，不让系统自动帮我们设置高亮状态下显示的图片即可。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗/4.gif" alt="完美"></p>
<p>附上相关项目：<a href="https://github.com/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">Swift 3.0 高仿微信</a></p>
<div class="github-widget" data-repo="LinXunFeng/LXFWeChat"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - Swift UICollectionView横向分页滚动，cell左右排版</title>
    <url>/2017/09/12/iOS-Swift-UICollectionView%E6%A8%AA%E5%90%91%E5%88%86%E9%A1%B5%E6%BB%9A%E5%8A%A8%EF%BC%8Ccell%E5%B7%A6%E5%8F%B3%E6%8E%92%E7%89%88/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>最近在做表情键盘时遇到一个问题，我用UICollectionView来布局表情，使用横向分页滚动，但在最后一页出现了如图所示的情况</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h2><p>最近在做表情键盘时遇到一个问题，我用UICollectionView来布局表情，使用横向分页滚动，但在最后一页出现了如图所示的情况<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UICollectionView横向分页滚动，cell左右排版/1.png" alt="只显示一半"></p>
<h3 id="情况分析图"><a href="#情况分析图" class="headerlink" title="情况分析图"></a>情况分析图</h3><p>是的，现在的item分布就是这个鬼样子<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UICollectionView横向分页滚动，cell左右排版/2.jpeg" alt="从上到下，从左到右"><br>现在想要做的，就是将现在这个鬼样子变成另外一种样子，如图<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UICollectionView横向分页滚动，cell左右排版/3.jpeg" alt="从左到右，从上到下"><br>那怎么办？只好重新布局item了</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我是自定了一个Layout(LXFChatEmotionCollectionLayout)，让UICollectionView在创建的时候使用了它</p>
<p>在 LXFChatEmotionCollectionLayout.swift 中</p>
<h3 id="添加一个属性来保存所有item的attributes"><a href="#添加一个属性来保存所有item的attributes" class="headerlink" title="添加一个属性来保存所有item的attributes"></a>添加一个属性来保存所有item的attributes</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存所有item的attributes</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> attributesArr: [<span class="type">UICollectionViewLayoutAttributes</span>] = []</span><br></pre></td></tr></table></figure>
<h3 id="重新布局"><a href="#重新布局" class="headerlink" title="重新布局"></a>重新布局</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK:- 重新布局</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.prepare()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> itemWH: <span class="type">CGFloat</span> = kScreenW / <span class="type">CGFloat</span>(kEmotionCellNumberOfOneRow)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置itemSize</span></span><br><span class="line">    itemSize = <span class="type">CGSize</span>(width: itemWH, height: itemWH)</span><br><span class="line">    minimumLineSpacing = <span class="number">0</span></span><br><span class="line">    minimumInteritemSpacing = <span class="number">0</span></span><br><span class="line">    scrollDirection = .horizontal</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置collectionView属性</span></span><br><span class="line">    collectionView?.isPagingEnabled = <span class="literal">true</span></span><br><span class="line">    collectionView?.showsHorizontalScrollIndicator = <span class="literal">false</span></span><br><span class="line">    collectionView?.showsVerticalScrollIndicator = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> insertMargin = (collectionView!.bounds.height - <span class="number">3</span> * itemWH) * <span class="number">0.5</span></span><br><span class="line">    collectionView?.contentInset = <span class="type">UIEdgeInsetsMake</span>(insertMargin, <span class="number">0</span>, insertMargin, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 重点在这里</span></span><br><span class="line">    <span class="keyword">var</span> page = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> itemsCount = collectionView?.numberOfItems(inSection: <span class="number">0</span>) ?? <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> itemIndex <span class="keyword">in</span> <span class="number">0</span>..&lt;itemsCount &#123;</span><br><span class="line">        <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: itemIndex, section: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">let</span> attributes = <span class="type">UICollectionViewLayoutAttributes</span>(forCellWith: indexPath)</span><br><span class="line">        </span><br><span class="line">        page = itemIndex / (kEmotionCellNumberOfOneRow * kEmotionCellRow)</span><br><span class="line">        <span class="comment">// 通过一系列计算, 得到x, y值</span></span><br><span class="line">        <span class="keyword">let</span> x = itemSize.width * <span class="type">CGFloat</span>(itemIndex % <span class="type">Int</span>(kEmotionCellNumberOfOneRow)) + (<span class="type">CGFloat</span>(page) * kScreenW)</span><br><span class="line">        <span class="keyword">let</span> y = itemSize.height * <span class="type">CGFloat</span>((itemIndex - page * kEmotionCellRow * kEmotionCellNumberOfOneRow) / kEmotionCellNumberOfOneRow)</span><br><span class="line">        </span><br><span class="line">        attributes.frame = <span class="type">CGRect</span>(x: x, y: y, width: itemSize.width, height: itemSize.height)</span><br><span class="line">        <span class="comment">// 把每一个新的属性保存起来</span></span><br><span class="line">        attributesArr.append(attributes)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回所有当前可见的Attributes"><a href="#返回所有当前可见的Attributes" class="headerlink" title="返回所有当前可见的Attributes"></a>返回所有当前可见的Attributes</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForElements</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; [<span class="type">UICollectionViewLayoutAttributes</span>]? &#123;</span><br><span class="line">    <span class="keyword">var</span> rectAttributes: [<span class="type">UICollectionViewLayoutAttributes</span>] = []</span><br><span class="line">    <span class="number">_</span> = attributesArr.<span class="built_in">map</span>(&#123;</span><br><span class="line">        <span class="keyword">if</span> rect.<span class="built_in">contains</span>($<span class="number">0</span>.frame) &#123;</span><br><span class="line">            rectAttributes.append($<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> rectAttributes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UICollectionView横向分页滚动，cell左右排版/4.gif" alt=""></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> kEmotionCellNumberOfOneRow = <span class="number">8</span></span><br><span class="line"><span class="keyword">let</span> kEmotionCellRow = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LXFChatEmotionCollectionLayout</span>: <span class="title">UICollectionViewFlowLayout</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存所有item</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> attributesArr: [<span class="type">UICollectionViewLayoutAttributes</span>] = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK:- 重新布局</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.prepare()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> itemWH: <span class="type">CGFloat</span> = kScreenW / <span class="type">CGFloat</span>(kEmotionCellNumberOfOneRow)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置itemSize</span></span><br><span class="line">        itemSize = <span class="type">CGSize</span>(width: itemWH, height: itemWH)</span><br><span class="line">        minimumLineSpacing = <span class="number">0</span></span><br><span class="line">        minimumInteritemSpacing = <span class="number">0</span></span><br><span class="line">        scrollDirection = .horizontal</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置collectionView属性</span></span><br><span class="line">        collectionView?.isPagingEnabled = <span class="literal">true</span></span><br><span class="line">        collectionView?.showsHorizontalScrollIndicator = <span class="literal">false</span></span><br><span class="line">        collectionView?.showsVerticalScrollIndicator = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> insertMargin = (collectionView!.bounds.height - <span class="number">3</span> * itemWH) * <span class="number">0.5</span></span><br><span class="line">        collectionView?.contentInset = <span class="type">UIEdgeInsetsMake</span>(insertMargin, <span class="number">0</span>, insertMargin, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> page = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> itemsCount = collectionView?.numberOfItems(inSection: <span class="number">0</span>) ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> itemIndex <span class="keyword">in</span> <span class="number">0</span>..&lt;itemsCount &#123;</span><br><span class="line">            <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: itemIndex, section: <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">let</span> attributes = <span class="type">UICollectionViewLayoutAttributes</span>(forCellWith: indexPath)</span><br><span class="line">            </span><br><span class="line">            page = itemIndex / (kEmotionCellNumberOfOneRow * kEmotionCellRow)</span><br><span class="line">            <span class="comment">// 通过一系列计算, 得到x, y值</span></span><br><span class="line">            <span class="keyword">let</span> x = itemSize.width * <span class="type">CGFloat</span>(itemIndex % <span class="type">Int</span>(kEmotionCellNumberOfOneRow)) + (<span class="type">CGFloat</span>(page) * kScreenW)</span><br><span class="line">            <span class="keyword">let</span> y = itemSize.height * <span class="type">CGFloat</span>((itemIndex - page * kEmotionCellRow * kEmotionCellNumberOfOneRow) / kEmotionCellNumberOfOneRow)</span><br><span class="line">            </span><br><span class="line">            attributes.frame = <span class="type">CGRect</span>(x: x, y: y, width: itemSize.width, height: itemSize.height)</span><br><span class="line">            <span class="comment">// 把每一个新的属性保存起来</span></span><br><span class="line">            attributesArr.append(attributes)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForElements</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; [<span class="type">UICollectionViewLayoutAttributes</span>]? &#123;</span><br><span class="line">        <span class="keyword">var</span> rectAttributes: [<span class="type">UICollectionViewLayoutAttributes</span>] = []</span><br><span class="line">        <span class="number">_</span> = attributesArr.<span class="built_in">map</span>(&#123;</span><br><span class="line">            <span class="keyword">if</span> rect.<span class="built_in">contains</span>($<span class="number">0</span>.frame) &#123;</span><br><span class="line">                rectAttributes.append($<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> rectAttributes</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附上相关项目：<a href="https://github.com/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">Swift 3.0 高仿微信</a></p>
<div class="github-widget" data-repo="LinXunFeng/LXFWeChat"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-Swift-UICollectionView横向分页的问题</title>
    <url>/2017/09/12/iOS-Swift-UICollectionView%E6%A8%AA%E5%90%91%E5%88%86%E9%A1%B5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>有两种方式可以解决，数据只有11个，要分两页需要16个，那我们可以直接添加数据到16个，然后在dataSource中返回cell时进行判断及处理即可。不过对于现在来说太小题大做了，我选第二种方式~</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h1 id="UICollectionView横向分页的问题"><a href="#UICollectionView横向分页的问题" class="headerlink" title="UICollectionView横向分页的问题"></a>UICollectionView横向分页的问题</h1><h2 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h2><p>直接看图<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UICollectionView横向分页的问题/1.png" alt="滚前"><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UICollectionView横向分页的问题/2.png" alt="滚后"><br>已经设置collectionView的isPagingEnabled为true了，可是出现了这种情况，原因就是collectionView的contentSize不够。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;UICollectionView: 0x7fc565076000; </span><br><span class="line">frame &#x3D; (0 0; 375 197); </span><br><span class="line">clipsToBounds &#x3D; YES; </span><br><span class="line">gestureRecognizers &#x3D; &lt;NSArray: 0x6180000557e0&gt;; </span><br><span class="line">layer &#x3D; &lt;CALayer: 0x61000022a5a0&gt;; </span><br><span class="line">contentOffset: &#123;187.5, 0&#125;; </span><br><span class="line">contentSize: &#123;562.5, 192.25&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有两种方式可以解决，数据只有11个，要分两页需要16个，那我们可以直接添加数据到16个，然后在dataSource中返回cell时进行判断及处理即可。不过对于现在来说太小题大做了，我选第二种方式~</p>
<h3 id="直接修改contentSize"><a href="#直接修改contentSize" class="headerlink" title="直接修改contentSize"></a>直接修改contentSize</h3><p>我自定义了一个继承于UICollectionViewFlowLayout的Layout(LXFChatMoreCollectionLayout)，让UICollectionView在创建的时候使用了它</p>
<p>在 LXFChatMoreCollectionLayout.swift 中我们需要重写父类的collectionViewContentSize，将contentSize取出来修改为我们自己创建的newSize就可以了代码如下<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> collectionViewContentSize: <span class="type">CGSize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> size: <span class="type">CGSize</span> = <span class="keyword">super</span>.collectionViewContentSize</span><br><span class="line">    <span class="keyword">let</span> collectionViewWidth: <span class="type">CGFloat</span> = <span class="keyword">self</span>.collectionView!.frame.size.width</span><br><span class="line">    <span class="keyword">let</span> nbOfScreen: <span class="type">Int</span> = <span class="type">Int</span>(ceil(size.width / collectionViewWidth))</span><br><span class="line">    <span class="keyword">let</span> newSize: <span class="type">CGSize</span> = <span class="type">CGSize</span>(width: collectionViewWidth * <span class="type">CGFloat</span>(nbOfScreen), height: size.height)</span><br><span class="line">    <span class="keyword">return</span> newSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注：ceil函数的作用是求不小于给定实数的最小整数。ceil(2)=ceil(1.2)=cei(1.5)=2.00</p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UICollectionView横向分页的问题/3.png" alt=""></p>
<p>至于如何让item水平布局，请参考<a href="/2017/09/12/[iOS - Swift UICollectionView横向分页滚动，cell左右排版](http://linxunfeng.top/2017/09/12/iOS-Swift-UICollectionView横向分页滚动，cell左右排版/">《iOS - Swift UICollectionView横向分页滚动，cell左右排版》</a></p>
<p>附上相关项目：<a href="https://github.com/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">Swift 3.0 高仿微信</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - Swift UITableView的scrollToRow的坑</title>
    <url>/2017/09/12/iOS-Swift-UITableView%E7%9A%84scrollToRow%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>今天鄙人使用SnapKit来布局cell，然后用scrollToRow来滚到底部就遇到了一个很奇葩的现象。<br>我设置了在键盘弹出后聊天消息列表会自动滚到底部。<br>1.随便输入一条消息，点发送后，在聊天消息列表中并没有滚到最新消息那一行。<br>2.退出键盘不做任何操作再打开键盘也是滚到刚才那里(即最新消息的上一条所在位置)<br>3.只有在退出键盘后把聊天消息列表的消息向上拉一点距离露出最新消息所在的cell之后，再点击才有用</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在tableView中，我们一般会用到scrollToRow这个来控制tableView滚到指定的某一行。一般写法如下所示<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: 滚到底部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollToBottom</span><span class="params">(animated: Bool = <span class="literal">false</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> dataArr.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tableView.scrollToRow(at: <span class="type">IndexPath</span>(row: dataArr.<span class="built_in">count</span> - <span class="number">1</span>, section: <span class="number">0</span>), at: .bottom, animated: animated)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h2><p>今天鄙人使用SnapKit来布局cell，然后用scrollToRow来滚到底部就遇到了一个很奇葩的现象。<br>我设置了在键盘弹出后聊天消息列表会自动滚到底部。<br>1.随便输入一条消息，点发送后，在聊天消息列表中并没有滚到最新消息那一行。<br>2.退出键盘不做任何操作再打开键盘也是滚到刚才那里(即最新消息的上一条所在位置)<br>3.只有在退出键盘后把聊天消息列表的消息向上拉一点距离露出最新消息所在的cell之后，再点击才有用<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UITableView的scrollToRow的&quot;坑&quot;/1.gif" alt=""></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在无奈之下，经过了一步步的探索，终于发现了问题的所在<br>首先我们要了解一下scrollToRow执行后会调用哪些函数及顺序<br><strong>会调用这两个方法</strong><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView, heightForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure></p>
<h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>我在 heightForRow 中写了具体的数据，也就是把高度写死，不再是动态获取。接着执行程序得到如下结果<br>比如我原本有10条数据，现在加入了一条后执行了scrollToRow，它会<br>1.先调用 heightForRow 11次，<strong>即包括最新加入的那一条</strong><br>2.然后再调用 cellForRow<br>3.最后在调一次 heightForRow<br>后面的2和3是针对最新消息的</p>
<h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>我在 heightForRow 中不再写死高度，而是从模型数据中动态获取高度(高度是在cell布局后获取的，再赋值到模型数据中的cellHeight变量)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行程序得到这个结果：调用 heightForRow 11次，然后就没了</span><br></pre></td></tr></table></figure><br>好吧，问题就出现在对heightForRow的第11次调用，前10次都有返回具体的高度，而最后一次是0~。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>现在清楚了，要想在调用 scrollToRow 到指定的那一行，前提条件是那一行的高度不能为0。</strong><br>所以在上面的情况中，发送完消息后，最新消息的cell的确是插入到了tableView，也有显示出来(后面我自己测的)，但就是无法滚到最新消息那一行，就是因为 heightForRow 返回的高度为0<br>在上面的情况中，向上拉一点距离露出cell后scrollToRow才有效就是因为此时heightForRow返回的高度不再为0</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>按本人自身的情况来说，有两种解决方法</p>
<h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>在传入的模型数据中给予明确计算出来的数值就好。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>我使用SnapKit来自动布局cell的位置然后再来获取高度，这做法主要就是为了避免运算。所以我不选用第一种解决方法<br>好了，方法如下：<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataArr是用来存放模型的数组</span></span><br><span class="line"><span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: dataArr.<span class="built_in">count</span> - <span class="number">1</span>, section: <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 调用tableView的数据源办法</span></span><br><span class="line"><span class="number">_</span> = <span class="keyword">self</span>.tableView(tableView, cellForRowAt: indexPath)</span><br></pre></td></tr></table></figure><br>在插入最新消息后，调用tableView的数据源方法来让它先对cell进行布局，这样就获取到了cell的高度，然后再执行 scrollToRow 就好了。<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-UITableView的scrollToRow的&quot;坑&quot;/2.gif" alt="完美"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-Swift 仿微信聊天图片显示</title>
    <url>/2017/09/12/iOS-Swift-%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>其实原理比较简单，准备一张图片MaskImgae，先对其进行拉伸，然后按照其轮廓对图片进行裁剪就行了</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>如图所示，图片左侧有个小箭头<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift 仿微信聊天图片显示/1.png" alt="效果图"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>其实原理比较简单，准备一张图片MaskImgae，先对其进行拉伸，然后按照其轮廓对图片进行裁剪就行了<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift 仿微信聊天图片显示/2.png" alt="MaskImgae"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>这里摘重点说，布局什么的按自己意愿去弄吧。我固定了图片的显示大小为 102 * 152</p>
<h3 id="1、对MaskImgae进行拉伸"><a href="#1、对MaskImgae进行拉伸" class="headerlink" title="1、对MaskImgae进行拉伸"></a>1、对MaskImgae进行拉伸</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置拉伸范围</span></span><br><span class="line"><span class="keyword">let</span> stretchInsets = <span class="type">UIEdgeInsetsMake</span>(<span class="number">30</span>, <span class="number">28</span>, <span class="number">23</span>, <span class="number">28</span>)</span><br><span class="line"><span class="comment">// 待拉伸的图片</span></span><br><span class="line"><span class="keyword">let</span> stretchImage = <span class="type">UIImage</span>(named: <span class="string">"SenderImageNodeMask"</span>)</span><br><span class="line"><span class="comment">// 进行拉伸</span></span><br><span class="line"><span class="keyword">let</span> bubbleMaskImage = stretchImage.resizableImage(withCapInsets: stretchInsets, resizingMode: .stretch)</span><br></pre></td></tr></table></figure>
<p>拉伸的效果如图<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift 仿微信聊天图片显示/3.png" alt="拉伸效果"></p>
<h3 id="2、对imageView设置裁剪区域"><a href="#2、对imageView设置裁剪区域" class="headerlink" title="2、对imageView设置裁剪区域"></a>2、对imageView设置裁剪区域</h3><p>这里我的 imageView 叫   chatImgView<br>上面的拉伸效果图是临时把拉伸好的图片赋值给了chatImgView，只是为了给大家看到效果而已，各位看官如果有赋值请记得改回来~~</p>
<p><strong>好，下面进行裁剪</strong><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个图层</span></span><br><span class="line"><span class="keyword">let</span> layer = <span class="type">CALayer</span>()</span><br><span class="line"><span class="comment">// 设置图层显示的内容为拉伸过的MaskImgae</span></span><br><span class="line">layer.contents = bubbleMaskImage.cgImage</span><br><span class="line"><span class="comment">// 设置拉伸范围(注意：这里contentsCenter的CGRect是比例（不是绝对坐标）)</span></span><br><span class="line">layer.contentsCenter = <span class="keyword">self</span>.<span class="type">CGRectCenterRectForResizableImage</span>(bubbleMaskImage)</span><br><span class="line"><span class="comment">// 设置图层大小与chatImgView相同</span></span><br><span class="line">layer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">102</span>, height: <span class="number">152</span>)</span><br><span class="line"><span class="comment">// 设置比例</span></span><br><span class="line">layer.contentsScale = <span class="type">UIScreen</span>.main.scale</span><br><span class="line"><span class="comment">// 设置不透明度</span></span><br><span class="line">layer.opacity = <span class="number">1</span></span><br><span class="line"><span class="comment">// 设置裁剪范围</span></span><br><span class="line"><span class="keyword">self</span>.chatImgView.layer.mask = layer</span><br><span class="line"><span class="comment">// 设置裁剪掉超出的区域</span></span><br><span class="line"><span class="keyword">self</span>.chatImgView.layer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CGRectCenterRectForResizableImage</span><span class="params">(<span class="number">_</span> image: UIImage)</span></span> -&gt; <span class="type">CGRect</span> &#123;</span><br><span class="line">    <span class="comment">// LXFLog("\(image.capInsets)")</span></span><br><span class="line">    <span class="comment">// 这里的image.capInsets就是UIEdgeInsetsMake(30, 28, 23, 28)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">CGRect</span>(</span><br><span class="line">        x: image.capInsets.<span class="keyword">left</span> / image.size.width,</span><br><span class="line">        y: image.capInsets.top / image.size.height,</span><br><span class="line">        width: (image.size.width - image.capInsets.<span class="keyword">right</span> - image.capInsets.<span class="keyword">left</span>) / image.size.width,</span><br><span class="line">        height: (image.size.height - image.capInsets.bottom - image.capInsets.top) / image.size.height</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样就完成了</p>
<h2 id="解释一下下"><a href="#解释一下下" class="headerlink" title="解释一下下"></a>解释一下下</h2><h3 id="UIEdgeInsetsMake"><a href="#UIEdgeInsetsMake" class="headerlink" title="UIEdgeInsetsMake"></a>UIEdgeInsetsMake</h3><p>MaskImgae 的大小为 56 * 50<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIEdgeInsetsMake(top: CGFloat, left: CGFloat, bottom: CGFloat, right: CGFloat)</span></span><br><span class="line"><span class="type">UIEdgeInsetsMake</span>(<span class="number">30</span>, <span class="number">28</span>, <span class="number">23</span>, <span class="number">28</span>)</span><br></pre></td></tr></table></figure><br>红色范围就是要拉伸的范围(随手一扣，不太准确，意思意思下就好了~~)<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift 仿微信聊天图片显示/4.png" alt="拉伸区域"></p>
<h3 id="contentsCenter"><a href="#contentsCenter" class="headerlink" title="contentsCenter"></a>contentsCenter</h3><p>这是对某个区域进行全面拉伸，如果不设置的话默认值为<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">1</span>, height: <span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>就是直接进行缩放<br>那我们先来看看，如果不对contentsCenter这个值进行设置会是什么效果<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift 仿微信聊天图片显示/5.png" alt="直接拉伸"><br>我们来看下官方解释</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contentsCenter: <span class="type">CGRect</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"><span class="type">Description</span>	</span><br><span class="line"><span class="type">The</span> rectangle that defines how the layer contents are scaled</span><br><span class="line"><span class="keyword">if</span> the layer’s contents are resized. <span class="type">Animatable</span>.</span><br></pre></td></tr></table></figure>
<p>翻译：如果图层的内容是重新设置了尺寸的，那定义的这个矩形(contentsCenter)是为了告诉图层，图层的内容是如何被缩放的</p>
<p>那明了，我们的图片是被拉伸后再绘制到layer上的，为了正确显示我们的图片，我们得告诉layer它是怎么被进行拉伸的。是的，就是下面代码所指定的范围<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIEdgeInsetsMake</span>(<span class="number">30</span>, <span class="number">28</span>, <span class="number">23</span>, <span class="number">28</span>)</span><br></pre></td></tr></table></figure><br>但是，正如上面提到过的，contentsCenter所要赋值的CGRect是比例，不是绝对坐标，所以现在我们得通过(30, 28, 23, 28)获取比例值，转换方法已经在上面给出了，就是CGRectCenterRectForResizableImage<br>我们来打印下 image.capInsets的内容<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFLog</span>(<span class="string">"\(image.capInsets)"</span>)</span><br><span class="line"><span class="type">LXFLog</span>(<span class="string">"\(image.capInsets.top)"</span>)</span><br><span class="line"><span class="type">LXFLog</span>(<span class="string">"\(image.capInsets.bottom)"</span>)</span><br><span class="line"><span class="type">LXFLog</span>(<span class="string">"\(image.capInsets.left)"</span>)</span><br><span class="line"><span class="type">LXFLog</span>(<span class="string">"\(image.capInsets.right)"</span>)</span><br></pre></td></tr></table></figure><br>打印结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIEdgeInsets(top: 30.0, left: 28.0, bottom: 23.0, right: 28.0)</span><br><span class="line">30.0</span><br><span class="line">23.0</span><br><span class="line">28.0</span><br><span class="line">28.0</span><br></pre></td></tr></table></figure><br>好，现在结合 下面的图 与 CGRectCenterRectForResizableImage 方法中的代码就很明确比例是怎么取到的了<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift 仿微信聊天图片显示/6.png" alt="拉伸区域"></p>
<p>附上相关项目：<a href="https://github.com/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">Swift 3.0 高仿微信</a></p>
<div class="github-widget" data-repo="LinXunFeng/LXFWeChat"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - Swift 面向协议编程（一）</title>
    <url>/2017/09/12/iOS-Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>传统的面向对象开发思维方式是将类中实现的相似方法抽取出来，接着放入一个Base类，然后继承于Base类后各个类即可找拥有相同的方法，不用再一个个手动实现。<br>比如：一个Person类，一个Dog类，它们都拥有方法eat，那么就可以新建一个Animal类，将eat方法抽取出来放入其中，然后将Person类和Dog类都继承于Animal。<br>但是，如果现在又有一个Robot类，也需要拥有eat方法，而此时也将其继承于Animal的话显然是不合理的，于是我们就需要转换思维，面向协议开发~</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>OC无法做到面向协议开发，而Swift可以，因为Swift可以做到协议方法的具体实现，而OC不行</p>
</blockquote>
<h2 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h2><p>传统的面向对象开发思维方式是将类中实现的相似方法抽取出来，接着放入一个Base类，然后继承于Base类后各个类即可找拥有相同的方法，不用再一个个手动实现。<br>比如：一个Person类，一个Dog类，它们都拥有方法eat，那么就可以新建一个Animal类，将eat方法抽取出来放入其中，然后将Person类和Dog类都继承于Animal。<br>但是，如果现在又有一个Robot类，也需要拥有eat方法，而此时也将其继承于Animal的话显然是不合理的，于是我们就需要转换思维，面向协议开发~</p>
<h2 id="面向协议开发"><a href="#面向协议开发" class="headerlink" title="面向协议开发"></a>面向协议开发</h2><p>面向协议开发的核心是：<strong> 模块化（组件化） </strong><br>我们先来回顾下协议的一般使用，新建一个Swift文件LXFProtocol.swift<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">protocol LXFProtocol &#123;</span><br><span class="line">    func eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们的Person类遵守协议LXFProtocol，需要我们实现协议中的方法，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person: NSObject, LXFProtocol &#123;</span><br><span class="line">    func eat() &#123;</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那我们每个类都这样做的话跟直接复制粘贴代码并没什么不同~~<br>而开头已经提到一点：</p>
<blockquote>
<p>Swift可以做到协议方法的具体实现</p>
</blockquote>
<p>那么现在，我们新建一个Swift文件Eatable.swift，以区分LXFProtocol.swift<br>Eatable.swift中的代码实现如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">protocol Eatable &#123;</span><br><span class="line">    &#x2F;&#x2F; 可声明变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Eatable &#123;</span><br><span class="line">    func eat() &#123;</span><br><span class="line">        &#x2F;&#x2F; 实现具体的功能</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有2个注意点</p>
<ul>
<li>protocol中可以声明变量，方便在协议方法中使用</li>
<li>协议方法的具体实现需要在extension中来实现</li>
</ul>
<p>使Dog类遵守Eatable<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Dog: NSObject, Eatable &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样我们就可以在其它地方轻松调用dog的eat方法，Person类与Robot类也是如法炮制<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift-面向协议编程（一）/1.png" alt=""></p>
<p>至此，我们就可以通过面向协议的方式给类定制不同的功能，也就是模块化。可以发现Swift的面向协议编程跟c++的多继承很相似</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>现在的这个Eatable协议是可以被任意遵守的，如果我们有这么个需求，我们创建的协议只是被UIViewController遵守，那我们该怎么做呢？<br>【当然，Eatable协议只能被UIViewController遵守很扯淡，这里只是举例，不要太在意咯~~】</p>
<blockquote>
<p>在 extension 后面加上约束关键字【where】，并注明该协议只能被UIViewController这个类（包括子类）所遵守，而且此时我们还可以拿到遵守该协议的控制器的view</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;import Foundation</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">protocol Eatable &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Eatable where Self : UIViewController &#123;</span><br><span class="line">    func eat() &#123;</span><br><span class="line">        view.backgroundColor &#x3D; UIColor.red</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/LinXunFeng/LXFPOP" target="_blank" rel="noopener">Demo</a><br>接下来以一个实际应用来巩固下吧 <a href="/2017/09/12/iOS-Swift-面向协议编程（二）/">iOS - Swift 面向协议编程（二）</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-Swift面向协议编程（二）</title>
    <url>/2017/09/12/iOS-Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>上一篇文章<a href="/2017/09/12/iOS-Swift-面向协议编程（一）/">iOS - Swift 面向协议编程（一）
</a>已经对Swift的面向协议编程做了介绍，接下来该篇文章将使用面向协议开发(POP)来做下实际的应用</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>上一篇文章<a href="/2017/09/12/iOS-Swift-面向协议编程（一）/">iOS - Swift 面向协议编程（一）
</a>已经对Swift的面向协议编程做了介绍，接下来该篇文章将使用面向协议开发(POP)来做下实际的应用</p>
</blockquote>
<p>在实际开发中，自定义View基本上是必须的，相信这对我们来说都是比较简单，不过我们还是来回顾一下下~</p>
<h2 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h2><p>1 新建一个UIView的FirstTypeView<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift面向协议编程（二）/1.png" alt="FirstTypeView"></p>
<p>2 创建一个View的xib文件<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift面向协议编程（二）/2.png" alt="xib"><br>3 设置xib对应的class进行绑定</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift面向协议编程（二）/3.png" alt="xib class"></p>
<p>4 在FirstTypeView.swift 中实现一个类方法，方便我们外部用xib来初始化FirstTypeView<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstTypeView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FirstTypeView</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">loadFromNib</span>() -&gt; <span class="title">FirstTypeView</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.main.loadNibNamed(<span class="string">"\(self)"</span>, owner: <span class="literal">nil</span>, options: <span class="literal">nil</span>)?.first <span class="keyword">as</span>! <span class="type">FirstTypeView</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在外部只要调用FirstTypeView的loadFromNib方法就可以初始化一个View来使用了。好，现在又有一个类SecondTypeView，也是要求使用xib来初始化view。这时我们就会想，一样的加载xib的方法，那我们就把它抽取出来放到父类就可以了。这里的父类以BaseView.swift为例<br>父类的主要实现代码<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BaseView</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">loadFromNib</span>() -&gt; <span class="title">BaseView</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Bundle</span>.main.loadNibNamed(<span class="string">"\(self)"</span>, owner: <span class="literal">nil</span>, options: <span class="literal">nil</span>)?.first <span class="keyword">as</span>! <span class="type">BaseView</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那我们的FirstTypeView和SecondTypeView只需要直接继承于BaseView就可以了，在其它地方初始化view也很方便<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let firstView &#x3D; FirstTypeView.loadFromNib()</span><br><span class="line">view.addSubview(firstView)</span><br><span class="line"></span><br><span class="line">let secondView &#x3D; SecondTypeView.loadFromNib()</span><br><span class="line">view.addSubview(secondView)</span><br></pre></td></tr></table></figure><br>好，现在FirstTypeView里声明了一个属性name，SecondTypeView声明的属性为age，假如我们现在要使用各自对应的属性，这时是直接点不出来的，需要先进行强转<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstView = <span class="type">FirstTypeView</span>.loadFromNib() <span class="keyword">as</span>! <span class="type">FirstTypeView</span></span><br><span class="line">firstView.name = <span class="string">"LXF"</span></span><br><span class="line">view.addSubview(firstView)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondView = <span class="type">SecondTypeView</span>.loadFromNib() <span class="keyword">as</span>! <span class="type">SecondTypeView</span></span><br><span class="line">secondView.age = <span class="number">100</span></span><br><span class="line">view.addSubview(secondView)</span><br></pre></td></tr></table></figure></p>
<p>但是这样觉得不是很方便，还需要进行强转，我们能不能在BaseView里面搞定它呢？如果是Swift 2.x 的话是可以的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension BaseView &#123;</span><br><span class="line">    class func loadFromNib() -&gt; Self &#123; &#x2F;&#x2F; 注意这里是大写的S</span><br><span class="line">        return Bundle.main.loadNibNamed(&quot;\(self)&quot;, owner: nil, options: nil)?.first as! Self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是现在Swift 3.0已经不支持这种写法了，会报错。这个时候如果使用面向协议的开发就很方便了。</p>
<h2 id="面向协议开发"><a href="#面向协议开发" class="headerlink" title="面向协议开发"></a>面向协议开发</h2><blockquote>
<p>将BaseView删除，FirstTypeView和SecondTypeView改回继承于UIView</p>
</blockquote>
<p>1 新建一个Swift文件 Nibloadable.swift<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift面向协议编程（二）/4.png" alt="Nibloadable"></p>
<p>2 实现协议方法</p>
<p><strong>协议中不允许定义类方法，需改为静态方法</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">protocol Nibloadable &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Nibloadable &#123;</span><br><span class="line">    static func loadFromNib() -&gt; Self &#123;</span><br><span class="line">        return Bundle.main.loadNibNamed(&quot;\(self)&quot;, owner: nil, options: nil)?.first as! Self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3 遵守协议<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SecondTypeView: UIView, Nibloadable &#123;</span><br><span class="line">    var age: Int &#x3D; 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以了，而且你在调用loadFromNib方法时可以发现，类型是对应上的</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-Swift面向协议编程（二）/5.png" alt="loadFromNib协议方法"></p>
<p>好了，面向协议开发的应用就记录到这里，希望能帮助到大家！</p>
<p><a href="https://github.com/LinXunFeng/LXFPOP" target="_blank" rel="noopener">Demo</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - Swift 高仿微信</title>
    <url>/2017/09/12/iOS-Swift-%E9%AB%98%E4%BB%BF%E5%BE%AE%E4%BF%A1/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>从2016年12月份开始做到 2017年2月16，虽说这个项目看起来不大，但是锻炼人的地方还真是很多的，微信通讯录联系人的按拼音排序，自定义表情键盘中遇到的分页滚动，微信聊天界面的图片显示、语音信息的动画等。挑战着各种各样的需求，本人也将遇到的问题的解决方案做了记录并整理了一下，希望能给iOS程序员同胞们带来帮助。目前基本的聊天已完成，实现了一部分个人信息的修改，功能我会尽快完善的！</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h1 id="LXFWeChat"><a href="#LXFWeChat" class="headerlink" title="LXFWeChat"></a>LXFWeChat</h1><p>Swift 3.0 高仿微信</p>
<blockquote>
<p>两个测试账号： lxf lqr  密码都是123456 </p>
</blockquote>
<h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>码云<br><a href="http://git.oschina.net/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">http://git.oschina.net/LinXunFeng/LXFWeChat</a></p>
<p>GitHub<br><a href="https://github.com/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">https://github.com/LinXunFeng/LXFWeChat</a></p>
<p>在此提供存放于百度云的完整项目<a href="https://pan.baidu.com/s/1bpB55Bx" target="_blank" rel="noopener">【高仿微信】- 百度云</a><br>希望各位能在我的项目上献出一个宝贵的Star<br>谢谢</p>
<blockquote>
<p>从2016年12月份开始做到现在，虽说这个项目看起来不大，但是锻炼人的地方还真是很多的，微信通讯录联系人的按拼音排序，自定义表情键盘中遇到的分页滚动，微信聊天界面的图片显示、语音信息的动画等。挑战着各种各样的需求，本人也将遇到的问题的解决方案做了记录并整理了一下，希望能给iOS程序员同胞们带来帮助。目前基本的聊天已完成，实现了一部分个人信息的修改，功能我会尽快完善的！</p>
</blockquote>
<h2 id="模仿微信的导航栏"><a href="#模仿微信的导航栏" class="headerlink" title="模仿微信的导航栏"></a>模仿微信的导航栏</h2><p>在navigationBar底部添加一个添加了渐变层的view<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blurBackView = <span class="type">UIView</span>()</span><br><span class="line">blurBackView.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: -<span class="number">20</span>, width: kScreenW, height: <span class="number">64</span>)</span><br><span class="line"><span class="keyword">let</span> gradintLayer = <span class="type">CAGradientLayer</span>()</span><br><span class="line">gradintLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: kScreenW, height: <span class="number">64</span>)</span><br><span class="line">gradintLayer.colors = [</span><br><span class="line">    <span class="type">UIColor</span>.hexInt(<span class="number">0x040012</span>).withAlphaComponent(<span class="number">0.76</span>).cgColor,</span><br><span class="line">    <span class="type">UIColor</span>.hexInt(<span class="number">0x040012</span>).withAlphaComponent(<span class="number">0.28</span>).cgColor</span><br><span class="line">]</span><br><span class="line">gradintLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">gradintLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">blurBackView.layer.addSublayer(gradintLayer)</span><br><span class="line">blurBackView.isUserInteractionEnabled = <span class="literal">false</span></span><br><span class="line">blurBackView.alpha = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置导航栏样式</span></span><br><span class="line">navigationBar.barStyle = .black</span><br><span class="line">navigationBar.insertSubview(blurBackView, at: <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="表情面板和更多面板"><a href="#表情面板和更多面板" class="headerlink" title="表情面板和更多面板"></a>表情面板和更多面板</h2><p>遇到的问题总结了一下，可以参考下以下总结的文章</p>
<p><a href="http://www.jianshu.com/p/18d7d0f5e3e2" target="_blank" rel="noopener">《iOS - Swift UICollectionView横向分页滚动，cell左右排版》</a></p>
<p><a href="http://www.jianshu.com/p/60da3b52d64c" target="_blank" rel="noopener">《iOS-Swift-UICollectionView横向分页的问题》</a></p>
<h2 id="聊天界面"><a href="#聊天界面" class="headerlink" title="聊天界面"></a>聊天界面</h2><p><a href="http://www.jianshu.com/p/4c570cd79bd3" target="_blank" rel="noopener">《iOS-Swift 仿微信聊天图片显示》</a></p>
<p><a href="http://www.jianshu.com/p/aa139463eb4b" target="_blank" rel="noopener">《iOS-Swift-UITableView的scrollToRow的”坑”》</a></p>
<p><a href="http://www.jianshu.com/p/412a2e23b5b6" target="_blank" rel="noopener">《iOS-Swift-UIButton中ImageView的animationImages动画执行完毕后，图标变暗》</a></p>
<h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p><a href="http://www.jianshu.com/p/807cddad469a" target="_blank" rel="noopener">《iOS - Swift 仿微信小红点(无数字)》</a></p>
<h2 id="目前完成的功能"><a href="#目前完成的功能" class="headerlink" title="目前完成的功能"></a>目前完成的功能</h2><h3 id="微信界面"><a href="#微信界面" class="headerlink" title="微信界面"></a>微信界面</h3><ol>
<li>显示右上角的菜单</li>
<li>显示最近联系人</li>
<li>最近联系人信息未读数的显示</li>
</ol>
<h3 id="通讯录界面"><a href="#通讯录界面" class="headerlink" title="通讯录界面"></a>通讯录界面</h3><ol>
<li>联系人的排序</li>
<li>联系人总数显示</li>
</ol>
<h3 id="发现界面"><a href="#发现界面" class="headerlink" title="发现界面"></a>发现界面</h3><ol>
<li>动态小红点的显示</li>
<li>购物选项的链接跳转</li>
</ol>
<h3 id="我界面"><a href="#我界面" class="headerlink" title="我界面"></a>我界面</h3><ol>
<li>个人头像的上传与设置，及头像的保存</li>
<li>我的二维码界面的显示及二维码的保存</li>
</ol>
<h3 id="聊天界面-1"><a href="#聊天界面-1" class="headerlink" title="聊天界面"></a>聊天界面</h3><ol>
<li>小视频的录制与发送</li>
<li>小视频的播放</li>
<li>聊天时间</li>
<li>图片的发送与显示</li>
<li>未发送成功的重发功能</li>
<li>语音的录制与发送</li>
<li>语音的播放动态效果</li>
</ol>
<h2 id="已知BUG"><a href="#已知BUG" class="headerlink" title="已知BUG"></a>已知BUG</h2><ul>
<li>小视频和图片发送出去后不能立即更新显示缩略图</li>
<li>更换头像模拟器测试正常，真机无效。。</li>
</ul>
<h2 id="2017-07-24-更新"><a href="#2017-07-24-更新" class="headerlink" title="2017-07-24 更新"></a>2017-07-24 更新</h2><p>抽空出来添加了一个简单的直播功能（对方需要先进入到对应的聊天界面）<br>相关博文：<a href="http://www.jianshu.com/p/022b9044decc" target="_blank" rel="noopener">iOS-给高仿微信添加直播聊天功能</a><br>需要用到<a href="https://github.com/LinXunFeng/IJKFramework" target="_blank" rel="noopener">编译好的B站开源库ijkplayer</a> ，由于打包好的文件太大，传不上来，所以需要各位去自己编译集成进去。</p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><h3 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h3><p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/1.gif" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/2.gif" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/3.gif" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/4.gif" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/5.gif" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/6.gif" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/7.gif" alt=""></p>
<h3 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h3><p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170206_1.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_1.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_2.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_3.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_4.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_5.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_6.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_7.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_8.png" alt=""><br><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/Snip20170214_9.png" alt=""></p>
<div class="github-widget" data-repo="LinXunFeng/LXFWeChat"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>iOS项目</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - 实现UINavigation全屏动返回(一)</title>
    <url>/2017/09/11/iOS-%E5%AE%9E%E7%8E%B0UINavigation%E5%85%A8%E5%B1%8F%E5%8A%A8%E8%BF%94%E5%9B%9E-%E4%B8%80/</url>
    <content><![CDATA[<p><Excerpt in index | 首页摘要><br>interactivePopGestureRecognizer 是UINavigationController自带手势，当我们自定义了导航条的返回按钮后，这个手势就自动失效了，也就是说无法滑动返回。<br>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>interactivePopGestureRecognizer 是UINavigationController自带手势，当我们自定义了导航条的返回按钮后，这个手势就自动失效了，也就是说无法滑动返回。</p>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>很多情况下我们不得不自定义导航条的返回按钮，但是我们也要滑动返回上一级的效果。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然自动失效，那我们就告诉它什么时候生效。</p>
<ul>
<li>在非根控制器下生效(用于滑动返回上一级)</li>
<li>在根控制器下失效(防止根控制器被移除，当然系统不会让我们把它移除，只是会出现bug)<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-实现UINavigation全屏动返回-一/1.png" alt="苹果官方文档说明">翻译：第一个被添加的控制器成为永远不会被出栈的根控制器</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>自定义一个 UINavigationController ，即继承于 UINavigationController ，名字为 LXFNavigationController ，将代理设为自己，遵守协议 UINavigationControllerDelegate ，实现代理方法 navigationController:didShowViewController:animated:</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>LXFNavigationController.m</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 系统手势代理 */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> popGesture;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line"> [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录系统手势代理</span></span><br><span class="line">  <span class="keyword">self</span>.popGesture = <span class="keyword">self</span>.interactivePopGestureRecognizer;</span><br><span class="line">  <span class="keyword">self</span>.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - UINavigationControllerDelegate</span></span><br><span class="line"><span class="comment">// 当控制器显示完毕的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)navigationController:(<span class="built_in">UINavigationController</span> *)navigationController didShowViewController:(<span class="built_in">UIViewController</span> *)viewController animated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="comment">// 根据 栈 先进后出</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.viewControllers[<span class="number">0</span>] == viewController) &#123; <span class="comment">// 根控制器</span></span><br><span class="line">        <span class="comment">// 还原代理</span></span><br><span class="line">        <span class="keyword">self</span>.interactivePopGestureRecognizer.delegate = <span class="keyword">self</span>.popGesture;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非控制器</span></span><br><span class="line">        <span class="comment">// 清空手势代理就能实现滑动返回，iOS6不支持</span></span><br><span class="line">        <span class="keyword">self</span>.interactivePopGestureRecognizer.delegate = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前控制器为根控制器，则使手势失效，不然手势会将根控制器移除</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.viewControllers.count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.interactivePopGestureRecognizer.enabled = <span class="literal">NO</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.interactivePopGestureRecognizer.enabled = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-实现UINavigation全屏动返回-一/2.gif" alt="只有左侧边缘滑动才有效"></p>
<p><a href="https://github.com/LinXunFeng/LXFNavigationControllerDemo" target="_blank" rel="noopener">附上Demo</a></p>
<h3 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h3><p>这样就可以了，但是注意了，现在实现的是滑动返回功能，并没有全屏滑动返回~~接下来看下一篇吧<br> <a href="/2017/09/12/iOS-实现UINavigation全屏动返回-二/">iOS - 实现UINavigation全屏滑动返回(二)</a></p>
<div class="github-widget" data-repo="LinXunFeng/LXFNavigationControllerDemo"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - 实现UINavigation全屏动返回(二)</title>
    <url>/2017/09/12/iOS-%E5%AE%9E%E7%8E%B0UINavigation%E5%85%A8%E5%B1%8F%E5%8A%A8%E8%BF%94%E5%9B%9E-%E4%BA%8C/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>在 <a href="/2017/09/11/iOS-实现UINavigation全屏动返回-一">iOS - 实现UINavigation全屏滑动返回(一)</a> 中我们实现了滑动返回的功能，但不是全屏滑动返回，得在左侧边缘轻扫才能滑动返回~UINavigationController自带的只能在边缘轻扫才能滑动返回，这用户体验是不好的，接下来实现全屏滑动返回!</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在 <a href="/2017/09/11/iOS-实现UINavigation全屏动返回-一/">iOS - 实现UINavigation全屏滑动返回(一)</a> 中我们实现了滑动返回的功能，但不是全屏滑动返回，得在左侧边缘轻扫才能滑动返回~UINavigationController自带的只能在边缘轻扫才能滑动返回，这用户体验是不好的，接下来实现全屏滑动返回!</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然自带的滑动返回只能是在边缘，那我们能不能修改使它触摸范围变大甚至全屏呢？先来看下系统手势有没有提供属性或方法供我们使用<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.interactivePopGestureRecognizer);</span><br></pre></td></tr></table></figure><br>打印信息：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;UIScreenEdgePanGestureRecognizer: 0x7fd542611e20; state = Possible;</span></span><br><span class="line"><span class="comment"> delaysTouchesBegan = YES; view = &lt;UILayoutContainerView 0x7fd542706300&gt;; target= </span></span><br><span class="line"><span class="comment">&lt;(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition </span></span><br><span class="line"><span class="comment">0x7fd542611ce0&gt;)&gt;&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>原来系统手势的类型为 UIScreenEdgePanGestureRecognizer ，转到定义，发现有一个属性<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIRectEdge</span> edges</span><br></pre></td></tr></table></figure><br>是个结构体<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIRectEdge</span>) &#123; </span><br><span class="line">   <span class="built_in">UIRectEdgeNone</span> = <span class="number">0</span>,</span><br><span class="line">   <span class="built_in">UIRectEdgeTop</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">   <span class="built_in">UIRectEdgeLeft</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">   <span class="built_in">UIRectEdgeBottom</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">   <span class="built_in">UIRectEdgeRight</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">   <span class="built_in">UIRectEdgeAll</span> = <span class="built_in">UIRectEdgeTop</span> | <span class="built_in">UIRectEdgeLeft</span> | <span class="built_in">UIRectEdgeBottom</span> | <span class="built_in">UIRectEdgeRight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只提供了这几样，都是边缘的，这样就只好另寻他路了。<br>既然没有提供方式给我们现实要求，那我们就自己添加一个拖动手势 UIPanGestureRecognizer来替它执行滑动返回功能。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:target action:<span class="keyword">@selector</span>(handleNavigationTransition:)];</span><br><span class="line">[<span class="keyword">self</span>.view addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure><br>添加一个拖动手势，让他执行系统手势的操作，调用handleNavigationTransition:方法（刚才打印的信息中可以得知），现在的问题就是target是谁？<br>我们可以看看UIScreenEdgePanGestureRecognizer中是否有线索呢？<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIScreenEdgePanGestureRecognizer</span> *gest = <span class="keyword">self</span>.interactivePopGestureRecognizer;</span><br></pre></td></tr></table></figure><br>找了半天没找着，但是UIScreenEdgePanGestureRecognizer继承于UIPanGestureRecognizer，而UIPanGestureRecognizer又继承于UIGestureRecognizer，在UIGestureRecognizer提供的方法中我们可以推断出一定有target，而且还是强引用的私有属性！那我们就可以用OC强大的杀手锏KVC来得到这个属性，但是前提是我们得知道target所指属性是什么名字<br>参照我的另一篇文章：<a href="/2017/09/12/iOS-通过runtime获取某个类中所有的变量和方法">iOS - 通过runtime获取某个类中所有的变量和方法</a><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OC runtime 机制</span></span><br><span class="line"><span class="comment">// 只能动态获取当前类的成员属性，不能获取其子类，或者父类的属性</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">// 拷贝出所胡的成员变量列表</span></span><br><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UIGestureRecognizer</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">   <span class="comment">// 取出成员变量</span></span><br><span class="line">   Ivar ivar = *(ivars + i); </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打印成员变量名字</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivar_getName(ivar)); </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打印成员变量的数据类型</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 释放</span></span><br><span class="line"> free(ivars);</span><br></pre></td></tr></table></figure><br>在打印中我们找到了UIGestureRecognizer的私有属性 _targets，是个数组，而且只有一个元素，元素的类型如图所示<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-实现UINavigation全屏动返回-二/1.png" alt="target"><br>那就好办了，这样我们就可以得到target了<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *targets = [gest valueForKeyPath:<span class="string">@"_targets"</span>]; <span class="comment">// 打印可以发现里面就一个元素</span></span><br><span class="line"><span class="keyword">id</span> target = [targets[<span class="number">0</span>] valueForKeyPath:<span class="string">@"_target"</span>];</span><br></pre></td></tr></table></figure><br>这样我们就差不多实现全屏滑动返回的功能，但是有个bug<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-实现UINavigation全屏动返回-二/2.gif" alt="向右滑动，接着点击Button"><br>如图所示，在最后里回到根控制器界面后我再一次向右滑动，接着点击Button，它没有将FirstVC弹出，这就是传说中的bug，那我们现在在做的，就是在根控制器不让滑动返回生效，即禁用手势。<br>监听手势，遵守协议UIGestureRecognizerDelegate，实现代理方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当当前控制器是是根控制器时不让移除当前控制器(换句话说就是禁止手势)</span></span><br><span class="line">pan.delegate = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - UIGestureRecognizerDelegate<span class="comment">// 当开始滑动时调用</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">   <span class="comment">// 当为根控制器是不让移除当前控制器，非根控制器时允许移除</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.viewControllers.count);</span><br><span class="line">   <span class="built_in">BOOL</span> open = <span class="keyword">self</span>.viewControllers.count &gt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> open;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最后说两句"><a href="#最后说两句" class="headerlink" title="最后说两句"></a>最后说两句</h2><p>这样就可以全屏滑动了，不过让我们来看看我们添加手势的习惯<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIPanGestureRecognizer</span> *myPan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pan)];</span><br><span class="line">[<span class="keyword">self</span>.view addGestureRecognizer:myPan];</span><br><span class="line">myPan.delegate = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure><br>我们在添加手势时设置了target为self，而delegate也为self<br>那是不是可以推断出系统手势的delegate就是我们刚刚想要的target呢，答案是是的<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> target = <span class="keyword">self</span>.interactivePopGestureRecognizer.delegate;</span><br></pre></td></tr></table></figure><br>所以我们的target就可以通过这种方式获得，不用KVC的方式<br>哦，最后别忘了禁用系统手势<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 禁止系统的手势</span></span><br><span class="line"><span class="keyword">self</span>.interactivePopGestureRecognizer.enabled = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure><br>这样，我们就实现了全屏滑动返回的功能了~</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><blockquote>
<p>Objective-C</p>
</blockquote>
<p>记得遵守协议： UIGestureRecognizerDelegate<br>LXFNavigationController.m<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">   [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">   <span class="comment">// 系统的手势</span></span><br><span class="line">   <span class="built_in">UIScreenEdgePanGestureRecognizer</span> *gest = <span class="keyword">self</span>.interactivePopGestureRecognizer;</span><br><span class="line">   <span class="comment">// target</span></span><br><span class="line">   <span class="keyword">id</span> target = <span class="keyword">self</span>.interactivePopGestureRecognizer.delegate;</span><br><span class="line">   <span class="comment">// 禁止系统的手势 </span></span><br><span class="line">   <span class="keyword">self</span>.interactivePopGestureRecognizer.enabled = <span class="literal">NO</span>;</span><br><span class="line">   <span class="built_in">UIPanGestureRecognizer</span> *pan = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:target action:<span class="keyword">@selector</span>(handleNavigationTransition:)];</span><br><span class="line">   [<span class="keyword">self</span>.view addGestureRecognizer:pan]; </span><br><span class="line">   <span class="comment">// 监听代理</span></span><br><span class="line">   pan.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - UIGestureRecognizerDelegate</span></span><br><span class="line"><span class="comment">// 当开始滑动时调用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">   <span class="comment">// 当为根控制器是不让移除当前控制器，非根控制器时允许移除</span></span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="keyword">self</span>.viewControllers.count);</span><br><span class="line">   <span class="built_in">BOOL</span> open = <span class="keyword">self</span>.viewControllers.count &gt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> open;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Swift</p>
</blockquote>
<p>LXFNavigationController.swift<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">    guard let targets &#x3D; interactivePopGestureRecognizer!.value(forKey: &quot;_targets&quot;) as? [NSObject] else &#123; return &#125;</span><br><span class="line">    let targetObjc &#x3D; targets.first</span><br><span class="line">    let target &#x3D; targetObjc?.value(forKey: &quot;target&quot;)</span><br><span class="line">    let action &#x3D; Selector((&quot;handleNavigationTransition:&quot;))</span><br><span class="line">    </span><br><span class="line">    let panGes &#x3D; UIPanGestureRecognizer(target: target, action: action)</span><br><span class="line">    view.addGestureRecognizer(panGes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-揭露Block的内部实现原理</title>
    <url>/2017/09/12/iOS-%E6%8F%AD%E9%9C%B2Block%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>想必大家对block都很熟悉了，虽然都会用，但是你真的知道它的原理吗？比如为什么要加上__block，这个修饰符到底有什么用？不加会有什么后果？block又是如何实现的等等。。。该篇文章就为大家揭晓关于Block的实现原理~</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>想必大家对block都很熟悉了，虽然都会用，但是你真的知道它的原理吗？比如为什么要加上__block，这个修饰符到底有什么用？不加会有什么后果？block又是如何实现的等等。。。该篇文章就为大家揭晓关于Block的实现原理~</p>
</blockquote>
<h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><p>先给出问题，大家思考下结果吧，如果分别调用以下两个方法，结果如何？<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> blockFunc1()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block)() = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"num equal %d"</span>, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> blockFunc2()</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block)() = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"num equal %d"</span>, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>答案是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blockFunc1 : num equal 100</span><br><span class="line">blockFunc2 : num equal 200</span><br></pre></td></tr></table></figure><br>是不是有人答错了？再来两个函数。这两个的结果与blockFunc2一样，打印出来的 num 为 200<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">void</span> blockFunc3()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (^block)() = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"num equal %d"</span>, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> blockFunc4()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (^block)() = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"num equal %d"</span>, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>疑问：<br>我们发现num做为局部变量时加上 _ _block 修饰符、num做为全局变量以及num为静态局部变量时在block中输出结果是一样的，皆为被修改之后的值，而做为局部变量并且未加上__block的num在block中输出的值却还是未赋值之前的值。这是为什么呢？探索这个问题我们就需要看看底层结构是如何实现的了</p>
</blockquote>
<h2 id="探索内部原理"><a href="#探索内部原理" class="headerlink" title="探索内部原理"></a>探索内部原理</h2><p>Objective-C是一个全动态语言，它的一切都是基于runtime实现的！在运行时会将OC转换成C，我们可以利用这个来查看关于block在内部是如何实现的<br>新建一个Command Line Tool项目，将以上代码放入main.m中，如图</p>
<p><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-揭露Block的内部实现原理/1.png" alt="main.m"></p>
<p>这里我们打开终端，cd到项目目录下，然后将用下面的命令将OC重写为C<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-揭露Block的内部实现原理/2.png" alt="rewrite-objc"><br>这时我们可以发现当前目录下多了一个main.cpp文件，打开它并滚到最下面<br><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-揭露Block的内部实现原理/3.png" alt="打开main.cpp"></p>
<p><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-揭露Block的内部实现原理/4.png" alt="main.cpp"><br>这里我们可以看到blockFunc1的C语言实现方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> (*block)() = ((<span class="keyword">void</span> (*)())&amp;__blockFunc1_block_impl_0((<span class="keyword">void</span> *)__blockFunc1_block_func_0, &amp;__blockFunc1_block_desc_0_DATA, num));</span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去掉类型转换<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockFunc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// *************************重点句***********************</span></span><br><span class="line">    <span class="keyword">void</span> (*block)() = &amp;__blockFunc1_block_impl_0(__blockFunc1_block_func_0, &amp;__blockFunc1_block_desc_0_DATA, num));</span><br><span class="line">    <span class="comment">// *****************************************************</span></span><br><span class="line">    num = <span class="number">200</span>;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我们可以看到</p>
<blockquote>
<p>block实际上是指向结构体的指针</p>
</blockquote>
<p>该结构体为<br><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-揭露Block的内部实现原理/5.png" alt="__blockFunc1_block_impl_0"></p>
<p>我们来看下带__block的blockFunc2</p>
<p><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-揭露Block的内部实现原理/6.png" alt="blockFunc2"><br>在 blockFunc1 中，block指向了一个名为<strong>blockFunc1_block_impl_0的结构体，并且在初始化时输入了三个参数(</strong>blockFunc1_block_impl_0最后的flags有默认参数，所以可以不用传参)，第三个参数就是我们写的num，与blockFunc2相比较，这里的num并没有带*号，所以说在这里它只是传值而非传址，而下面的【num = 200;】也就没什么卵用了。这就是blockFunc2、blockFunc3与blockFunc4为什么能打印出num改变后的值，而blockFunc1不行的原因。</p>
<p><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-揭露Block的内部实现原理/7.png" alt=""></p>
<p>在这里我们也可以看出：</p>
<blockquote>
<p>编译器会将block的内部代码生成对应的函数</p>
</blockquote>
<p><strong> SO </strong></p>
<blockquote>
<p>我们总结下，block在内部会作为一个指向结构体的指针，当调用block的时候其实就是根据block对应的指针找到相应的函数，进而进行调用，并传入自身</p>
</blockquote>
<h2 id="block的实现"><a href="#block的实现" class="headerlink" title="__block的实现"></a>__block的实现</h2><p>我们再来看看 _ <em>block，</em> _block也被转换成了结构体，并含有5个变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __Block_byref_num_0 &#123;</span><br><span class="line">  void *__isa;  &#x2F;&#x2F; isa指针</span><br><span class="line">__Block_byref_num_0 *__forwarding;  &#x2F;&#x2F; 实例本身</span><br><span class="line"> int __flags; </span><br><span class="line"> int __size;</span><br><span class="line"> int num;  &#x2F;&#x2F; 我们的num值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-揭露Block的内部实现原理/8.png" alt=""><br>图片对应着blockFunc2中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block int num &#x3D; 100;</span><br></pre></td></tr></table></figure>
<p>当创建num并用<strong>block修饰的时候，会初始化这五个变量<br>当我们执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num &#x3D; 200;</span><br></pre></td></tr></table></figure><br>对应着<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(num.__forwarding-&gt;num) &#x3D; 200;</span><br></pre></td></tr></table></figure><br>上面刚刚提到过 _ _forwarding是实例本身，即类型结构体</strong>Block_byref_num_0的&amp;num，再找到对应的num变量，将其原来的100修改为200~~</p>
<p>到此，关于Block内部实现的揭晓也就到此结束了，希望本文能让你对block有更深的理解，感谢你耐心的阅读！</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-组件化开发（三）：加载资源文件</title>
    <url>/2018/04/06/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>经过前两篇文章的学习，相信对组件化开发有了大致的了解，那我们这篇文章就来讲讲资源文件的加载吧</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>


<blockquote>
<p>经过前两篇文章的学习，相信对组件化开发有了大致的了解，那我们这篇文章就来讲讲资源文件的加载吧</p>
</blockquote>
<p>这里我新建了一个LXFMain组件库，主要是用来显示TabBar的玩意，然后再进行组件化抽离出来，其中的过程这里不再赘述，还没了解过的同学建议先阅读下这两篇文章吧</p>
<p><a href="http://linxunfeng.top/2018/04/06/iOS-组件化开发（一）：远程私有库的基本使用/">iOS-组件化开发（一）：远程私有库的基本使用</a></p>
<p><a href="http://linxunfeng.top/2018/04/06/iOS-组件化开发（二）：远程私有库的更新与子库/">iOS-组件化开发（二）：远程私有库的更新与子库</a></p>
<p>这里跟之前不一样的地方在于多了图片资源，组件的核心代码放在Classes文件夹中，而图片我们则存放于Assets目录下，如图所示 </p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/存放位置.png" alt="存放位置"></p>
<h3 id="一、修改Spec"><a href="#一、修改Spec" class="headerlink" title="一、修改Spec"></a>一、修改Spec</h3><p>将关于资源加载的注释去掉<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.resource_bundles &#x3D; &#123;</span><br><span class="line"> # &#39;LXFMain&#39; &#x3D;&gt; [&#39;LXFMain&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line"> &#39;LXFMain&#39; &#x3D;&gt; [&#39;LXFMain&#x2F;Assets&#x2F;*&#39;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到LXFMain的模板库，我们进行一次本地的安装和测试(<code>pod install</code>)</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/修改Spec-podInstall.png" alt=""></p>
<p>可以看到，图片资源也安装进来了，但是运行的效果如下图，图片并不能成功加载出来</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/没有图标.png" alt="没有图标"></p>
<h2 id="二、修改加载资源代码"><a href="#二、修改加载资源代码" class="headerlink" title="二、修改加载资源代码"></a>二、修改加载资源代码</h2><p>这是当前加载图片的相关代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[UIImage imageNamed:@&quot;图片名称&quot;];</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/showInFinder.png" alt="show in finder"></p>
<p>右击显示包内容<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/LXFMain.framework.png" alt="LXFMain.framework"></p>
<p>图片就在这个<code>LXFMain.bundle</code>里面(这里就不截图看了)，这里主要是让大家对这个目录结构有个了解</p>
<p>我们对<code>imageNamed</code>进行跳转到定义操作<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/imageNamed.png" alt="imageNamed"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; load from main bundle</span><br></pre></td></tr></table></figure>
<p>可以看到，官方注释着<code>imageNamed</code>加载的是main bundle中的资源,mainBundle的位置如下图<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/mainBundle.png" alt="mainBundle"></p>
<p>这样当然就无法加载到图片啦，我们需要让它加载自己当前所在bundle里的图片 ，所以加载图片的代码需要进行修改<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *normalImgName = <span class="string">@"个人@2x.png"</span>;</span><br><span class="line"><span class="built_in">NSBundle</span> *curBundle = [<span class="built_in">NSBundle</span> bundleForClass:<span class="keyword">self</span>.class]; <span class="comment">// 获取当前bundle</span></span><br><span class="line"><span class="built_in">NSString</span> *normalImgPath = [curBundle pathForResource:normalImgName ofType:<span class="literal">nil</span> inDirectory:<span class="string">@"LXFMain.bundle"</span>];</span><br><span class="line"><span class="built_in">UIImage</span> *normalImage = [<span class="built_in">UIImage</span> imageWithContentsOfFile:normalImgPath];</span><br></pre></td></tr></table></figure></p>
<p>但是直接写<code>LXFMain.bundle</code>并不好，不可控，所以还需要改进一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *normalImgName &#x3D; [NSString stringWithFormat:@&quot;%@@2x.png&quot;, normalImg];</span><br><span class="line">NSBundle *curBundle &#x3D; [NSBundle bundleForClass:self.class];</span><br><span class="line">&#x2F;&#x2F;  *********** 重点 ***********   &#x2F;&#x2F;</span><br><span class="line">NSString *curBundleName &#x3D; curBundle.infoDictionary[@&quot;CFBundleName&quot;];</span><br><span class="line">NSString *curBundleDirectory &#x3D; [NSString stringWithFormat:@&quot;%@.bundle&quot;, curBundleName];</span><br><span class="line">NSString *normalImgPath &#x3D; [curBundle pathForResource:normalImgName ofType:nil inDirectory:curBundleDirectory];</span><br><span class="line">&#x2F;&#x2F;  ***************************   &#x2F;&#x2F;</span><br><span class="line">UIImage *normalImage &#x3D; [UIImage imageWithContentsOfFile:normalImgPath];</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/成功加载.png" alt="成功加载"></p>
<h2 id="三、聊聊xib"><a href="#三、聊聊xib" class="headerlink" title="三、聊聊xib"></a>三、聊聊xib</h2><p>Xib的加载也是如此<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSBundle *curBundle &#x3D; [NSBundle bundleForClass:self.class];</span><br><span class="line">LXFCenterView *centerView &#x3D; (LXFCenterView *)[curBundle loadNibNamed:@&quot;LXFCenterView&quot; owner:nil options:nil].firstObject;</span><br><span class="line">centerView.frame &#x3D; CGRectMake(30, 140, 200, 100);</span><br><span class="line">[self.view addSubview:centerView];</span><br></pre></td></tr></table></figure><br>不过xib中值得一提的是，如果是直接在xib中拖入一个imageView控件来设置图片的加载，我们则需要在图片名字前加上当前bundle名称<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LXFMain.bundle&#x2F;个人</span><br></pre></td></tr></table></figure></p>
<p>这里除了当前xib要加载的图片不属于mainBundle这个原因之外，还有一点就是xib文件与bundle存放位置属于同一级别，故直接使用相对路径的方式，在图片名字前加上bundle名称即可。</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/同一目录级别.png" alt="同一目录级别"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/xib上的操作.png" alt="xib上的操作"></p>
<p>虽然无法在xib上直接看到效果，不过确实是有效的<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（三）：加载资源文件/xib成功显示图片.png" alt="xib成功显示图片"></p>
<h2 id="四、遇到的小问题"><a href="#四、遇到的小问题" class="headerlink" title="四、遇到的小问题"></a>四、遇到的小问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[!] Unable to find a pod with name, author, summary, or description matching &#96;lxfmain&#96;</span><br></pre></td></tr></table></figure>
<p>我做完一切操作后发现搜索报上面那个错，解决方案是删除本地索引文件，然后再搜索一遍，系统会自动帮你再生成一切本地索引文件，然后就搞定了～<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json </span><br><span class="line">pod search lxfmain</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Cocoapods</tag>
        <tag>iOS</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-组件化开发（二）：远程私有库的更新与子库</title>
    <url>/2018/04/06/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%AD%90%E5%BA%93/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>在上一篇【<a href="http://linxunfeng.top/2018/04/06/iOS-组件化开发（一）：远程私有库的基本使用/">iOS-组件化开发（一）：远程私有库的基本使用</a>】中我们已经实战了远程私有库的基本操作，但是组件不可能上传一次就完事了，随着业务的增加，我们的组件可能还需要添加更多的东西，或者修复一些问题，这就需要我们对私有库代码进行升级与维护</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>在上一篇【<a href="http://linxunfeng.top/2018/04/06/iOS-组件化开发（一）：远程私有库的基本使用/">iOS-组件化开发（一）：远程私有库的基本使用</a>】中我们已经实战了远程私有库的基本操作，但是组件不可能上传一次就完事了，随着业务的增加，我们的组件可能还需要添加更多的东西，或者修复一些问题，这就需要我们对私有库代码进行升级与维护</p>
</blockquote>
<p>这里以对基础组件里添加了一个Cache工具为例</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/添加Cache工具.png" alt="添加Cache工具"></p>
<p>添加完成后我们需要更新到远程仓库</p>
<h2 id="一、更新远程仓库"><a href="#一、更新远程仓库" class="headerlink" title="一、更新远程仓库"></a>一、更新远程仓库</h2><p>cd 到本地仓库的位置，执行以下操作</p>
<h3 id="1、代码更新"><a href="#1、代码更新" class="headerlink" title="1、代码更新"></a>1、代码更新</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#39;更新描述&#39;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/代码升级.png" alt="代码升级"></p>
<h3 id="2、版本更新"><a href="#2、版本更新" class="headerlink" title="2、版本更新"></a>2、版本更新</h3><p><strong>版本更新 这一步非常重要，为更新索引库做准备</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a &#39;新版本号&#39; -m &#39;注释&#39;</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/版本升级.png" alt="版本升级"></p>
<p>查看远程仓库，标签数已经有2个了，点进去就可以看到0.2.0，这里我们就不去看了<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/2个标签.png" alt=""></p>
<h2 id="二、修改描述文件并更新索引库"><a href="#二、修改描述文件并更新索引库" class="headerlink" title="二、修改描述文件并更新索引库"></a>二、修改描述文件并更新索引库</h2><h3 id="1、修改Sepc"><a href="#1、修改Sepc" class="headerlink" title="1、修改Sepc"></a>1、修改Sepc</h3><p>打开你的<code>xx.podspec</code>文件，将原本的版本号改为<code>0.2.0</code>，与刚刚的tag保持一致<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.version &#x3D; &#39;0.2.0&#39;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、验证远程Spec"><a href="#2、验证远程Spec" class="headerlink" title="2、验证远程Spec"></a>2、验证远程Spec</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec lint --private</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/验证远程Spec.png" alt="验证远程Spec"></p>
<h3 id="3、更新索引库"><a href="#3、更新索引库" class="headerlink" title="3、更新索引库"></a>3、更新索引库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod repo push 索引库名称 xxx.podspec</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/更新索引库.png" alt="更新索引库"></p>
<h2 id="三、更新使用"><a href="#三、更新使用" class="headerlink" title="三、更新使用"></a>三、更新使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; --no-repo-update 不更新本地索引库</span><br><span class="line">&#x2F;&#x2F; 因为刚刚已经自己手动更新过了，所以这里我们选择跳过更新</span><br><span class="line">pod update --no-repo-update</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/更新框架.png" alt="更新框架"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/更新成功.png" alt="更新成功"></p>
<hr>

<h2 id="四、第三方依赖"><a href="#四、第三方依赖" class="headerlink" title="四、第三方依赖"></a>四、第三方依赖</h2><p>当我们的私有库需要依赖其它第三方才可以正常使用时，我们就需要在spec文件中开启依赖，例如下面所示代码，表明当前仓库需要依赖AFN和SDWebImage<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 3.2.0&#39;</span><br><span class="line">s.dependency &#39;SDWebImage&#39;, &#39;~&gt; 4.3.3&#39;</span><br></pre></td></tr></table></figure><br>修改后更新操作同上所述，这里就不再赘述了。</p>
<p>但是这里存在一个问题，如果来了一位新的小伙伴，他所负责的部分只需要LXFBase下的Category，而LXFBase下的Cache才需要依赖SDWebImage，此时他若是pod一整个LXFBase岂不是平白无故安装了第三方依赖库，那应该怎么做呢？</p>
<blockquote>
<p>方案就是可以通过子库Subspecs来解决因需要一个小小的工具而依赖整个基础组件的问题</p>
</blockquote>
<h2 id="五、子库Subspecs"><a href="#五、子库Subspecs" class="headerlink" title="五、子库Subspecs"></a>五、子库Subspecs</h2><p>什么是Subspecs？这里我们可以搜索一下SDWebImage</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod search &#39;SDWebImage&#39;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/Subspecs.png" alt="Subspecs"></p>
<p>可以看到，如果我们只需要用到SDWebImage中的GIF功能，那么并不需要将整个SDWebImage都下载下来，在Podfile中将<del><code>pod &#39;SDWebImage&#39;</code></del> 改为 <code>pod SDWebImage/GIF</code>即可单独使用这一功能</p>
<p>那接下来我们就来看看怎么描述一个子库吧</p>
<h3 id="子库格式"><a href="#子库格式" class="headerlink" title="子库格式"></a>子库格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.subspec &#39;子库名称&#39; do |别名|</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>因为这里已经分离出子库了，所以<code>s.source_files</code>和<code>s.dependency</code>就不能这么使用了，需要我们在子库里分别指定，所以我们直接把原来的<code>s.source_files</code>和<code>s.dependency</code>都注释掉。写法参考如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># s.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line"># s.dependency &#39;SDWebImage&#39;, &#39;~&gt; 4.3.3&#39;</span><br><span class="line"></span><br><span class="line">s.subspec &#39;Cache&#39; do |c|</span><br><span class="line">  c.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;Cache&#x2F;**&#x2F;*&#39;</span><br><span class="line">  c.dependency &#39;SDWebImage&#39;, &#39;~&gt; 4.3.3&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &#39;Category&#39; do |c|</span><br><span class="line">  c.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;Category&#x2F;**&#x2F;*&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &#39;Tool&#39; do |t|</span><br><span class="line">  t.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;Tool&#x2F;**&#x2F;*&#39;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>修改后再按之前的步骤更新索引库和组件库就可以了</p>
<p><strong>ps: 在添加第三方依赖描述后做验证或者上传操作可能会很慢，因为它在克隆第三方库如SDWebImage，有兴趣的可以在命令后面加入<code>--verbose</code>来查看详情情况</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec lint --private --verbose</span><br></pre></td></tr></table></figure></p>
<p>在成功更新组件库和索引库后我们再来搜索一下试试<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod search &#39;LXFBase&#39;</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/subspec添加成功.png" alt="subspec添加成功"></p>
<p>现在就可以爱装哪个就装哪个了，在Podfile中指定要安装的子库就行了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;LXFBase&#x2F;Cache&#39;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（二）：远程私有库的更新与子库/安装指定子库与依赖库.png" alt="安装指定子库与依赖库"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Cocoapods</tag>
        <tag>iOS</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-给高仿微信添加直播聊天功能</title>
    <url>/2017/09/12/iOS-%E7%BB%99%E9%AB%98%E4%BB%BF%E5%BE%AE%E4%BF%A1%E6%B7%BB%E5%8A%A0%E7%9B%B4%E6%92%AD%E8%81%8A%E5%A4%A9%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>抽空给之前做的开源项目<a href="https://github.com/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">【高仿微信】</a>添加直播功能，由于时间有限，做得不是很完美，有空再去完善吧，能用就好~~</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>抽空给之前做的开源项目<a href="https://github.com/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">【高仿微信】</a>添加直播功能，由于时间有限，做得不是很完美，有空再去完善吧，能用就好~~</p>
</blockquote>
<p>在此提供存放于百度云的完整项目<a href="https://pan.baidu.com/s/1bpB55Bx" target="_blank" rel="noopener">【高仿微信】- 百度云</a><br>希望各位能在我的GitHub上献出一个宝贵的Star <a href="https://github.com/LinXunFeng/LXFWeChat" target="_blank" rel="noopener">【高仿微信】- GitHub</a><br>谢谢</p>
<p>注意：直播功能的使用（对方需要先进入到对应的聊天界面）</p>
<blockquote>
<p>两个测试账号： lxf lqr  密码都是123456</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://github.com/LinXunFeng/LXFWeChat/raw/master/Screenshots/8.gif" alt="直播聊天"></p>
<h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><p>首先第一件事当然就是搭建一个推流服务器，这里请跳转参考我之前写好的文章吧<a href="/2017/09/12/Ubuntu-安装nginx-来搭建推流服务器/">【Ubuntu安装nginx来搭建推流服务器】</a>，这里我的服务器的ip地址是：192.168.123.191</p>
<p>APP上推流我使用的是第三方的库 <a href="https://github.com/LaiFengiOS/LFLiveKit" target="_blank" rel="noopener">LFLiveKit</a>，这个第三方库已经帮我们处理了很多事情，而且还包括美颜~~。当然，有时间我们还是要去了解一下底层的东西，这里就先不赘述，过几天抽空再做总结。</p>
<p>关键代码如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化配置</span></span><br><span class="line"><span class="keyword">let</span> audioConfiguration = <span class="type">LFLiveAudioConfiguration</span>.<span class="keyword">default</span>()</span><br><span class="line"><span class="keyword">let</span> videoConfiguration = <span class="type">LFLiveVideoConfiguration</span>.defaultConfiguration(<span class="keyword">for</span>: .low2, outputImageOrientation: .portrait)</span><br><span class="line"><span class="comment">// 初始化session</span></span><br><span class="line"><span class="keyword">let</span> session = <span class="type">LFLiveSession</span>(audioConfiguration: audioConfiguration, videoConfiguration: videoConfiguration)</span><br><span class="line"><span class="comment">// 设置代理</span></span><br><span class="line"><span class="comment">// session?.delegate = self</span></span><br><span class="line"><span class="comment">// 设置展示的View</span></span><br><span class="line">session?.preView = <span class="keyword">self</span>.view</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stream = <span class="type">LFLiveStreamInfo</span>()</span><br><span class="line">stream.url = <span class="string">"rtmp://192.168.123.191:1935/rtmplive/lxf"</span>; <span class="comment">// 服务器地址</span></span><br><span class="line">session.startLive(stream)</span><br><span class="line"><span class="comment">// 开始推流</span></span><br><span class="line">session.running = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="拉流"><a href="#拉流" class="headerlink" title="拉流"></a>拉流</h2><p>这里我使用的是B站的开源库 <a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer</a> </p>
<p>为了方便可以用这个 <a href="https://github.com/LinXunFeng/IJKFramework" target="_blank" rel="noopener">编译好的B站开源库</a></p>
<p>需要注意的是：IJKPlayer默认使用的是软解码(FFMpeng)，如果需要使用硬解码需要我们进行相应的设置<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置"videotoolbox"的值为0为软解码(默认)，设置为1则是硬解码</span></span><br><span class="line"><span class="keyword">let</span> options = <span class="type">IJKFFOptions</span>.byDefault()</span><br><span class="line">options?.setOptionIntValue(<span class="number">1</span>, forKey: <span class="string">"videotoolbox"</span>, of: kIJKFFOptionCategoryPlayer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ijkPlayer = <span class="type">IJKFFMoviePlayerController</span>(contentURLString: <span class="string">"rtmp://192.168.123.191:1935/rtmplive/lxf"</span>, with: options)</span><br><span class="line"><span class="comment">// 需保存起来</span></span><br><span class="line"><span class="keyword">self</span>.ijkPlayer = ijkPlayer</span><br><span class="line">ijkPlayer?.view.frame = view.bounds</span><br><span class="line">view.addSubview(ijkPlayer!.view)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备播放，当视频准备好的时候会自动进行播放</span></span><br><span class="line">ijkPlayer?.prepareToPlay()</span><br></pre></td></tr></table></figure></p>
<h2 id="将IJKPlayer打包"><a href="#将IJKPlayer打包" class="headerlink" title="将IJKPlayer打包"></a>将IJKPlayer打包</h2><p>从B站的gitHub上下载的 <a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer</a> 需要手动编译出来，跟着说明走就可以了，这里就不赘述咯，接下来我们将它打包，方便使用</p>
<p>如果你不跟着说明走的话会提示找不到 avformat.h 这个头文件<br><img src= "/img/loading.gif" data-src="http://https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/1.png" alt="avformat.h"></p>
<p>这时你需要在终端cd到ijkplayer这个目录，然后执行 init-ios.sh文件，如图</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/2.png" alt="目录"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/3.png" alt="init-ios.sh"></p>
<p>然后经过一段漫长的时间之后，在ios目录下就多出了这些ffmpeg相关的目录</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/4.png" alt="ffmpeg相关目录"></p>
<p>这个操作是在下载ffmpeg源码，然缺失的avformat.h就在里面</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/5.png" alt="avformat.h"></p>
<p>打开项目 IJKMediaPlayer<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/6.png" alt="打开项目"></p>
<p>设置为 release，这样打出来的包会小些<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/7.png" alt="Edit Scheme"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/8.png" alt="release"></p>
<p>选择真机和模拟器，各Command+B编译一次<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/9.png" alt="真机"><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/10.png" alt="模拟器"></p>
<p>右击，Show in Finder<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/11.png" alt=""></p>
<p>如图，就有两个文件夹，里面存放着的就是我们编译出来的库<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/12.png" alt="Paste_Image.png"></p>
<p>可以使用如下命令查看信息<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lipo -info IJKMediaFramework</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/13.png" alt="查看所支持的处理器"><br>默认模拟器编译出来的包是不支持i386，如果希望支持的话<br>进入项目的 Build Settings，将 Build Active Architecture Only 设置为NO<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/14.png" alt="Build Active Architecture Only"></p>
<p>好，现在对编译出来的包进行合并，这样就即支持真机，也支持模拟器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 格式</span><br><span class="line">// lipo -create  path1  path2  -output  frameName</span><br><span class="line"></span><br><span class="line">lipo -create Release-iphoneos/IJKMediaFramework.framework/IJKMediaFramework Release-iphonesimulator/IJKMediaFramework.framework/IJKMediaFramework -output IJKMediaFramework</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/15.png" alt="合并"></p>
<p>将合并出来的IJKMediaFramework替换 IJKMediaFramework.framework中的IJKMediaFramework，最后将替换好的 IJKMediaFramework.framework 拖入到项目中使用即可。<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-给高仿微信添加直播聊天功能/16.png" alt="替换"></p>
<p>最后，附上编译好的IJKMediaFramework<br>链接:<a href="https://pan.baidu.com/s/1eRYlJ7W" target="_blank" rel="noopener">https://pan.baidu.com/s/1eRYlJ7W</a> 密码:9iaw</p>
<div class="github-widget" data-repo="LinXunFeng/LXFWeChat"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - 通过runtime获取某个类中所有的变量和方法</title>
    <url>/2017/09/12/iOS-%E9%80%9A%E8%BF%87runtime%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E7%B1%BB%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>苹果官方的类中只提供给我们一小部分成员变量和方法,但有时候我们需要的恰好就没有提供,这样就会令开发人员十分懊恼了,那怎样才能获取该类中所有的变量及方法,用来查找是否有相对应的变量和方法呢?<br>我们可以使用苹果自带的 运行时(runtime) 来获取<br>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<p>苹果官方的类中只提供给我们一小部分成员变量和方法,但有时候我们需要的恰好就没有提供,这样就会令开发人员十分懊恼了,那怎样才能获取该类中所有的变量及方法,用来查找是否有相对应的变量和方法呢?<br>我们可以使用苹果自带的 运行时(runtime) 来获取</p>
<h2 id="运行时-Runtime"><a href="#运行时-Runtime" class="headerlink" title="运行时(Runtime):"></a>运行时(Runtime):</h2><ul>
<li>苹果官方一套<a href="http://lib.csdn.net/base/c" target="_blank" rel="noopener">C语言</a>库 </li>
<li>能做很多底层操作(比如访问隐藏的一些成员变量\成员方法….)</li>
</ul>
<p>以下以 UITextField 为例</p>
<h3 id="一-包含运行时头文件"><a href="#一-包含运行时头文件" class="headerlink" title="一. 包含运行时头文件"></a>一. 包含运行时头文件</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="二-获取所有的成员变量"><a href="#二-获取所有的成员变量" class="headerlink" title="二. 获取所有的成员变量"></a>二. 获取所有的成员变量</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 拷贝出所胡的成员变量列表</span></span><br><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UITextField</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">    <span class="comment">// 取出成员变量</span></span><br><span class="line">    Ivar ivar = *(ivars + i);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 打印成员变量名字</span></span><br><span class="line">    LXFLog(<span class="string">@"%s"</span>, ivar_getName(ivar));</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 打印成员变量的数据类型</span></span><br><span class="line">    LXFLog(<span class="string">@"%s"</span>, ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">free(ivars);</span><br></pre></td></tr></table></figure>
<p>Swift的写法如下<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> ivars = class_copyIvarList(<span class="type">UIViewController</span>.<span class="keyword">self</span>, &amp;<span class="built_in">count</span>)!</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> namePoint = ivar_getName(ivars[<span class="type">Int</span>(i)])!</span><br><span class="line">    <span class="keyword">let</span> name = <span class="type">String</span>(cString: namePoint)</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="三-获取所有的成员方法"><a href="#三-获取所有的成员方法" class="headerlink" title="三. 获取所有的成员方法"></a>三. 获取所有的成员方法</h3><p>// 下面的UITextField改为你想获取所有属性的类名<br>// methCount: 这个类所有属性的个数<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> methCount = <span class="number">0</span>;</span><br><span class="line">Method *meths = class_copyMethodList([<span class="built_in">UITextField</span> <span class="keyword">class</span>], &amp;methCount);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methCount; i++) &#123;</span><br><span class="line">        </span><br><span class="line">    Method meth = meths[i];</span><br><span class="line">        </span><br><span class="line">    SEL sel = method_getName(meth);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(sel);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">free(meths);</span><br></pre></td></tr></table></figure><br>最后,通过KVC的方式给相应的成员变量赋值即可!<br>如:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改点位文字颜色</span></span><br><span class="line"><span class="built_in">UILabel</span> *placeholderLabel = [<span class="keyword">self</span> valueForKeyPath:<span class="string">@"_placeholderLabel"</span>];</span><br><span class="line">placeholderLabel.textColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line"><span class="comment">// 或者这样</span></span><br><span class="line">[<span class="keyword">self</span> setValue:[<span class="built_in">UIColor</span> grayColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - 采集音视频及写入文件</title>
    <url>/2017/09/26/iOS-%E9%87%87%E9%9B%86%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8F%8A%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>音视频采集包括两部分：视频采集和音频采集。在iOS中可以同步采集视频与音频，通过系统框架AVFoundation，可以帮助我们采集音频与视频，对于视频还可以进行切换前后摄像头，最终我们将录制好的视频写入沙盒中</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>音视频采集包括两部分：视频采集和音频采集。在iOS中可以同步采集视频与音频，通过系统框架AVFoundation，可以帮助我们采集音频与视频，对于视频还可以进行切换前后摄像头，最终我们将录制好的视频写入沙盒中</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="/images/2017/09/iOS-采集音视频及写入文件/1.gif" alt="目录"></p>
<h2 id="音视频数据的采集与展示"><a href="#音视频数据的采集与展示" class="headerlink" title="音视频数据的采集与展示"></a>音视频数据的采集与展示</h2><h3 id="一、初始化视频的输入与输出"><a href="#一、初始化视频的输入与输出" class="headerlink" title="一、初始化视频的输入与输出"></a>一、初始化视频的输入与输出</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒加载一个session，所有的操作都需要session来执行</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="built_in">lazy</span> <span class="keyword">var</span> session: <span class="type">AVCaptureSession</span> = <span class="type">AVCaptureSession</span>()</span><br><span class="line"><span class="comment">// 保存视频输出</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> videoOutput: <span class="type">AVCaptureVideoDataOutput?</span></span><br><span class="line"><span class="comment">// 保存视频输入</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> videoInput: <span class="type">AVCaptureDeviceInput?</span></span><br><span class="line"><span class="comment">// 保存预览图层</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> previewLayer: <span class="type">AVCaptureVideoPreviewLayer?</span></span><br></pre></td></tr></table></figure>
<p>设置视频输入源与输出源<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置视频输入源</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> devices = <span class="type">AVCaptureDevice</span>.devices() <span class="keyword">as</span>? [<span class="type">AVCaptureDevice</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="comment">// 获取我们的前置摄像头(后置为.back)</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> device = devices.<span class="built_in">filter</span>(&#123; $<span class="number">0</span>.position == .front &#125;).first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> input = <span class="keyword">try</span>? <span class="type">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">self</span>.videoInput = input</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置视频输出源</span></span><br><span class="line"><span class="keyword">let</span> output = <span class="type">AVCaptureVideoDataOutput</span>()</span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="comment">// 设置代理，并在代理中获取采集到的数据，需要遵守 AVCaptureVideoDataOutputSampleBufferDelegate</span></span><br><span class="line">output.setSampleBufferDelegate(<span class="keyword">self</span>, queue: queue)</span><br><span class="line"><span class="keyword">self</span>.videoOutput = output</span><br></pre></td></tr></table></figure><br>设置音频的输入源与输出源<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置音频的输入源</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> device = <span class="type">AVCaptureDevice</span>.defaultDevice(withMediaType: <span class="type">AVMediaTypeAudio</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> input = <span class="keyword">try</span>? <span class="type">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置音频输出源</span></span><br><span class="line"><span class="keyword">let</span> output = <span class="type">AVCaptureAudioDataOutput</span>()</span><br><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</span><br><span class="line"><span class="comment">// 需要遵守 AVCaptureAudioDataOutputSampleBufferDelegate</span></span><br><span class="line">output.setSampleBufferDelegate(<span class="keyword">self</span>, queue: queue)</span><br></pre></td></tr></table></figure><br>添加音频与视频的输入与输出到session中，但是每次添加之前需要先判断是否可以添加</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加输入与输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：每次对session进行设置之前都需要调用session的【beginConfiguration】方法</span></span><br><span class="line"><span class="comment">// 来告诉系统你现在要开始进行配置，结束配置后再调用【commitConfiguration】方法来提交配置</span></span><br><span class="line">session.beginConfiguration()</span><br><span class="line"><span class="keyword">if</span> session.canAddInput(input) &#123;</span><br><span class="line">    session.addInput(input)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> session.canAddOutput(output) &#123;</span><br><span class="line">    session.addOutput(output)</span><br><span class="line">&#125;</span><br><span class="line">session.commitConfiguration()</span><br></pre></td></tr></table></figure>
<h3 id="二、实现音视频的采集代理"><a href="#二、实现音视频的采集代理" class="headerlink" title="二、实现音视频的采集代理"></a>二、实现音视频的采集代理</h3><p>音视频虽然需要遵守的代理名称不一样，但是需要实现的方法是一致的，所以要拿到音频或者视频就得先进行判断，需要用到AVCaptureOutput的这个方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; This convenience method returns the first AVCaptureConnection in the receiver&#39;s</span><br><span class="line">&#x2F;&#x2F; connections array that has an AVCaptureInputPort of the specified mediaType. If </span><br><span class="line">&#x2F;&#x2F; no connection with the specified mediaType is found, nil is returned.</span><br><span class="line"></span><br><span class="line">open func connection(withMediaType mediaType: String!) -&gt; AVCaptureConnection!</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">AVCaptureVideoDataOutputSampleBufferDelegate</span>, <span class="title">AVCaptureAudioDataOutputSampleBufferDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">captureOutput</span><span class="params">(<span class="number">_</span> captureOutput: AVCaptureOutput!, didOutputSampleBuffer sampleBuffer: CMSampleBuffer!, from connection: AVCaptureConnection!)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> videoOutput?.connection(withMediaType: <span class="type">AVMediaTypeVideo</span>) == connection &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"视频数据"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"音频数据"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="三、初始化一个预览图层用来显示采集到的视频（非采集所必须的步骤）"><a href="#三、初始化一个预览图层用来显示采集到的视频（非采集所必须的步骤）" class="headerlink" title="三、初始化一个预览图层用来显示采集到的视频（非采集所必须的步骤）"></a>三、初始化一个预览图层用来显示采集到的视频（非采集所必须的步骤）</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建预览图层</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> previewLayer = <span class="type">AVCaptureVideoPreviewLayer</span>(session: session) <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">previewLayer.frame = view.bounds</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将图层添加到控制器的view的layer中</span></span><br><span class="line">view.layer.insertSublayer(previewLayer, at: <span class="number">0</span>)</span><br><span class="line"><span class="keyword">self</span>.previewLayer = previewLayer</span><br></pre></td></tr></table></figure>
<p>现在基本功能都有了，如果想要开始采集音视频只需要调用<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始录制</span></span><br><span class="line">session.startRunning()</span><br><span class="line"><span class="comment">// 结束录制</span></span><br><span class="line">session.stopRunning()</span><br></pre></td></tr></table></figure></p>
<h3 id="切换镜头"><a href="#切换镜头" class="headerlink" title="切换镜头"></a>切换镜头</h3><p>其实就是换掉当前的视频输入法制，这里的过程跟上面的设置输入源一样。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.取出之前镜头的方向</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> videoInput = videoInput <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">let</span> position: <span class="type">AVCaptureDevicePosition</span> = videoInput.device.position == .front ? .back : .front</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> devices = <span class="type">AVCaptureDevice</span>.devices() <span class="keyword">as</span>? [<span class="type">AVCaptureDevice</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> device = devices.<span class="built_in">filter</span>(&#123; $<span class="number">0</span>.position == position &#125;).first <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> newInput = <span class="keyword">try</span>? <span class="type">AVCaptureDeviceInput</span>(device: device) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.移除之前的input，添加新的input</span></span><br><span class="line">session.beginConfiguration()</span><br><span class="line">session.removeInput(videoInput)</span><br><span class="line"><span class="keyword">if</span> session.canAddInput(newInput) &#123;</span><br><span class="line">    session.addInput(newInput)</span><br><span class="line">&#125;</span><br><span class="line">session.commitConfiguration()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.保存最新的input</span></span><br><span class="line"><span class="keyword">self</span>.videoInput = newInput</span><br></pre></td></tr></table></figure></p>
<h2 id="录制视频写入文件"><a href="#录制视频写入文件" class="headerlink" title="录制视频写入文件"></a>录制视频写入文件</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> movieOutput: <span class="type">AVCaptureMovieFileOutput?</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在开始采集音视频的时候就要开始写入文件</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始写入文件 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、创建写入文件的输出</span></span><br><span class="line"><span class="keyword">let</span> fileOutput = <span class="type">AVCaptureMovieFileOutput</span>()</span><br><span class="line"><span class="keyword">self</span>.movieOutput = fileOutput <span class="comment">// 保存起来，用于停止写入文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置类型，不然报错(这两句很重要)</span></span><br><span class="line"><span class="keyword">let</span> connection = fileOutput.connection(withMediaType: <span class="type">AVMediaTypeVideo</span>)</span><br><span class="line">connection?.automaticallyAdjustsVideoMirroring = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> session.canAddOutput(fileOutput) &#123;</span><br><span class="line">    session.addOutput(fileOutput)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、直接开始写入文件</span></span><br><span class="line"><span class="keyword">let</span> filePath = <span class="type">NSSearchPathForDirectoriesInDomains</span>(.documentDirectory, .userDomainMask, <span class="literal">true</span>).first! + <span class="string">"/abc.mp4"</span></span><br><span class="line"><span class="keyword">let</span> fileUrl = <span class="type">URL</span>(fileURLWithPath: filePath)</span><br><span class="line">fileOutput.startRecording(toOutputFileURL: fileUrl, recordingDelegate: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在停止采集音视频的时候停止写入文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 停止写入文件</span><br><span class="line">movieOutput?.stopRecording()</span><br></pre></td></tr></table></figure>
<p>详情请看 <a href="https://github.com/LinXunFeng/LXFRecordAndWriteMediaDemo" target="_blank" rel="noopener">DEMO</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-面向协议封装全屏旋转功能</title>
    <url>/2018/09/15/iOS-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E5%B0%81%E8%A3%85%E5%85%A8%E5%B1%8F%E6%97%8B%E8%BD%AC%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<blockquote>
<p>关于使用面向协议来封装功能的实战可以参考我上篇文章 <a href="/2018/04/07/iOS-面向协议方式封装空白页功能/">【iOS-面向协议方式封装空白页功能】</a>，这里就不再赘述，我们直接进入使用阶段吧。<br>本篇文章只有一个目的，那就是只要遵守协议，一行代码随意切换全屏～</p>
</blockquote>
<p>如果对面向协议有疑问的同学可以看下我之前的两篇文章</p>
<p><a href="/2017/09/12/iOS-Swift-面向协议编程（一）/">iOS - Swift 面向协议编程（一）</a> </p>
<p><a href="/2017/09/12/iOS-Swift-面向协议编程（二）/">iOS - Swift 面向协议编程（二）</a></p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>关于使用面向协议来封装功能的实战可以参考我上篇文章 <a href="/2018/04/07/iOS-面向协议方式封装空白页功能/">【iOS-面向协议方式封装空白页功能】</a>，这里就不再赘述，我们直接进入使用阶段吧。<br>本篇文章只有一个目的，那就是只要遵守协议，一行代码随意切换全屏～</p>
</blockquote>
<p>如果对面向协议有疑问的同学可以看下我之前的两篇文章</p>
<p><a href="/2017/09/12/iOS-Swift-面向协议编程（一）/">iOS - Swift 面向协议编程（一）</a> </p>
<p><a href="/2017/09/12/iOS-Swift-面向协议编程（二）/">iOS - Swift 面向协议编程（二）</a></p>
<h2 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Link</th>
</tr>
</thead>
<tbody>
<tr>
<td>GitHub</td>
<td><a href="https://github.com/LinXunFeng/LXFProtocolTool" target="_blank" rel="noopener">LXFProtocolTool</a></td>
</tr>
<tr>
<td>Wiki</td>
<td><a href="https://github.com/LinXunFeng/LXFProtocolTool/wiki" target="_blank" rel="noopener">Wiki首页</a></td>
</tr>
<tr>
<td>本文 Demo</td>
<td><a href="https://github.com/LinXunFeng/LXFProtocolTool/tree/master/Example/LXFProtocolTool/Demo/LXFFullScreenable" target="_blank" rel="noopener">LXFFullScreenable</a></td>
</tr>
</tbody>
</table>
<p>使用Cocoapods的方式来安装即可</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">'LXFProtocolTool/FullScreenable'</span></span><br></pre></td></tr></table></figure>
<h2 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h2><p>在AppDelegate中实现如下方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?)</span></span> -&gt; <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIApplication</span>.shared.lxf.currentVcOrientationMask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、使用案例"><a href="#二、使用案例" class="headerlink" title="二、使用案例"></a>二、使用案例</h2><blockquote>
<p>方法与属性的调用都需要命名空间加上 <code>lxf</code>，如<code>isFullScreen</code> -&gt; <code>lxf.isFullScreen</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">isFullScreen : 获取当前遵守协议者是否为全屏状态</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    isEnter: Bool? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    specifiedView: UIView? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    superView: UIView? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: <span class="params">(<span class="params">(<span class="number">_</span> isFullScreen: Bool)</span></span></span></span>-&gt;<span class="type">Void</span>)? = <span class="literal">nil</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>isEnter</td>
<td><code>Bool?</code></td>
<td>是否进入全屏</td>
</tr>
<tr>
<td>specifiedView</td>
<td><code>UIView?</code></td>
<td>指定即将全屏的视图</td>
</tr>
<tr>
<td>superView</td>
<td><code>UIView?</code></td>
<td>作为退出全屏后specifiedView的父视图</td>
</tr>
<tr>
<td>config</td>
<td><code>FullScreenableConfig?</code></td>
<td>配置</td>
</tr>
<tr>
<td>completed</td>
<td><code>((_ isFullScreen: Bool)-&gt;Void)?</code></td>
<td>进入/退出 全屏后的回调</td>
</tr>
</tbody>
</table>
<blockquote>
<p>当<code>switchFullScreen</code>的调用者为<code>UIView</code>时，如果<code>specifiedView</code>为<code>nil</code>会自动填写，<code>superView</code>也是如此</p>
</blockquote>
<blockquote>
<p><code>switchFullScreen</code>方法不推荐直接使用，不过当遵守协议者为<code>UIViewController</code>时，可以通过使用默认参数来切换屏幕方向<code>lxf.switchFullScreen()</code></p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/09/iOS-面向协议封装全屏旋转功能/lxf_FullScreenable_1.gif" alt="lxf_FullScreenable_1"></p>
<p>以下分两种情况说明</p>
<h3 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enterFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    specifiedView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: FullScreenableCompleteType? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    superView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: FullScreenableCompleteType? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上两个方法是对<code>switchFullScreen</code>的抽离，使调用时对参数的传递更加清晰</p>
</blockquote>
<p>1、遵守协议 <code>FullScreenable</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LXFFullScreenableController</span>: <span class="title">UIViewController</span>, <span class="title">FullScreenable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>2、指定视图进入全屏<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lxf.enterFullScreen(specifiedView: cyanView)</span><br></pre></td></tr></table></figure></p>
<p>3、指定视图退出全屏，并添加到当前控制器的<code>view</code>上<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lxf.exitFullScreen(superView: <span class="keyword">self</span>.view)</span><br></pre></td></tr></table></figure></p>
<h4 id="🔥自动进入-退出全屏"><a href="#🔥自动进入-退出全屏" class="headerlink" title="🔥自动进入|退出全屏"></a>🔥自动进入|退出全屏</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    specifiedView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">    superView: UIView,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>控制器可以调用该方法来注册自动进入或退出全屏，各控制器之间互不影响。</li>
<li><code>view</code>手动进入全屏会屏蔽当前控制器的自动全屏功能，退出方可恢复</li>
</ul>
<h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enterFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    specifiedView: UIView? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: FullScreenableCompleteType? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exitFullScreen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    superView: UIView? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    config: FullScreenableConfig? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    completed: FullScreenableCompleteType? = <span class="literal">nil</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上两个方法是对<code>switchFullScreen</code>的抽离，使调用时对参数的传递更加清晰</p>
</blockquote>
<p>1、遵守协议 <code>FullScreenable</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LXFFullScreenView</span>: <span class="title">UIButton</span>, <span class="title">FullScreenable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cyanView = <span class="type">LXFFullScreenView</span>()</span><br></pre></td></tr></table></figure>
<p>2、进入全屏</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">cyanView.lxf.enterFullScreen()</span><br></pre></td></tr></table></figure>
<p>3、退出全屏<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">cyanView.lxf.exitFullScreen()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里是对遵守了<code>FullScreenable</code>协议的视图进入全屏切换，由于代码内部已经经过自动视图填写，所以直接调用相应的方法即可，当然也可以自己指定<code>specifiedView</code>和<code>superView</code></p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/09/iOS-面向协议封装全屏旋转功能/lxf_FullScreenable_2.gif" alt="lxf_FullScreenable_2"></p>
<h2 id="三、FullScreenableConfig说明"><a href="#三、FullScreenableConfig说明" class="headerlink" title="三、FullScreenableConfig说明"></a>三、FullScreenableConfig说明</h2><blockquote>
<p>上述的方法都有一个<code>config</code>参数，默认为nil，即为默认配置</p>
</blockquote>
<p>相关属性说明<br>| Name                       | Type                     | Desc                           | Default        |<br>| ————————– | ———————— | —————————— | ————– |<br>| animateDuration            | <code>Double</code>                 | 进入/退出 全屏时的旋转动画时间 | 0.25           |<br>| enterFullScreenOrientation | <code>UIInterfaceOrientation</code> | 进入全屏时的初始方向           | landscapeRight |</p>
<p>这里我们把动画时间设置为<code>1s</code>，初始方向为<code>左</code>后来看看效果<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">FullScreenableConfig</span>(</span><br><span class="line">    animateDuration: <span class="number">1</span>,</span><br><span class="line">    enterFullScreenOrientation : .landscapeLeft</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">cyanView.lxf.enterFullScreen(config: diyConfig)</span><br><span class="line">cyanView.lxf.exitFullScreen(config: diyConfig)</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/09/iOS-面向协议封装全屏旋转功能/lxf_FullScreenable_3.gif" alt="lxf_FullScreenable_3"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里相关的说明已罗列完毕，有什么不清楚的可以下载<a href="https://github.com/LinXunFeng/LXFProtocolTool/tree/master/Example/LXFProtocolTool/Demo/LXFFullScreenable" target="_blank" rel="noopener">Demo</a>看看，或者在文章下方留言提问</p>
<p><a href="https://github.com/LinXunFeng/LXFProtocolTool" target="_blank" rel="noopener">LXFProtocolTool</a> 主要是通过协议的方式来方便快捷地实现一些的实用功能，除了本文提及的全屏旋转功能外还有其它实用功能的封装，具体内容可以到 <a href="https://github.com/LinXunFeng/LXFProtocolTool/wiki" target="_blank" rel="noopener">Wiki首页</a>  查找。如果你有什么想实现的功能也可以提出来，喜欢的就给个Star鼓励下我吧 🚀 🚀 🚀，感谢支持！</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>解决SecurityEnvSDK与SGMain的冲突问题</title>
    <url>/2020/03/14/%E8%A7%A3%E5%86%B3SecurityEnvSDK%E4%B8%8ESGMain%E7%9A%84%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>报错是说有重复类，解决的办法比较简单粗暴，就是把在Xcode里全文搜索<br><code>-framework &quot;SecurityEnvSDK&quot;</code>，接着全文替换为空字符串就可以了。</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在集成友盟统计和阿里百川之后项目报如下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">duplicate symbol '_OBJC_CLASS_$_tdvSFHFKeychainUtils' in:</span><br><span class="line">    /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o)</span><br><span class="line">    /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)</span><br><span class="line">duplicate symbol '_OBJC_METACLASS_$_tdvSFHFKeychainUtils' in:</span><br><span class="line">    /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o)</span><br><span class="line">    /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)</span><br><span class="line">duplicate symbol '_OBJC_CLASS_$_SGDataCollectionLock' in:</span><br><span class="line">    /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o)</span><br><span class="line">    /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)</span><br><span class="line">duplicate symbol '_OBJC_METACLASS_$_SGDataCollectionLock' in:</span><br><span class="line">    /Users/.../Pods/UMCSecurityPlugins/thirdparties/SecurityEnvSDK.framework/SecurityEnvSDK(SecurityEnvSDK99999999.o)</span><br><span class="line">    /Users/.../阿里百川/WXFrameworks/SGMain.framework/SGMain(SGMain99999999.o)</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 报错是说有重复类，解决的办法比较简单粗暴，就是把在Xcode里全文搜索<br> <code>-framework &quot;SecurityEnvSDK&quot;</code>，接着全文替换为空字符串就可以了。</p>
</blockquote>
<p>虽然解决这个问题的方式很简单，但是每次 <code>pod install</code> 后都要做一遍该操作，这就很无语了 。</p>
<p>那有什么办法可以让我们不用自己去做这个烦琐的事情呢？</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ol>
<li><p>首先要搞清楚，上面的操作原理是怎么回事？其它很简单，就是将下面这两个文件中 <code>OTHER_LDFLAGS</code> 所在行的内容里，把 <code>-framework &quot;SecurityEnvSDK&quot;</code> 置为空字符串。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Pods/Target Support Files/Pods-项目名/Pods-项目名.debug.xcconfig</span><br><span class="line">Pods/Target Support Files/Pods-项目名/Pods-项目名.release.xcconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>有什么办法可以让我们在适当的时候去执行这个置空字符串的操作？<br><code>Cocoapods</code> 提供了一个很好用的 <code>Hook</code> 就是 <code>post_install</code>，这个钩子的作用就是方便我们在执行 <code>pod install</code> 之后去做一些其它配置，这里我们就用它来搞事情。</p>
</li>
</ol>
<p><code>Podfile</code> 文件中使用的是 <code>ruby</code> 语言，<code>ruby</code> 执行终端命令的代码如下所示：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line"><span class="meta">  #</span><span class="bash"> <span class="built_in">command</span> = <span class="string">"echo 'hello world'"</span></span></span><br><span class="line">  command = "终端命令"</span><br><span class="line">  system(command)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br>OK，现在开始搞事！</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>在项目的目录，即与<code>Pods</code>平级目录中，新建一个文件，名为 <code>fix.py</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── ...</span><br><span class="line">├── Podfile</span><br><span class="line">├── Podfile.lock</span><br><span class="line">├── Pods</span><br><span class="line">│   ├── ...</span><br><span class="line">│   └── ...</span><br><span class="line">└── fix.py</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在 <code>fix.py</code> 中粘贴如下内容<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys, os, getopt, codecs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_file_name</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""获取当前文件名称"""</span></span><br><span class="line">    <span class="keyword">return</span> os.path.split(__file__)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_all_str</span><span class="params">(file_path, for_str, to_str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    全文搜索替换或单行替换</span></span><br><span class="line"><span class="string">    :param file_path: 文件路径</span></span><br><span class="line"><span class="string">    :param for_str: 要被替换的内容</span></span><br><span class="line"><span class="string">    :param to_str: 替换之后的内容</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">        <span class="comment"># 文件不存在</span></span><br><span class="line">        print(<span class="string">'文件不存在'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    bak_file_path = file_path+<span class="string">".bak"</span></span><br><span class="line">    <span class="keyword">with</span> codecs.open(file_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f, codecs.open(bak_file_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_w:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"OTHER_LDFLAGS"</span> <span class="keyword">in</span> line <span class="keyword">and</span> for_str <span class="keyword">in</span> line:</span><br><span class="line">                line = line.replace(for_str, to_str)</span><br><span class="line">            f_w.write(line)</span><br><span class="line"></span><br><span class="line">    os.remove(file_path)</span><br><span class="line">    os.rename(bak_file_path, file_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">throwParamError</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"请正确输入命令： %s -p 项目名称"</span> % get_current_file_name())</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    project_name = <span class="string">""</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(argv, <span class="string">"p:"</span>, [<span class="string">"project="</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">        throwParamError()</span><br><span class="line">    <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="comment"># print("opt -- ", opt)</span></span><br><span class="line">        <span class="comment"># print("arg -- ", arg)</span></span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> (<span class="string">'-p'</span>, <span class="string">'--project'</span>):</span><br><span class="line">            project_name = arg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(project_name):</span><br><span class="line">        throwParamError()</span><br><span class="line">    </span><br><span class="line">    path_str = <span class="string">"Pods/Target Support Files/Pods-%s/Pods-%s.%s.xcconfig"</span></span><br><span class="line">    xcconfig_debug_path = path_str % (project_name, project_name, <span class="string">"debug"</span>)</span><br><span class="line">    xcconfig_release_path = path_str % (project_name, project_name, <span class="string">"release"</span>)</span><br><span class="line">    <span class="comment"># print(xcconfig_debug_path)</span></span><br><span class="line">    <span class="comment"># print(xcconfig_release_path)</span></span><br><span class="line">    be_fixed_str = <span class="string">'-framework "SecurityEnvSDK"'</span></span><br><span class="line">    replace_all_str(xcconfig_debug_path,  be_fixed_str, <span class="string">''</span>)</span><br><span class="line">    replace_all_str(xcconfig_release_path,  be_fixed_str, <span class="string">''</span>)</span><br><span class="line">    print(<span class="string">"%s is fixed successfully"</span> %project_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main(sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></li>
<li>打开 <code>Podfile</code>，在内容最后添加如下内容<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">  <span class="comment"># 解决SecurityEnvSDK与SGMain的冲突问题</span></span><br><span class="line">  command = <span class="string">"python fix.py -p 项目名称"</span></span><br><span class="line">  system(command)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li>执行<code>pod install</code></li>
</ol>
<p>好了，现在开始就又可以继续愉快的搬砖了~</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>相关代码文件可以到这里下载，如果觉得不错，不妨给个 <code>Star</code> 鼓励一下<br><a href="https://github.com/LinXunFeng/fix_confict_SecurityEnvSDK_SGMain" target="_blank" rel="noopener">https://github.com/LinXunFeng/fix_confict_SecurityEnvSDK_SGMain</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Transporter一直卡正在验证的问题</title>
    <url>/2020/03/12/%E8%A7%A3%E5%86%B3Transporter%E4%B8%80%E7%9B%B4%E5%8D%A1%E6%AD%A3%E5%9C%A8%E9%AA%8C%E8%AF%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>苹果的上传应用工具 <code>Transporter</code> 虽然挺好用，但是估计也不少人跟我一样遇到过这样的问题，就是一直卡在 <code>正在验证</code>，不采取点措施估计能一直卡下去~</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>苹果的上传应用工具 <code>Transporter</code> 虽然挺好用，但是估计也不少人跟我一样遇到过这样的问题，就是一直卡在 <code>正在验证</code>，不采取点措施估计能一直卡下去~</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="/images/2020/03/解决Transporter一直卡正在验证的问题/正在验证APP.jpg" alt="正在验证APP"></p>
<p>其实原因很简单，就是 <code>/User/当前登录用户/Library/Caches/com.apple.amp.itmstransporter</code> 这个目录里的文件不全，一直处于下载更新的状态。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>科学上网前提下，在终端下执行  <code>Transporter</code> 包内的 <code>iTMSTransporter</code>，<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter</span><br></pre></td></tr></table></figure><br>因为国外服务器（<code>contentdelivery.itunes.apple.com:443</code>）对我们来说会很慢，所以这个过程最好弄下科学环境。</p>
<p>直到出现这个命令说明界面就可以了<br><img src= "/img/loading.gif" data-src="/images/2020/03/解决Transporter一直卡正在验证的问题/iTMSTransporter.png" alt=""></p>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>适用人群</p>
<ul>
<li>没有科学环境</li>
<li>速度要求高的</li>
<li>比较懒的</li>
</ul>
<p>可以使用 <code>transporter_fix</code><br>GitHub地址：<a href="https://github.com/LinXunFeng/transporter_fix" target="_blank" rel="noopener">https://github.com/LinXunFeng/transporter_fix</a><br>执行文件下载地址：<a href="https://github.com/LinXunFeng/transporter_fix/releases" target="_blank" rel="noopener">点我下载</a>，下载后双击运行即可。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/03/解决Transporter一直卡正在验证的问题/transporter_fix.png" alt=""></p>
<p>比较懒的朋友看到这就可以了，要求速度快的就继续往下看</p>
<p><strong>重点</strong></p>
<ul>
<li><code>transporter_fix</code> 默认是从 <code>github</code> 上下载 <code>com.apple.amp.itmstransporter.zip</code> 到同目录级别的 <code>files</code> 目录下。</li>
<li>如果 <code>files</code> 目录下已存在 <code>com.apple.amp.itmstransporter.zip</code> ，则不会重新下载。</li>
</ul>
<p>所以，如果当前正常网络对 <code>github</code> 不给力，可以到<a href="https://www.lanzous.com/b0aqkmhpg" target="_blank" rel="noopener">这里</a>，找个离当前日期最近的压缩包，下载下来后改名为 <code>com.apple.amp.itmstransporter.zip</code>，存放 <code>files</code> 目录下即可</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/03/解决Transporter一直卡正在验证的问题/itmstransporter压缩包存放位置.png" alt=""></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装nginx来搭建推流服务器</title>
    <url>/2017/09/12/Ubuntu-%E5%AE%89%E8%A3%85nginx-%E6%9D%A5%E6%90%AD%E5%BB%BA%E6%8E%A8%E6%B5%81%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>如果安装命令回车之后出现如下信息，请参考<a href="http://www.linuxidc.com/Linux/2009-07/20740.htm" target="_blank" rel="noopener">【Ubuntu “无法获得锁”解决方案】</a>解决，但是我亲测对我没用，直接重启搞定</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>安装两个依赖库<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install autoconf automake</span><br><span class="line">sudo apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure><br>安装zlib库<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssl</span><br><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure><br>如果安装命令回车之后出现如下信息，请参考<a href="http://www.linuxidc.com/Linux/2009-07/20740.htm" target="_blank" rel="noopener">【Ubuntu “无法获得锁”解决方案】</a>解决，但是我亲测对我没用，直接重启搞定<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E: 无法获得锁 &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open (11: 资源暂时不可用)</span><br><span class="line">E: 无法锁定管理目录(&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;)，是否有其他进程正占用它？</span><br></pre></td></tr></table></figure></p>
<p>进入家目录，新建一个文件夹，这里以lxf为例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir lxf</span><br></pre></td></tr></table></figure></p>
<p>下载所需源码<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 下载nginx-rtmp源码</span><br><span class="line">wget https://github.com/arut/nginx-rtmp-module/archive/master.zip</span><br><span class="line">// 修改压缩包的名字</span><br><span class="line">mv master.zip module.zip</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 下载nginx</span><br><span class="line">wget https://github.com/nginx/nginx/archive/master.zip</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 下载nginx的依赖pcre源码</span><br><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz</span><br></pre></td></tr></table></figure>
<p>下载完成之后使用unzip命令进行解压<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip master.zip </span><br><span class="line">unzip module.zip</span><br><span class="line">tar -zxvf pcre-8.39.tar.gz</span><br></pre></td></tr></table></figure><br>配置编译文件，准备编译安装<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 先进入nginx-master目录</span><br><span class="line">cd nginx-master/</span><br></pre></td></tr></table></figure><br>在nginx-master目录下有一个auto文件夹，里面有一个名为configure的配置文件，我们先来通过它进行一些配置<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// prefix:指定安装目录</span><br><span class="line">// add-module:指定模块文件夹</span><br><span class="line">auto/configure --prefix=/usr/local/nginx --with-pcre=../pcre-8.39 --with-http_ssl_module --with-http_v2_module --with-http_flv_module --with-http_mp4_module --add-module=../nginx-rtmp-module-master/</span><br></pre></td></tr></table></figure><br>配置好之后会多出一个Makefile文件(一种配置文件，定义了一系列的规则来指定编译操作)与objs文件夹<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/1.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 编译</span><br><span class="line">make</span><br><span class="line">// 安装</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>当你make后，看到则代表编译成功<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/2.png" alt="make成功"><br>再执行【sudo make install】，看到这个则代表安装完成<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/3.png" alt="安装完成"></p>
<p>现在我们去测试一下<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> cd /usr/local/nginx/sbin/</span><br><span class="line">sudo ./nginx -t</span><br></pre></td></tr></table></figure><br>看到successful说明配置文件正确！，如果是failed的话看看你是不是没加sudo<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/4.png" alt="配置文件正确"></p>
<p>启动nginx服务器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ./nginx</span><br></pre></td></tr></table></figure><br>默认端口是80，所以直接到浏览器中直接敲入本地地址 127.0.0.1，显示【Welcome to nginx!】就代表nginx已经成功安装<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/5.png" alt=""></p>
<h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>创建推流存放文件夹<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 为里以 &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;hls 为例</span><br><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">sudo mkdir -p var&#x2F;www&#x2F;hls</span><br></pre></td></tr></table></figure><br>进入nginx的conf目录，使用vim编辑nginx.conf文件<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">sudo vim nginx.conf</span><br></pre></td></tr></table></figure><br>配置Nginx，支持http协议拉流<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location /hls &#123;</span><br><span class="line">  types &#123;</span><br><span class="line">    application/vnd.apple.mpegurl    m3u8;</span><br><span class="line">    video/mp2t ts;</span><br><span class="line">  &#125;</span><br><span class="line">  root /usr/local/var/www;</span><br><span class="line">   add_header Cache-Control    no-cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置Nginx，支持rtmp协议推流<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line">        application rtmplive &#123;</span><br><span class="line">            live on;</span><br><span class="line">            max_connections 1024;</span><br><span class="line">        &#125;</span><br><span class="line">        application hls&#123;</span><br><span class="line">            live on;</span><br><span class="line">            hls on;</span><br><span class="line">            hls_path /usr/local/var/www/hls;</span><br><span class="line">            hls_fragment 1s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/6.png" alt="hls"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/7.png" alt="rtmp"></p>
<p>重启nginx服务器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin/</span><br><span class="line">sudo ./nginx -s reload</span><br></pre></td></tr></table></figure></p>
<p>如果执行【sudo ./nginx -s reload】出现下面这个问题<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx: [error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)</span><br></pre></td></tr></table></figure><br>就使用nginx -c的参数指定nginx.conf文件的位置，接着再reload一下就好了<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p>
<p>我Ubuntu地址为192.168.123.191</p>
<p>推流至RTMP到服务器  <a href="rtmp://192.168.123.191:1935/rtmplive/lxf">rtmp://192.168.123.191:1935/rtmplive/lxf</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i 异形.契约.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp:&#x2F;&#x2F;192.168.123.191:1935&#x2F;rtmplive&#x2F;lxf</span><br></pre></td></tr></table></figure><br>推流至HLS到服务器  <a href="http://192.168.123.191/hls/lxf.m3u8" target="_blank" rel="noopener">http://192.168.123.191/hls/lxf.m3u8</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i 异形.契约.mp4 -vcodec libx264 -vprofile baseline -acodec aac -ar 44100 -strict -2 -ac 1 -f flv -s 1280x720 -q 10 rtmp:&#x2F;&#x2F;192.168.123.191:1935&#x2F;hls&#x2F;lxf</span><br></pre></td></tr></table></figure></p>
<p>如果出现如下错误说明你的电脑没安装ffmpeg<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-bash: ffmpeg: command not found</span><br></pre></td></tr></table></figure><br>使用Homebrew来安装FFmpeg<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 安装Homebrew</span><br><span class="line">ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br><span class="line">// 安装FFmpeg</span><br><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure></p>
<p>开始推流，终端上就开始不断的刷新推流信息<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/8.png" alt="开始推流"></p>
<p>我们可以用电脑上的VLC这个软件来测试是否推流成功<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/9.png" alt="VLC"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/10.png" alt="打开流"></p>
<p>OK，rmtp打开正常，hls就不演示了，一样的<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/Ubuntu安装nginx来搭建推流服务器/11.png" alt="rmtp打开成功"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RxSwift + MJRefresh 打造自动处理刷新控件状态</title>
    <url>/2017/10/24/RxSwift-MJRefresh-%E6%89%93%E9%80%A0%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E5%88%B7%E6%96%B0%E6%8E%A7%E4%BB%B6%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>MVVM的模式中，多出了ViewModel这个角色，将逻辑处理、网络请求等繁杂操作中ViewController中抽离出来，ViewController得以瘦身。<br>结合RxSwift架构，我们一般就会在ViewModel中定义一个input收集繁杂操作所需的信息，通过一个transform方法将input作为参数传入，进而得到一个output供controller使用。</p>
<p>在使用RxSwift开发时会大量的使用到这种形式，其中就包括我们的网络请求。</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>本文是基于 <a href="http://linxunfeng.top/2017/09/12/iOS-RxSwift-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/">iOS-RxSwift项目实战记录</a> 所述，如果你还未阅读过，建议你最好还先阅读一遍，并下载Demo熟悉一下 : )</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MVVM的模式中，多出了ViewModel这个角色，将逻辑处理、网络请求等繁杂操作中ViewController中抽离出来，ViewController得以瘦身。<br>结合RxSwift架构，我们一般就会在ViewModel中定义一个input收集繁杂操作所需的信息，通过一个transform方法将input作为参数传入，进而得到一个output供controller使用。</p>
<p>在使用RxSwift开发时会大量的使用到这种形式，其中就包括我们的网络请求。<br>结合 <a href="http://linxunfeng.top/2017/09/12/iOS-RxSwift-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/">iOS-RxSwift项目实战记录</a> 中所述的“MJRefresh在RxSwift中的使用”，在output中定义了一个变量<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> refreshStatus = <span class="type">Variable</span>&lt;<span class="type">LXFRefreshStatus</span>&gt;(.<span class="keyword">none</span>)</span><br></pre></td></tr></table></figure><br>controller通过output将其进行监听，从而当值发生变化时，controller就能实时获取当前应所处的刷新状态<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">vmOutput.refreshStatus.asObservable().subscribe(onNext: &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] status <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> status &#123;</span><br><span class="line">    <span class="keyword">case</span> .beingHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_header.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_header.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .beingFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_footer.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_footer.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .noMoreData:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_footer.endRefreshingWithNoMoreData()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).addDisposableTo(rx_disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>如果在一个项目多处使用到了这种方式，我们就可以看到弊端——重复代码，过于冗余。</p>
<p>难道我们每次都要在controller中进行如此操作吗？</p>
<h2 id="面向协议"><a href="#面向协议" class="headerlink" title="面向协议"></a>面向协议</h2><p>关于协议的内容可以看下我之前的这两篇文章<br><a href="http://linxunfeng.top/2017/09/12/iOS-Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/">iOS - Swift 面向协议编程（一）</a></p>
<p> <a href="http://linxunfeng.top/2017/09/12/iOS-Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/">iOS - Swift 面向协议编程（二）</a></p>
<p>总结协议的两大作用：1、规范  2、定制能力</p>
<p>定义协议 Refreshable </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ============================ Refreshable ================================ */</span></span><br><span class="line"><span class="comment">// 需要使用 MJExtension 的控制器使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Refreshable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Refreshable</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initRefreshHeader</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, <span class="number">_</span> action: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">MJRefreshHeader</span> &#123;</span><br><span class="line">        scrollView.mj_header = <span class="type">MJRefreshNormalHeader</span>(refreshingBlock: &#123; action() &#125;)</span><br><span class="line">        <span class="keyword">return</span> scrollView.mj_header</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">initRefreshFooter</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, <span class="number">_</span> action: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">MJRefreshFooter</span> &#123;</span><br><span class="line">        scrollView.mj_footer = <span class="type">MJRefreshAutoNormalFooter</span>(refreshingBlock: &#123; action() &#125;)</span><br><span class="line">        <span class="keyword">return</span> scrollView.mj_footer</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在controller中遵循 Refreshable 协议，通过initRefreshHeader方法或者initRefreshFooter方法给tableView或者collectionView赋予头部或尾部刷新的能力，并且书写下拉刷新时需要执行的代码<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下拉刷新为例</span></span><br><span class="line"><span class="keyword">let</span> refreshHeader = initRefreshHeader(liveCollectionView) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 下拉后需要执行的操作 </span></span><br><span class="line">    <span class="keyword">self</span>?.vmOutput?.requestCommand.onNext(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来再讲讲output，只要有网络请求的地方，就会需要需要监听请求状态，既然这样，那么可以为output定义一个协议OutputRefreshProtocol，专门用来规范必需声明的属性<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ============================ OutputRefreshProtocol ================================ */</span></span><br><span class="line"><span class="comment">// viewModel 中 output使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">OutputRefreshProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 告诉外界的tableView当前的刷新状态</span></span><br><span class="line">    <span class="keyword">var</span> refreshStatus : <span class="type">Variable</span>&lt;<span class="type">LXFRefreshStatus</span>&gt; &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接着让output去遵循该协议，并进行初始化刷新状态的值为.none<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct LXFLiveOutput: OutputRefreshProtocol &#123;</span><br><span class="line">    var refreshStatus: Variable&lt;LXFRefreshStatus&gt;</span><br><span class="line">    </span><br><span class="line">    let sections: Driver&lt;[LXFLiveSection]&gt;</span><br><span class="line">    init(sections: Driver&lt;[LXFLiveSection]&gt;) &#123;</span><br><span class="line">        self.sections &#x3D; sections</span><br><span class="line">        refreshStatus &#x3D; Variable&lt;LXFRefreshStatus&gt;(.none)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>到此为止，其实跟之前没啥两样，只是使controller更方便初始化刷新控件而已。接下来才是本文的重点。</p>
<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>刷新的状态无非也就那么几种，下拉重载数据，上拉加载更多，请求完成时结束下拉或上拉等等。。。那我们何必要在每个controller中再去管理这等琐事？？<br>而至此，刷新控件的状态是由变量 refreshStatus 来决定，此时 refreshStatus 又声明在 OutputRefreshProtocol 协议中，我们何不再定义一个方法，将刷新控件的状态交给refreshStatus自己来帮我们处理呢～</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">OutputRefreshProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">autoSetRefreshHeaderStatus</span><span class="params">(header: MJRefreshHeader?, footer: MJRefreshFooter?)</span></span> -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> refreshStatus.asObservable().subscribe(onNext: &#123; (status) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> status &#123;</span><br><span class="line">            <span class="keyword">case</span> .beingHeaderRefresh:</span><br><span class="line">                header?.beginRefreshing()</span><br><span class="line">            <span class="keyword">case</span> .endHeaderRefresh:</span><br><span class="line">                header?.endRefreshing()</span><br><span class="line">            <span class="keyword">case</span> .beingFooterRefresh:</span><br><span class="line">                footer?.beginRefreshing()</span><br><span class="line">            <span class="keyword">case</span> .endFooterRefresh:</span><br><span class="line">                footer?.endRefreshing()</span><br><span class="line">            <span class="keyword">case</span> .noMoreData:</span><br><span class="line">                footer?.endRefreshingWithNoMoreData()</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时需要我们将刷新控件的对象 header / footer 传入到方法中，实现自动控制刷新控件状态。</p>
<h2 id="总结使用"><a href="#总结使用" class="headerlink" title="总结使用"></a>总结使用</h2><p>一、output中遵守协议 OutputRefreshProtocol， 并初始化 refreshStatus 的值为 none</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LXFLiveOutput</span>: <span class="title">OutputRefreshProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> refreshStatus: <span class="type">Variable</span>&lt;<span class="type">LXFRefreshStatus</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> sections: <span class="type">Driver</span>&lt;[<span class="type">LXFLiveSection</span>]&gt;</span><br><span class="line">    <span class="keyword">init</span>(sections: <span class="type">Driver</span>&lt;[<span class="type">LXFLiveSection</span>]&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sections = sections</span><br><span class="line">        refreshStatus = <span class="type">Variable</span>&lt;<span class="type">LXFRefreshStatus</span>&gt;(.<span class="keyword">none</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、controller 遵守协议 Refreshable，通过协议中的方法初始化刷新控件及对应的操作，并将刷新控件对象作为参数传入到自动处理状态方法中<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LXFLiveViewController</span>: <span class="title">Refreshable</span></span></span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> refreshHeader = initRefreshHeader(liveCollectionView) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>?.vmOutput?.requestCommand.onNext(())</span><br><span class="line">&#125;</span><br><span class="line">vmOutput?.autoSetRefreshHeaderStatus(header: refreshHeader, footer: <span class="literal">nil</span>).disposed(by: rx.disposeBag)</span><br></pre></td></tr></table></figure></p>
<p>三、viewModel中根据实际情况实时更新 refreshStatus 的刷新状态</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/10/RxSwift-MJExtension-打造自动处理刷新控件状态/1.png" alt="image.png"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>协议：<a href="https://github.com/LinXunFeng/LXFBiliBili/blob/master/LXFBiliBili/LXFBiliBili/Classes/Common/Protocol/Lib/Refreshable.swift" target="_blank" rel="noopener">Refreshable.swift</a><br>ViewModel：<a href="https://github.com/LinXunFeng/LXFBiliBili/blob/master/LXFBiliBili/LXFBiliBili/Classes/Main/Home/Controller/Live/ViewModel/LXFLiveViewModel.swift" target="_blank" rel="noopener">LXFLiveViewModel</a><br>Controller：<a href="https://github.com/LinXunFeng/LXFBiliBili/blob/master/LXFBiliBili/LXFBiliBili/Classes/Main/Home/Controller/Live/LXFLiveViewController.swift" target="_blank" rel="noopener">LXFLiveViewController</a></p>
<p><a href="https://github.com/LinXunFeng/LXFBiliBili" target="_blank" rel="noopener">LXFBiliBili</a></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/10/RxSwift-MJExtension-打造自动处理刷新控件状态/2.gif" alt="LXFBiliBili"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 掌控Moya的网络请求、数据解析与缓存</title>
    <url>/2018/10/27/Swift-%E6%8E%8C%E6%8E%A7Moya%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E3%80%81%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<ul>
<li><code>Moya</code> 在Swift开发中起着重要的网络交互作用，但是还有不如之处，比如网络不可用时，返回的 <code>Response</code> 为 <code>nil</code>，这时还得去解析相应的 <code>Error</code></li>
<li><code>Codable</code> 可以帮助我们快速的解析数据，但是一旦声明的属性类型与json中的不一致，将无法正常解析; 而且对于模型中自定义属性名的处理也十分繁琐</li>
</ul>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>



<ul>
<li><code>Moya</code> 在Swift开发中起着重要的网络交互作用，但是还有不如之处，比如网络不可用时，返回的 <code>Response</code> 为 <code>nil</code>，这时还得去解析相应的 <code>Error</code></li>
<li><code>Codable</code> 可以帮助我们快速的解析数据，但是一旦声明的属性类型与json中的不一致，将无法正常解析; 而且对于模型中自定义属性名的处理也十分繁琐</li>
</ul>
<p>解决的方案有很多，不过我比较习惯使用 <code>MoyaMapper</code> ，不仅可以解决上述问题，还提供了多种<code>模型转换</code>、<code>数据互转</code>、<code>多种数据类型任意存储</code>的便捷方法。掌控Moya的网络请求、数据解析与缓存简直易如反掌。</p>
<blockquote>
<p><code>MoyaMapper</code>是基于Moya和SwiftyJSON封装的工具，以Moya的plugin的方式来实现间接解析，支持RxSwift</p>
<p> GitHub: <a href="https://github.com/MoyaMapper/MoyaMapper" target="_blank" rel="noopener">MoyaMapper</a></p>
<p>📖 详细的使用请查看手册 <a href="https://moyamapper.github.io/" target="_blank" rel="noopener">https://MoyaMapper.github.io</a></p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>支持<code>json</code> 转 <code>Model</code> 自动映射 与 自定义映射</li>
<li>无视 <code>json</code> 中值的类型，<code>Model</code> 中属性声明的是什么类型，它就是什么类型</li>
<li>支持 <code>Data</code> <code>字典</code> <code>JSON</code> <code>json字符串</code> <code>Model</code> 互转</li>
<li>插件方式，全方位保障<code>Moya.Response</code>，拒绝各种网络问题导致 <code>Response</code> 为 <code>nil</code>，将各式各样的原因导致的数据加载失败进行统一处理，开发者只需要关注 <code>Response</code></li>
<li>可选 - 支持数据随意缓存( <code>JSON</code> 、 <code>Number</code> 、<code>String</code>、 <code>Bool</code>、 <code>Moya.Response</code> )</li>
<li>可选 - 支持网络请求缓存</li>
</ul>
<h2 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h2><h5 id="一、插件注入"><a href="#一、插件注入" class="headerlink" title="一、插件注入"></a>一、插件注入</h5><p>附：<a href="https://moyamapper.github.io/plugin/" target="_blank" rel="noopener">插件 MoyaMapperPlugin 的详细使用</a></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/success-obj.png" alt=""></p>
<p>1、定义适用于项目接口的 <code>ModelableParameterType</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// statusCodeKey、tipStrKey、 modelKey 可以任意指定级别的路径，如： "error&gt;used"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetParameter</span> : <span class="title">ModelableParameterType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> successValue = <span class="string">"000"</span></span><br><span class="line">    <span class="keyword">var</span> statusCodeKey = <span class="string">"retStatus"</span></span><br><span class="line">    <span class="keyword">var</span> tipStrKey = <span class="string">"retMsg"</span></span><br><span class="line">    <span class="keyword">var</span> modelKey = <span class="string">"retBody"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在 <code>MoyaProvider</code> 中使用 <code>MoyaMapperPlugin</code> 插件，并指定 <code>ModelableParameterType</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lxfNetTool = <span class="type">MoyaProvider</span>&lt;<span class="type">LXFNetworkTool</span>&gt;(plugins: [<span class="type">MoyaMapperPlugin</span>(<span class="type">NetParameter</span>())])</span><br></pre></td></tr></table></figure>
<p>❗ 使用 <code>MoyaMapperPlugin</code> 插件是整个 <code>MoyaMapper</code>  的核心所在！</p>
<h5 id="二、Model声明"><a href="#二、Model声明" class="headerlink" title="二、Model声明"></a>二、Model声明</h5><blockquote>
<p><code>Model</code> 需遵守 <code>Modelable</code> 协议</p>
<ul>
<li><code>MoyaMapper</code> 支持模型自动映射 和 自定义映射</li>
<li>不需要考虑源json数据的真实类型，这里统一按 <code>Model</code> 中属性声明的类型进行转换</li>
</ul>
</blockquote>
<p>1、一般情况下如下写法即可</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompanyModel</span>: <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> catchPhrase : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、如果自定义映射，则可以实现方法 <code>mutating func mapping(_ json: JSON)</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CompanyModel</span>: <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> catchPhrase : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="number">_</span> json: JSON)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = json[<span class="string">"nickname"</span>].stringValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、支持模型嵌套</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserModel</span>: <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> id : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> name : <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> company : <span class="type">CompanyModel</span> = <span class="type">CompanyModel</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="三、Response-解析"><a href="#三、Response-解析" class="headerlink" title="三、Response 解析"></a>三、Response 解析</h5><blockquote>
<p>1、以下示例皆使用了 <code>MoyaMapperPlugin</code> ，所以不需要指定 <code>解析路径</code></p>
<p>2、如果没有使用 <code>MoyaMapperPlugin</code> 则需要指定 <code>解析路径</code>，否则无法正常解析</p>
<p>ps:  <code>解析路径</code> 可以使用 <code>a&gt;b</code> 这种形式来解决多级路径的问题</p>
</blockquote>
<p>解析方法如下列表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:left">描述 (支持RxSwift)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">toJSON</td>
<td style="text-align:left">Response 转 JSON ( <a href="https://moyamapper.github.io/core/toJSON/" target="_blank" rel="noopener">toJSON</a>   <a href="https://moyamapper.github.io/rx/toJSON/" target="_blank" rel="noopener">rx.toJSON</a>)</td>
</tr>
<tr>
<td style="text-align:center">fetchString</td>
<td style="text-align:left">获取指定路径的字符串( <a href="https://moyamapper.github.io/core/fetchString/" target="_blank" rel="noopener">fetchString</a>   <a href="https://moyamapper.github.io/rx/fetchString/" target="_blank" rel="noopener">rx.fetchString</a>)</td>
</tr>
<tr>
<td style="text-align:center">fetchJSONString</td>
<td style="text-align:left">获取指定路径的原始json字符串 ( <a href="https://moyamapper.github.io/core/fetchJSONString/" target="_blank" rel="noopener">fetchJSONString</a>   <a href="https://moyamapper.github.io/rx/fetchJSONString/" target="_blank" rel="noopener">rx.fetchJSONString</a> )</td>
</tr>
<tr>
<td style="text-align:center">mapResult</td>
<td style="text-align:left">Response -&gt; MoyaMapperResult   <code>(Bool, String)</code> ( <a href="https://moyamapper.github.io/core/mapResult/" target="_blank" rel="noopener">mapResult</a>   <a href="https://moyamapper.github.io/rx/mapResult/" target="_blank" rel="noopener">rx.mapResult</a> )</td>
</tr>
<tr>
<td style="text-align:center">mapObject</td>
<td style="text-align:left">Response -&gt; Model ( <a href="https://moyamapper.github.io/core/mapObject/" target="_blank" rel="noopener">mapObject</a>   <a href="https://moyamapper.github.io/rx/mapObject/" target="_blank" rel="noopener">rx.mapObject</a>)</td>
</tr>
<tr>
<td style="text-align:center">mapObjResult</td>
<td style="text-align:left">Response -&gt; (MoyaMapperResult, Model) ( <a href="https://moyamapper.github.io/core/mapObjResult/" target="_blank" rel="noopener">mapObjResult</a>   <a href="https://moyamapper.github.io/rx/mapObjResult/" target="_blank" rel="noopener">rx.mapObjResult</a>)</td>
</tr>
<tr>
<td style="text-align:center">mapArray</td>
<td style="text-align:left">Response -&gt; [Model] ( <a href="https://moyamapper.github.io/core/mapArray/" target="_blank" rel="noopener">mapArray</a>  <a href="https://moyamapper.github.io/rx/mapArray/" target="_blank" rel="noopener">rx.mapArray</a>)</td>
</tr>
<tr>
<td style="text-align:center">mapArrayResult</td>
<td style="text-align:left">Response -&gt; (MoyaMapperResult, [Model]) ( <a href="https://moyamapper.github.io/core/mapArrayResult/" target="_blank" rel="noopener">mapArrayResult</a>   <a href="https://moyamapper.github.io/rx/mapArrayResult/" target="_blank" rel="noopener">rx.mapArrayResult</a>)</td>
</tr>
</tbody>
</table>
<p>❗除了 <code>fetchJSONString</code> 的默认解析路径是<code>根路径</code>之外，其它方法的默认解析路径为插件对象中的 <code>modelKey</code></p>
<p>如果接口请求后 <code>json</code> 的数据结构与下图类似，则使用 <code>MoyaMapper</code> 是最合适不过了</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/success-obj.png" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Normal</span></span><br><span class="line"><span class="keyword">let</span> model = response.mapObject(<span class="type">MMModel</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"name -- \(model.name)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"github -- \(model.github)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印json</span></span><br><span class="line"><span class="built_in">print</span>(response.fetchJSONString())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx</span></span><br><span class="line">rxRequest.mapObject(<span class="type">MMModel</span>.<span class="keyword">self</span>)</span><br><span class="line">    .subscribe(onSuccess: &#123; (model) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"name -- \(model.name)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"github -- \(model.github)"</span>)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>附： <a href="https://moyamapper.github.io/core/fetchJSONString/" target="_blank" rel="noopener">fetchJSONString的详细使用</a></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/success-array.png" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Normal</span></span><br><span class="line"><span class="keyword">let</span> models = response.mapArray(<span class="type">MMModel</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="keyword">let</span> name = models[<span class="number">0</span>].name</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"count -- \(models.count)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"name -- \(name)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 json 模型数组中第一个的name</span></span><br><span class="line"><span class="built_in">print</span>(response.fetchString(keys: [<span class="number">0</span>, <span class="string">"name"</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx</span></span><br><span class="line">rxRequest.mapArray(<span class="type">MMModel</span>.<span class="keyword">self</span>)</span><br><span class="line">    .subscribe(onSuccess: &#123; models <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> name = models[<span class="number">0</span>].name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"count -- \(models.count)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"name -- \(name)"</span>)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>附：<a href="https://moyamapper.github.io/core/mapArray/" target="_blank" rel="noopener">mapArray的详细使用说明</a></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/fail.png" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Normal</span></span><br><span class="line"><span class="keyword">let</span> (isSuccess, tipStr) = response.mapResult()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"isSuccess -- \(isSuccess)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"tipStr -- \(tipStr)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx</span></span><br><span class="line">rxRequest.mapResult()</span><br><span class="line">    .subscribe(onSuccess: &#123; (isSuccess, tipStr) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"isSuccess -- \(isSuccess)"</span>) <span class="comment">// 是否为 "000"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"retMsg -- \(retMsg)"</span>) <span class="comment">// "缺少必要参数"</span></span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>附：<a href="https://moyamapper.github.io/core/mapResult/" target="_blank" rel="noopener">mapResult的详细使用说明</a></p>
<h2 id="统一处理网络请求结果"><a href="#统一处理网络请求结果" class="headerlink" title="统一处理网络请求结果"></a>统一处理网络请求结果</h2><blockquote>
<p>在APP的实际使用过程中，会遇到各种各样的网络请求结果，如:服务器挂了、手机无网络，此时 <code>Moya</code> 返回的 <code>Response</code> 为 nil，这样我们就不得不去判断 <code>Error</code>。但是使用 <code>MoyaMapperPlugin</code> 就可以让我们只关注 <code>Response</code></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MoyaMapperPlugin 的初始化方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">T</span>: <span class="type">ModelableParameterType</span>&gt;(</span><br><span class="line">    <span class="number">_</span> type: <span class="type">T</span>,</span><br><span class="line">    transformError: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type : <span class="type">ModelableParameterType</span>  用于定义字段路径，做为全局解析数据的依据</span><br><span class="line">transformError : <span class="type">Bool</span>  是否当网络请求失败时，自动转换请求结果，默认为 <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当请求失败的时候，此时的 <code>result.response</code> 为 <code>nil</code>，根据<code>transformError</code>是否为<code>true</code> 判断是否创建一个自定义的 <code>response</code> 并返回出去。</li>
</ul>
<p>➡ 本来可以请求到的数据内容</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/success-obj.png" alt=""></p>
<p>➡ 现在关闭网络，再请求数据</p>
<ul>
<li><p>正常情况下，即不做任何不处理的时候， <code>Response</code> 为 <code>nil</code> </p>
</li>
<li><p>经过 <code>MoyaMapperPlugin</code> 处理的后可得到转换后的 <code>Response</code> ，如图</p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/10/Swift-掌控Moya的网络请求、数据解析与缓存/plugin.png" alt=""></p>
<p>这里将请求失败进行了统一处理，无论是服务器还是自身网络的问题，<code>retStatus</code> 都为 MMStatusCode.loadFail，但是 errorDescription 会保持原来的样子并赋值给 <code>retMsg</code>。</p>
<blockquote>
<ul>
<li><code>retStatus</code> 值会从枚举 <code>MMStatusCode</code> 中取  <code>loadFail.rawValue</code> ，即 <code>700</code> </li>
<li>取 类型为 <code>ModelableParameterType</code>  的 <code>type</code> 中 <code>statusCodeKey</code> 所指定的值 为键名，<code>retMsg</code>也同理</li>
</ul>
</blockquote>
<p>ps: 这个时候可以通过判断 <code>retStatus</code> 或 <code>response.statusCode</code> 是否与 <code>MMStatusCode.loadFail.rawValue</code> 相同来判断是否显示加载失败的空白页占位图</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MMStatusCode</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> cache = <span class="number">230</span></span><br><span class="line">    <span class="keyword">case</span> loadFail = <span class="number">700</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举 <code>MMStatusCode</code> 中除了 <code>loadFail</code> ，还有 <code>cache</code>，我们已经知道 <code>loadFail</code> 在数据加载失败的时候会出现，那 <code>cache</code> 是在什么时候出来呢？不急，看下一节就知道了。</p>
<h2 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h2><h5 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 缓存</span><br><span class="line">@discardableResult</span><br><span class="line">MMCache.shared.cache&#96;XXX&#96;(value : XXX, key: String, cacheContainer: MMCache.CacheContainer &#x3D; .RAM)  -&gt; Bool</span><br><span class="line">&#x2F;&#x2F; 取舍</span><br><span class="line">MMCache.shared.fetch&#96;XXX&#96;Cache(key: String, cacheContainer: MMCache.CacheContainer &#x3D; .RAM)</span><br></pre></td></tr></table></figure>
<p>缓存成功会返回一个 <code>Bool</code> 值，这里可不接收</p>
<table>
<thead>
<tr>
<th>XXX 所支持类型</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Bool</td>
<td>-</td>
</tr>
<tr>
<td>Float</td>
<td>-</td>
</tr>
<tr>
<td>Double</td>
<td>-</td>
</tr>
<tr>
<td>String</td>
<td>-</td>
</tr>
<tr>
<td>JSON</td>
<td>-</td>
</tr>
<tr>
<td>Modelable</td>
<td>[Modelable]</td>
</tr>
<tr>
<td>Moya.Response</td>
<td>-</td>
</tr>
<tr>
<td>Int</td>
<td>UInt</td>
</tr>
<tr>
<td>Int8</td>
<td>UInt8</td>
</tr>
<tr>
<td>Int16</td>
<td>UInt16</td>
</tr>
<tr>
<td>Int32</td>
<td>UInt32</td>
</tr>
<tr>
<td>Int64</td>
<td>UInt64</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其中，除了 <code>Moya.Response</code> 之外，其它类型皆是通过 <code>JSON</code> 来实现缓存</p>
</blockquote>
<p>所以，如果你想清除这些类型的缓存，只需要调用如下方法即可</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeJSONCache</span><span class="params">(<span class="number">_</span> key: String, cacheContainer: MMCache.CacheContainer = .RAM)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAllJSONCache</span><span class="params">(cacheContainer: MMCache.CacheContainer = .RAM)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>清除 <code>Moya.Response</code> 则使用如下两个方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeResponseCache</span><span class="params">(<span class="number">_</span> key: String)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@discardableResult</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeAllResponseCache</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>再来看看MMCache.CacheContainer</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CacheContainer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RAM</span> 	<span class="comment">// 只缓存于内存的容器</span></span><br><span class="line">    <span class="keyword">case</span> hybrid <span class="comment">// 缓存于内存与磁盘的容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两种容器互不相通，即 即使key相同，使用 <code>hybrid</code> 来缓存后，再通过 <code>RAM</code> 取值是取不到的。</p>
</blockquote>
<ul>
<li>RAM : 仅缓存于内存之中，缓存的数据在APP使用期间一直存在</li>
<li>hybrid ：缓存于内存与磁盘中，APP重启后也可以获取到数据</li>
</ul>
<h5 id="二、缓存网络请求"><a href="#二、缓存网络请求" class="headerlink" title="二、缓存网络请求"></a>二、缓存网络请求</h5><p>内部缓存过程：</p>
<ol>
<li>APP首次启动并进行网络请求，网络数据将缓存起来</li>
<li>APP再次启动并进行网络请求时，会先返回缓存的数据，等请求成功后再返回网络数据</li>
<li>其它情况只会加载网络数据</li>
<li>每次成功请求到数据后，都会对缓存的数据进行更新</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Normal</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> target: Target, </span></span></span><br><span class="line"><span class="function"><span class="params">    cacheType: MMCache.CacheKeyType = .<span class="keyword">default</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    callbackQueue: DispatchQueue? = <span class="literal">nil</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    progress: Moya.ProgressBlock? = <span class="literal">nil</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    completion: @escaping Moya.Completion</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Cancellable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> target: Base.Target, </span></span></span><br><span class="line"><span class="function"><span class="params">    callbackQueue: DispatchQueue? = <span class="literal">nil</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    cacheType: MMCache.CacheKeyType = .<span class="keyword">default</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Response</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上是对 <code>Moya</code> 请求后的 <code>Response</code> 进行缓存。 其实与 <code>Moya</code> 自带的方法相比较只多了一个参数 <code>cacheType: MMCache.CacheKeyType</code> ，定义着缓存中的 <code>key</code> ，默认为 <code>default</code> </p>
</blockquote>
<p>下面是 <code>MMCache.CacheKeyType</code> 的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> let cacheKey &#x3D; [method]baseURL&#x2F;path</span><br><span class="line"> </span><br><span class="line"> - default : cacheKey + &quot;?&quot; + parameters</span><br><span class="line"> - base : cacheKey</span><br><span class="line"> - custom : cacheKey + &quot;?&quot; + customKey</span><br><span class="line"> *&#x2F;</span><br><span class="line">public enum CacheKeyType &#123;</span><br><span class="line">    case &#96;default&#96;</span><br><span class="line">    case base</span><br><span class="line">    case custom(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你想缓存<code>多页</code>列表数据的<code>最新一页</code>数据，此时使用 <code>default</code> 是不合适的，因为 <code>default</code> 使用的 <code>key</code> 包含了 <code>pageIndex</code>，这样就达不到只缓存 <code>最新一页数据</code> 的目的， 所以这里应该使用 <code>base</code> 或者 <code>custom(String)</code> </p>
</blockquote>
<p>我们可以来试一下带缓存的请求</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * APP第一次启动并进行网络请求，网络数据将缓存起来</span></span><br><span class="line"><span class="comment"> * APP再次启动并进行网络请求时，会先加载缓存，再加载网络数据</span></span><br><span class="line"><span class="comment"> * 其它情况只会加载网络数据</span></span><br><span class="line"><span class="comment"> * 每次成功请求到数据都会进行数据更新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lxfNetTool.rx.cacheRequest(.data(type: .all, size: <span class="number">10</span>, index: <span class="number">1</span>))</span><br><span class="line">    .subscribe(onNext: &#123; response <span class="keyword">in</span></span><br><span class="line">        log.debug(<span class="string">"statusCode -- \(response.statusCode)"</span>)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">let _ = lxfNetTool.cacheRequest(.data(type: .all, size: 10, index: 1)) &#123; result in</span></span><br><span class="line"><span class="comment">    guard let resp = result.value else &#123; return &#125;</span></span><br><span class="line"><span class="comment">    log.debug("statusCode -- \(resp.statusCode)")</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 首次使用APP</span><br><span class="line">statusCode -- 200</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 关闭并重新打开APP，再请求一下</span><br><span class="line">statusCode -- 230</span><br><span class="line">statusCode -- 200</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 然后再请求一下</span><br><span class="line">statusCode -- 200</span><br></pre></td></tr></table></figure>
<p>这里的 <code>230</code> 就是 <code>MMStatusCode.cache.rawValue</code></p>
<h2 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h2><ul>
<li>默认安装</li>
</ul>
<p>MoyaMapper默认只安装Core下的文件<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">'MoyaMapper'</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>RxSwift拓展</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">'MoyaMapper/Rx'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存拓展</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">'MoyaMapper/MMCache'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Rx缓存</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod <span class="string">'MoyaMapper/RxCache'</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-RxSwift项目实战记录</title>
    <url>/2017/09/12/iOS-RxSwift-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>最近刚刚把接手的OC项目搞定，经过深思熟虑后，本人决定下个项目起就使用Swift(学了这么久的Swift还没真正用到实际项目里。。。)，而恰巧RxSwift已经出来有一些时间了，语法也基本上稳定，遂只身前来试探试探这RxSwift，接着就做了个小Demo，有兴趣的同学可以瞧一瞧~</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-RxSwift项目实战记录/1.png" alt="ReactiveX"></p>
<blockquote>
<p>最近刚刚把接手的OC项目搞定，经过深思熟虑后，本人决定下个项目起就使用Swift(学了这么久的Swift还没真正用到实际项目里。。。)，而恰巧RxSwift已经出来有一些时间了，语法也基本上稳定，遂只身前来试探试探这RxSwift，接着就做了个小Demo，有兴趣的同学可以瞧一瞧~</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/09/iOS-RxSwift项目实战记录/2.gif" alt="Exhibition"></p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Controller</span><br><span class="line">│   └── LXFViewController.swift		&#x2F;&#x2F; 主视图控制器</span><br><span class="line">├── Extension</span><br><span class="line">│   └── Response+ObjectMapper.swift	&#x2F;&#x2F; Response分类，Moya请求完进行Json转模型或模型数组</span><br><span class="line">├── Model</span><br><span class="line">│   └── LXFModel.swift				&#x2F;&#x2F; 模型</span><br><span class="line">├── Protocol</span><br><span class="line">│   └── LXFViewModelType.swift		&#x2F;&#x2F; 定义了模型协议</span><br><span class="line">├── Tool</span><br><span class="line">│   ├── LXFNetworkTool.swift		&#x2F;&#x2F; 封装Moya请求</span><br><span class="line">│   └── LXFProgressHUD.swift		&#x2F;&#x2F; 封装的HUD</span><br><span class="line">├── View</span><br><span class="line">│   ├── LXFViewCell.swift			&#x2F;&#x2F; 自定义cell</span><br><span class="line">│   └── LXFViewCell.xib				&#x2F;&#x2F; cell的xib文件</span><br><span class="line">└── ViewModel</span><br><span class="line">    └── LXFViewModel.swift			&#x2F;&#x2F; 视图模型</span><br></pre></td></tr></table></figure>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RxSwift			&#x2F;&#x2F; 想玩RxSwift的必备库</span><br><span class="line">RxCocoa 		&#x2F;&#x2F; 对 UIKit Foundation 进行 Rx 化</span><br><span class="line">NSObject+Rx		&#x2F;&#x2F; 为我们提供 rx_disposeBag </span><br><span class="line">Moya&#x2F;RxSwift 	&#x2F;&#x2F; 为RxSwift专用提供，对Alamofire进行封装的一个网络请求库</span><br><span class="line">ObjectMapper 	&#x2F;&#x2F; Json转模型之必备良品</span><br><span class="line">RxDataSources	&#x2F;&#x2F; 帮助我们优雅的使用tableView的数据源方法</span><br><span class="line">Then 			&#x2F;&#x2F; 提供快速初始化的语法糖</span><br><span class="line">Kingfisher		&#x2F;&#x2F; 图片加载库</span><br><span class="line">SnapKit			&#x2F;&#x2F; 视图约束库</span><br><span class="line">Reusable 		&#x2F;&#x2F; 帮助我们优雅的使用自定义cell和view,不再出现Optional</span><br><span class="line">MJRefresh 		&#x2F;&#x2F; 上拉加载、下拉刷新的库</span><br><span class="line">SVProgressHUD 	&#x2F;&#x2F; 简单易用的HUD</span><br></pre></td></tr></table></figure>
<h2 id="敲黑板"><a href="#敲黑板" class="headerlink" title="敲黑板"></a>敲黑板</h2><h3 id="Moya的使用"><a href="#Moya的使用" class="headerlink" title="Moya的使用"></a>Moya的使用</h3><p>Moya是基于Alamofire的网络请求库，这里我使用了Moya/Swift，它在Moya的基础上添加了对RxSwift的接口支持。接下来我们来说下Moya的使用</p>
<p>一、创建一个枚举，用来存放请求类型，这里我顺便设置相应的路径，等下统一取出来直接赋值即可<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LXFNetworkTool</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">LXFNetworkCategory</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> all     = <span class="string">"all"</span></span><br><span class="line">        <span class="keyword">case</span> android = <span class="string">"Android"</span></span><br><span class="line">        <span class="keyword">case</span> ios     = <span class="string">"iOS"</span></span><br><span class="line">        <span class="keyword">case</span> welfare = <span class="string">"福利"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> data(type: <span class="type">LXFNetworkCategory</span>, size:<span class="type">Int</span>, index:<span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>二、为这个枚举写一个扩展，并遵循塄 TargetType，这个协议的Moya这个库规定的协议，可以按住Commond键+单击左键进入相应的文件进行查看<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LXFNetworkTool</span>: <span class="title">TargetType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// baseURL 统一基本的URL</span></span><br><span class="line">    <span class="keyword">var</span> baseURL: <span class="type">URL</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URL</span>(string: <span class="string">"http://gank.io/api/data/"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// path字段会追加至baseURL后面</span></span><br><span class="line">    <span class="keyword">var</span> path: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .data(<span class="keyword">let</span> type, <span class="keyword">let</span> size, <span class="keyword">let</span> index):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"\(type.rawValue)/\(size)/\(index)"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// HTTP的请求方式</span></span><br><span class="line">    <span class="keyword">var</span> method: <span class="type">Moya</span>.<span class="type">Method</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .<span class="keyword">get</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 请求参数(会在请求时进行编码)</span></span><br><span class="line">    <span class="keyword">var</span> parameters: [<span class="type">String</span>: <span class="type">Any</span>]? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 参数编码方式(这里使用URL的默认方式)</span></span><br><span class="line">    <span class="keyword">var</span> parameterEncoding: <span class="type">ParameterEncoding</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">URLEncoding</span>.<span class="keyword">default</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 这里用于单元测试，不需要的就像我一样随便写写</span></span><br><span class="line">    <span class="keyword">var</span> sampleData: <span class="type">Data</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"LinXunFeng"</span>.data(using: .utf8)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 将要被执行的任务(请求：request 下载：upload 上传：download)</span></span><br><span class="line">    <span class="keyword">var</span> task: <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> .request</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 是否执行Alamofire验证，默认值为false</span></span><br><span class="line">    <span class="keyword">var</span> validate: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>三、定义一个全局变量用于整个项目的网络请求<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lxfNetTool = <span class="type">RxMoyaProvider</span>&lt;<span class="type">LXFNetworkTool</span>&gt;()</span><br></pre></td></tr></table></figure><br>至此，我们就可以使用这个全局变量来请求数据了</p>
<h3 id="RxDataSources"><a href="#RxDataSources" class="headerlink" title="RxDataSources"></a>RxDataSources</h3><p>如果你想用传统的方式也行，不过这就失去了使用RxSwift的意义。好吧，我们接下来说说如何优雅的来实现tableView的数据源。其实<a href="https://github.com/RxSwiftCommunity/RxDataSources" target="_blank" rel="noopener">RxDataSources</a>官网上已经有很明确的使用说明，不过我还是总结一下整个过程吧。</p>
<p>概念点<br>RxDataSources是以section来做为数据结构来传输，这点很重要，可能很多同学会比较疑惑这句话吧，我在此举个例子，在传统的数据源实现的方法中有一个numberOfSection，我们在很多情况下只需要一个section，所以这个方法可实现，也可以不实现，默认返回的就是1，这给我们带来的一个迷惑点：【tableView是由row来组成的】，不知道在坐的各位中有没有是这么想的呢？？有的话那从今天开始就要认清楚这一点，【tableView其实是由section组成的】，所以在使用RxDataSources的过程中，即使你的setion只有一个，那你也得返回一个section的数组出去！！！</p>
<p>一、自定义Section<br>在我们自定义的Model中创建一个Section的结构体，并且创建一个扩展，遵循SectionModelType协议，实现相应的协议方法。约定俗成的写法呢请参考如下方式<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFModel</span>.swift</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LXFSection</span> </span>&#123;</span><br><span class="line">    <span class="comment">// items就是rows</span></span><br><span class="line">    <span class="keyword">var</span> items: [<span class="type">Item</span>]</span><br><span class="line">  	<span class="comment">// 你也可以这里加你需要的东西，比如 headerView 的 title</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LXFSection</span>: <span class="title">SectionModelType</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 重定义 Item 的类型为 LXFModel</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Item</span> = <span class="type">LXFModel</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现协议中的方式</span></span><br><span class="line">    <span class="keyword">init</span>(original: <span class="type">LXFSection</span>, items: [<span class="type">LXFSection</span>.<span class="type">Item</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span> = original</span><br><span class="line">        <span class="keyword">self</span>.items = items</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>二、在控制器下创建一个数据源属性</p>
<p>以下代码均在 LXFViewController.swift 文件中<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个数据源属性，类型为自定义的Section类型</span></span><br><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="type">LXFSection</span>&gt;()</span><br></pre></td></tr></table></figure><br>使用数据源属性绑定我们的cell<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定cell</span></span><br><span class="line">dataSource.configureCell = &#123; ds, tv, ip, item <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 这个地方使用了Reusable这个库，在LXFViewCell中遵守了相应的协议</span></span><br><span class="line">	<span class="comment">// 使其方便转换cell为非可选型的相应的cell类型</span></span><br><span class="line">    <span class="keyword">let</span> cell = tv.dequeueReusableCell(<span class="keyword">for</span>: ip) <span class="keyword">as</span> <span class="type">LXFViewCell</span></span><br><span class="line">    cell.picView.kf.setImage(with: <span class="type">URL</span>(string: item.url))</span><br><span class="line">    cell.descLabel.text = <span class="string">"描述: \(item.desc)"</span></span><br><span class="line">    cell.sourceLabel.text = <span class="string">"来源: \(item.source)"</span></span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>三、将sections序列绑定给我们的rows<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">output.sections.asDriver().drive(tableView.rx.items(dataSource:dataSource)).addDisposableTo(rx_disposeBag)</span><br></pre></td></tr></table></figure><br>大功告成，接下来说说section序列的产生</p>
<h3 id="ViewModel的规范"><a href="#ViewModel的规范" class="headerlink" title="ViewModel的规范"></a>ViewModel的规范</h3><p>我们知道MVVM思想就是将原本在ViewController的视图显示逻辑、验证逻辑、网络请求等代码存放于ViewModel中，让我们手中的ViewController瘦身。这些逻辑由ViewModel负责，外界不需要关心，外界只需要结果，ViewModel也只需要将结果给到外界，基于此，我们定义了一个协议LXFViewModelType</p>
<p>一、创建一个LXFViewModelType.swift<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFViewModelType</span>.swift</span><br><span class="line"></span><br><span class="line"><span class="comment">// associatedtype 关键字 用来声明一个类型的占位符作为协议定义的一部分</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LXFViewModelType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Input</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Output</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(input: Input)</span></span> -&gt; <span class="type">Output</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>二、viewModel遵守LXFViewModelType协议</p>
<ol>
<li>我们可以为XFViewModelType的Input和Output定义别名，以示区分，如：你这个viewModel的用于请求首页模块相关联的，则可以命名为：HomeInput 和 HomeOutput</li>
<li>我们可以丰富我们的 Input 和 Output 。可以看到我为Output添加了一个序列，类型为我们自定义的LXFSection数组，在Input里面添加了一个请求类型(即要请求什么数据，比如首页的数据)</li>
<li>我们通过 transform 方法将input携带的数据进行处理，生成了一个Output</li>
</ol>
<p><strong>注意： 以下代码为了方便阅读，进行了部分删减</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFViewModel</span>.swift</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LXFViewModel</span>: <span class="title">LXFViewModelType</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 存放着解析完成的模型数组</span></span><br><span class="line">   <span class="keyword">let</span> models = <span class="type">Variable</span>&lt;[<span class="type">LXFModel</span>]&gt;([])</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 为LXFViewModelType的Input和Output定义别名</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Input</span> = <span class="type">LXFInput</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Output</span> = <span class="type">LXFOutput</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 丰富我们的Input和Output</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LXFInput</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 网络请求类型</span></span><br><span class="line">        <span class="keyword">let</span> category: <span class="type">LXFNetworkTool</span>.<span class="type">LXFNetworkCategory</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">init</span>(category: <span class="type">LXFNetworkTool</span>.<span class="type">LXFNetworkCategory</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.category = category</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LXFOutput</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tableView的sections数据</span></span><br><span class="line">        <span class="keyword">let</span> sections: <span class="type">Driver</span>&lt;[<span class="type">LXFSection</span>]&gt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">init</span>(sections: <span class="type">Driver</span>&lt;[<span class="type">LXFSection</span>]&gt;) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sections = sections</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transform</span><span class="params">(input: LXFViewModel.LXFInput)</span></span> -&gt; <span class="type">LXFViewModel</span>.<span class="type">LXFOutput</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> sections = models.asObservable().<span class="built_in">map</span> &#123; (models) -&gt; [<span class="type">LXFSection</span>] <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 当models的值被改变时会调用，这是Variable的特性</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="type">LXFSection</span>(items: models)] <span class="comment">// 返回section数组</span></span><br><span class="line">        &#125;.asDriver(onErrorJustReturn: [])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> output = <span class="type">LXFOutput</span>(sections: sections)</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">// 接下来的代码是网络请求，请结合项目查看，不然会不方便阅读和理解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们在ViewController中初始化我们的input，通过transform得到output，然后将我们output中的sections序列绑定tableView的items<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">LXFViewController</span>.swift</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化input</span></span><br><span class="line"><span class="keyword">let</span> vmInput = <span class="type">LXFViewModel</span>.<span class="type">LXFInput</span>(category: .welfare)</span><br><span class="line"><span class="comment">// 通过transform得到output</span></span><br><span class="line"><span class="keyword">let</span> vmOutput = viewModel.transform(input: vmInput)</span><br><span class="line"></span><br><span class="line">vmOutput.sections.asDriver().drive(tableView.rx.items(dataSource: dataSource)).addDisposableTo(rx_disposeBag)</span><br></pre></td></tr></table></figure></p>
<h3 id="RxSwift中使用MJRefresh"><a href="#RxSwift中使用MJRefresh" class="headerlink" title="RxSwift中使用MJRefresh"></a>RxSwift中使用MJRefresh</h3><p>一、定义一个枚举LXFRefreshStatus，用于标志当前刷新状态<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LXFRefreshStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> beingHeaderRefresh</span><br><span class="line">    <span class="keyword">case</span> endHeaderRefresh</span><br><span class="line">    <span class="keyword">case</span> beingFooterRefresh</span><br><span class="line">    <span class="keyword">case</span> endFooterRefresh</span><br><span class="line">    <span class="keyword">case</span> noMoreData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>二、在LXFOutput添加一个refreshStatus序列，类型为LXFRefreshStatus<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给外界订阅，告诉外界的tableView当前的刷新状态</span></span><br><span class="line"><span class="keyword">let</span> refreshStatus = <span class="type">Variable</span>&lt;<span class="type">LXFRefreshStatus</span>&gt;(.<span class="keyword">none</span>)</span><br></pre></td></tr></table></figure><br>我们在进行网络请求并得到结果之后，修改refreshStatus的value为相应的LXFRefreshStatus项</p>
<p>三、外界订阅output的refreshStatus</p>
<p>外界订阅output的refreshStatus，并且根据接收到的值进行相应的操作<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">vmOutput.refreshStatus.asObservable().subscribe(onNext: &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] status <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> status &#123;</span><br><span class="line">    <span class="keyword">case</span> .beingHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_header.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endHeaderRefresh:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_header.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .beingFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_footer.beginRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .endFooterRefresh:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_footer.endRefreshing()</span><br><span class="line">    <span class="keyword">case</span> .noMoreData:</span><br><span class="line">        <span class="keyword">self</span>?.tableView.mj_footer.endRefreshingWithNoMoreData()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).addDisposableTo(rx_disposeBag)</span><br></pre></td></tr></table></figure><br>四、output提供一个requestCommond用于请求数据</p>
<p>PublishSubject 的特点：即可以作为Observable，也可以作为Observer，说白了就是可以发送信号，也可以订阅信号<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外界通过该属性告诉viewModel加载数据（传入的值是为了标志是否重新加载）</span></span><br><span class="line"><span class="keyword">let</span> requestCommond = <span class="type">PublishSubject</span>&lt;<span class="type">Bool</span>&gt;()</span><br></pre></td></tr></table></figure><br>在transform中，我们对生成的output的requestCommond进行订阅<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">output.requestCommond.subscribe(onNext: &#123;[<span class="keyword">unowned</span> <span class="keyword">self</span>] isReloadData <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.index = isReloadData ? <span class="number">1</span> : <span class="keyword">self</span>.index+<span class="number">1</span></span><br><span class="line">    lxfNetTool.request(.data(type: input.category, size: <span class="number">10</span>, index: <span class="keyword">self</span>.index)).mapArray(<span class="type">LXFModel</span>.<span class="keyword">self</span>).subscribe(&#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .next(modelArr):</span><br><span class="line">            <span class="keyword">self</span>?.models.value = isReloadData ? modelArr : (<span class="keyword">self</span>?.models.value ?? []) + modelArr</span><br><span class="line">            <span class="type">LXFProgressHUD</span>.showSuccess(<span class="string">"加载成功"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .error(error):</span><br><span class="line">            <span class="type">LXFProgressHUD</span>.showError(error.localizedDescription)</span><br><span class="line">        <span class="keyword">case</span> .completed:</span><br><span class="line">            output.refreshStatus.value = isReloadData ? .endHeaderRefresh : .endFooterRefresh</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).addDisposableTo(<span class="keyword">self</span>.rx_disposeBag)</span><br><span class="line">&#125;).addDisposableTo(rx_disposeBag)</span><br></pre></td></tr></table></figure><br>五、在ViewController中初始化刷新控件</p>
<p>为tableView设置刷新控件，并且在创建刷新控件的回调中使用output的requestCommond发射信号<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView.mj_header = <span class="type">MJRefreshNormalHeader</span>(refreshingBlock: &#123; </span><br><span class="line">    vmOutput.requestCommond.onNext(<span class="literal">true</span>)</span><br><span class="line">&#125;)</span><br><span class="line">tableView.mj_footer = <span class="type">MJRefreshAutoNormalFooter</span>(refreshingBlock: &#123; </span><br><span class="line">    vmOutput.requestCommond.onNext(<span class="literal">false</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>总结流程：</p>
<ol>
<li><p>ViewController已经拿到output，当下拉加载数据的时候，使用output的requestCommond发射信息，告诉viewModel我们要加载数据</p>
</li>
<li><p>viewModel请求数据，在处理完json转模型或模型数组后修改models，当models的值被修改的时候会发信号给sections，sections在ViewController已经绑定到tableView的items了，所以此时tableView的数据会被更新。接着我们根据请求结果，修改output的refreshStatus属性的值</p>
</li>
<li><p>当output的refreshStatus属性的值改变后，会发射信号，由于外界之前已经订阅了output的refreshStatus，此时就会根据refreshStatus的新值来处理刷新控件的状态</p>
</li>
</ol>
<p>好了，附上<a href="https://github.com/LinXunFeng/RxSwiftDemo" target="_blank" rel="noopener">RxSwiftDemo</a>。完结撒花</p>
<div class="github-widget" data-repo="LinXunFeng/RxSwiftDemo"></div>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-组件化开发（一）：远程私有库的基本使用</title>
    <url>/2018/04/06/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BF%9C%E7%A8%8B%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>随着项目功能的不断增加，越来越多的开发人员加入，业务主线也随之越来越多，造成耦合越来越严重，编译越来越慢，测试不独立等一系列问题。为了解决此类情况，我们可以考虑到使用组件化开发</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>随着项目功能的不断增加，越来越多的开发人员加入，业务主线也随之越来越多，造成耦合越来越严重，编译越来越慢，测试不独立等一系列问题。为了解决此类情况，我们可以考虑到使用组件化开发</p>
</blockquote>
<p>1.概念<br>组件化就是将一个单一工程的项目, 分解成为各个独立的组件， 然后按照某种方式, 任意组织成一个拥有完整业务逻辑的工程。</p>
<p>2.优势</p>
<ul>
<li>独立：独立编写、编译、运行、测试</li>
<li>重用：功能代码的重复使用。比如不同项目使用同一功能模块</li>
<li>高效：任意增删模块，实现高效迭代</li>
<li>组件化还可以配合二进制化, 提高项目编译速度</li>
</ul>
<p>3.组件分类<br>大体上分三类：基础组件、功能组件和业务组件<br></p>
<ul>
<li>基础组件：也称为公共组件，存放平时定义的宏、常量、协议、分类、对必要的第三方的封装类，以及各种处理工具类，如：时间、日期、设备信息、文件处理、沙盒管理等</li>
<li>功能组件： 自定义视图控件、一些特定功能的封装（如录音、播放音频封装）</li>
<li>业务组件：各种业务线</li>
</ul>
<hr>

<blockquote>
<p>本篇先来介绍下远程私有库的基本使用，建议按顺序看完之后，回来再看一遍步骤归纳，加深了解，如有不足之处，欢迎指出，感谢 : )</p>
</blockquote>
<h2 id="步骤归纳"><a href="#步骤归纳" class="headerlink" title="步骤归纳"></a>步骤归纳</h2><ol>
<li><p>创建远程索引库和私有库</p>
</li>
<li><p>将远程索引库添加到本地 <code>pod repo add 索引库名称 索引库地址</code></p>
</li>
<li><p>在本地创建一个pod模板库 <code>pod lib create 组件名称</code><br><br>将框架的核心代码添加到Classes目录下<br><br>本地安装测试核心代码是否可用 <code>pod install</code><br><br>修改Spec描述文件<br><br>将修改好的模板库上传至远程私有库</p>
</li>
<li><p>上传代码和打标签<br><br><code>git init</code><br><br><code>git add .</code><br><br><code>git commit -m &quot;提交描述&quot;</code><br><br><code>git remote add origin 远程私有库地址</code><br><br><code>git push origin master</code><br><br><code>git tag &#39;0.1.0&#39;</code><br><br><code>git push --tags</code></p>
</li>
<li><p>提交spec至私有索引库<br><br><code>pod lib lint --private</code><br><br><code>pod spec lint --private</code><br><br><code>pod repo push 索引库的本地名称 xx.podspec</code></p>
</li>
<li><p>使用<br><br><code>source 官方索引库url</code><br><br><code>source 私有索引库url</code><br><br><code>pod &#39;组件名称&#39;</code><br><br><code>pod install</code></p>
</li>
</ol>
<p><strong>接下来我们就来实战如何创建和使用私有库</strong></p>
<h2 id="一、创建私有索引库"><a href="#一、创建私有索引库" class="headerlink" title="一、创建私有索引库"></a>一、创建私有索引库</h2><p>这里以码云为例，创建一个LXFSpecs的私有索引库，这玩意的作用如其名，就是用来索引的</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/私有索引库.png" alt="私有索引库"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/LXFSpecs.png" alt="LXFSpecs"></p>
<h2 id="二、本地添加私有索引库"><a href="#二、本地添加私有索引库" class="headerlink" title="二、本地添加私有索引库"></a>二、本地添加私有索引库</h2><h3 id="1、查看本地索引库"><a href="#1、查看本地索引库" class="headerlink" title="1、查看本地索引库"></a>1、查看本地索引库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod repo</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/查看本地索引库.png" alt="查看本地索引库"></p>
<p>如图，目前本地仅有github上的那个公有索引库</p>
<h3 id="2、添加私有索引库"><a href="#2、添加私有索引库" class="headerlink" title="2、添加私有索引库"></a>2、添加私有索引库</h3><p>将我们刚刚新建的私有索引库LXFSpecs添加到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pod repo add 索引库名称 索引库地址</span><br><span class="line">pod repo add LXFSpecs https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFSpecs.git</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/添加私有索引库.png" alt=""></p>
<p>现在本地就有两个索引库，好，索引库的事情就先放一边去了～</p>
<h2 id="三、创建组件库"><a href="#三、创建组件库" class="headerlink" title="三、创建组件库"></a>三、创建组件库</h2><p>码云上的创建操作同上，这里以LXFBase为例，创建基础组件库<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/LXFBase.png" alt="LXFBase"></p>
<h3 id="1、快速创建模版库"><a href="#1、快速创建模版库" class="headerlink" title="1、快速创建模版库"></a>1、快速创建模版库</h3><p>到合适的位置创建一个与组件名相同的文件夹，cd进去后，使用如下命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pod lib create 组件名</span><br><span class="line">pod lib create LXFBase</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/快速创建模版库.png" alt=""></p>
<p>这里会让你配置一些信息，根据自己的情况自行配置即可。</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/快速创建模版库-配置.png" alt="配置"></p>
<h3 id="2、添加组件内容"><a href="#2、添加组件内容" class="headerlink" title="2、添加组件内容"></a>2、添加组件内容</h3><p>创建完成后会自动帮我们打开相应的Example项目，LXFBase目录中会出现如图这些文件，我们把基础组件相关的东西丢到Classes文件夹中，并且把<code>ReplaceMe.m</code>文件删除</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/目录结构.png" alt="目录结构"></p>
<p>默认Classes文件夹中存放的文件就是pod install时要下载下来的文件，当然可以通过修改spec文件的配置来更改位置</p>
<h3 id="3、安装与测试本地库"><a href="#3、安装与测试本地库" class="headerlink" title="3、安装与测试本地库"></a>3、安装与测试本地库</h3><p>在Example项目的Podfile文件中可以看到<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;LXFBase&#39;, :path &#x3D;&gt; &#39;..&#x2F;&#39;</span><br></pre></td></tr></table></figure><br>模板库已经默认帮我们在Podfile中指定了LXFBase.podspec的位置，使组件LXFBase可以正常安装使用和方便测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/安装与测试本地库-podinstall.png" alt="pod install"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/安装与测试本地库-pod.png" alt="pod"></p>
<p>可以看到我们已经将本地的组件添加进Example中了，现在可以尽情地做你想做的测试，确保组件的可用。</p>
<p>测试组件没有问题后，我们接下来就要将podspec文件上传至私有索引库，不过在此之前，需要对spec进行修改。</p>
<h3 id="4、-修改Spec"><a href="#4、-修改Spec" class="headerlink" title="4、 修改Spec"></a>4、 修改Spec</h3><p>具体的配置说明可以参考<a href="https://juejin.im/post/5ac446b8f265da238d50ecfa" target="_blank" rel="noopener">Cocoapods-创建第三方框架</a></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/修改Spec-podspec.png" alt="podspec"></p>
<p>主要的修改内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  s.name             &#x3D; &#39;LXFBase&#39;</span><br><span class="line">  s.version          &#x3D; &#39;0.1.0&#39;</span><br><span class="line">  s.summary          &#x3D; &#39;LXFBase.&#39;</span><br><span class="line">  s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">LXFBase是基础组件库，包括分类和常用工具</span><br><span class="line">                       DESC</span><br><span class="line">  s.homepage         &#x3D; &#39;https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFBase&#39;</span><br><span class="line">  s.source           &#x3D; &#123; :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFBase.git&#39;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line">  s.source_files &#x3D; &#39;LXFBase&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br></pre></td></tr></table></figure>
<h2 id="四、上传组件代码"><a href="#四、上传组件代码" class="headerlink" title="四、上传组件代码"></a>四、上传组件代码</h2><h3 id="1、将代码提交到组件仓库"><a href="#1、将代码提交到组件仓库" class="headerlink" title="1、将代码提交到组件仓库"></a>1、将代码提交到组件仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#39;firstCommit&#39;</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFBase.git</span><br><span class="line">&#x2F;&#x2F; 第一次push如果报错的话可以加上-f</span><br><span class="line">&#x2F;&#x2F; git push -f origin master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="2、打标签"><a href="#2、打标签" class="headerlink" title="2、打标签"></a>2、打标签</h3><p>标签<code>0.1.0</code>与spec中的<code>s.version</code>保持一致<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag &#39;0.1.0&#39;</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/上传组件代码-tag.png" alt="tag"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/上传组件代码-标签上传成功.png" alt="标签上传成功"></p>
<h2 id="五、提交podspec到私有索引库"><a href="#五、提交podspec到私有索引库" class="headerlink" title="五、提交podspec到私有索引库"></a>五、提交podspec到私有索引库</h2><p>在上传spec文件前我们可以做一个验证来节省时间，不然每次都推送很久结果还是验证失败，会气死人的～</p>
<h3 id="1、本地验证Spec的必填字段"><a href="#1、本地验证Spec的必填字段" class="headerlink" title="1、本地验证Spec的必填字段"></a>1、本地验证Spec的必填字段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 本地验证不会验证 s.source 中的tag</span><br><span class="line">pod lib lint</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/提交podspec到私有索引库-podLibLint.png" alt="pod lib lint"></p>
<h3 id="2、远程验证"><a href="#2、远程验证" class="headerlink" title="2、远程验证"></a>2、远程验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 远程验证会验证 s.source 中的tag，如果此时没有打上相应的标签则会报错</span><br><span class="line">pod spec lint</span><br></pre></td></tr></table></figure>
<p>如果你刚才没有打标签并上传至远程私有库就来进行远程验证，肯定是会报错的</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/提交podspec到私有索引库-tagError.png" alt="tag Error"></p>
<p>在打完并上传tag后再进行远程验证，就会验证成功了，验证成功后我们就可以进行下一步操作：提交podspec文件到索引库</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/提交podspec到私有索引库-podSpecLint.png" alt="pod spec lint"></p>
<ul>
<li>验证私有库提示<br>如果验证的是私有库，则在后面加上<code>--private</code>,否则会有警告，你可以选择<code>--allow-warnings</code>来忽略该警告<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod lib lint --private</span><br><span class="line">pod spec lint --private</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3、提交podspec"><a href="#3、提交podspec" class="headerlink" title="3、提交podspec"></a>3、提交podspec</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; pod repo push 私有索引库名称 spec名称.podspec </span><br><span class="line">pod repo push LXFSpecs LXFBase.podspec</span><br></pre></td></tr></table></figure>
<p>这里的操作过程：先将我们的代码直接push到本地索引库LXFSpecs，推送后会自动帮我们同步到远程索引库</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/提交podspec到私有索引库-提交成功.png" alt="提交成功"></p>
<p>再来看看码云上的私有索引库LXFSpecs</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/提交podspec到私有索引库-LXFBase.podspec.png" alt="LXFBase.podspec"></p>
<p>来测试下搜索我们的组件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod search &#39;LXFBase&#39;</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/提交podspec到私有索引库-搜索成功.png" alt="搜索成功"></p>
<h2 id="六、使用私有库"><a href="#六、使用私有库" class="headerlink" title="六、使用私有库"></a>六、使用私有库</h2><p>这时我们可以来试试通过pod形式来添加组件LXFBase，创建一个新的项目</p>
<h3 id="1、添加Podfile文件"><a href="#1、添加Podfile文件" class="headerlink" title="1、添加Podfile文件"></a>1、添加Podfile文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure>
<h3 id="2、在Podfile的最顶部添加如下描述"><a href="#2、在Podfile的最顶部添加如下描述" class="headerlink" title="2、在Podfile的最顶部添加如下描述"></a>2、在Podfile的最顶部添加如下描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二行是为了保证公有库的正常使用</span><br><span class="line">source &#39;https:&#x2F;&#x2F;gitee.com&#x2F;LinXunFeng&#x2F;LXFSpecs.git&#39;</span><br><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br></pre></td></tr></table></figure>
<h3 id="3、添加使用组件LXFBase"><a href="#3、添加使用组件LXFBase" class="headerlink" title="3、添加使用组件LXFBase"></a>3、添加使用组件LXFBase</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;LXFBase&#39;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/使用私有库-LXFBase.png" alt=""></p>
<h3 id="4、安装组件"><a href="#4、安装组件" class="headerlink" title="4、安装组件"></a>4、安装组件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/使用私有库-安装成功.png" alt="安装成功"><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（一）：远程私有库的基本使用/使用私有库-成功添加组件内容.png" alt="成功添加组件内容"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Cocoapods</tag>
        <tag>iOS</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-组件化开发（四）：fastlane实现pod自动化</title>
    <url>/2018/04/06/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9Afastlane%E5%AE%9E%E7%8E%B0pod%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>在第一次组件化的时候，需要执行很多操作，这些操作可以在【<a href="http://linxunfeng.top/2018/04/06/iOS-组件化开发（一）：远程私有库的基本使用/">iOS-组件化开发（一）：远程私有库的基本使用</a>】，这里就不再赘述，在组件化后的重复性操作就是升级，而升级这个过程是一模一样的。那么，我们有什么办法可以很方便的搞定这一过程来节约我们大量的时间呢？</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/fastlane.png" alt=""></p>
<blockquote>
<p>在第一次组件化的时候，需要执行很多操作，这些操作可以在【<a href="http://linxunfeng.top/2018/04/06/iOS-组件化开发（一）：远程私有库的基本使用/">iOS-组件化开发（一）：远程私有库的基本使用</a>】，这里就不再赘述，在组件化后的重复性操作就是升级，而升级这个过程是一模一样的。那么，我们有什么办法可以很方便的搞定这一过程来节约我们大量的时间呢？</p>
</blockquote>
<h2 id="一、升级必备操作"><a href="#一、升级必备操作" class="headerlink" title="一、升级必备操作"></a>一、升级必备操作</h2><p>修改完核心代码后，一共还需要做以下几步：<br><br>1、修改spec文件（修改s.version，s.description等）<br><br>2、<code>pod install</code> （使Example与pod下来的库产生关联）<br><br>3、提交本地仓库代码至远程仓库<br><br>4、打标签，并提交至远程<br><br>5、验证spec，并提至私有索引库</p>
<h2 id="二、Fastlane"><a href="#二、Fastlane" class="headerlink" title="二、Fastlane"></a>二、Fastlane</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p><a href="https://docs.fastlane.tools/" target="_blank" rel="noopener">Fastlane文档说明 </a><br>Fastlane是一个ruby脚本集合，它可以按照我们指定的路线，在指定位置执行我们所要执行的操作。这里我们称这样的路线为「航道(lane)」，这样的操作称为「Action」</p>
<p>Action是Fastlane自动化流程中的最小执行单元，用来执行Fastlane脚本中的命令，关于更多的描述可以到<a href="https://docs.fastlane.tools/actions/Actions/" target="_blank" rel="noopener">Actions - fastlane docs</a>查看，里面也介绍了常用的action有哪些，顺带附上<a href="https://github.com/fastlane/fastlane/tree/master/fastlane/lib/fastlane/actions" target="_blank" rel="noopener">action的源码地址</a>，这个源码在后面自定义起参考作用</p>
<h3 id="2、-安装"><a href="#2、-安装" class="headerlink" title="2、 安装"></a>2、 安装</h3><ul>
<li><p>确保ruby为最新版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew update</span><br><span class="line">brew install ruby</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装fastlane</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin fastlane</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前fastlane版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane --version</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有action</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane actions</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三、fastlane初始化"><a href="#三、fastlane初始化" class="headerlink" title="三、fastlane初始化"></a>三、fastlane初始化</h3><p>cd到你的本地组件仓库的根目录</p>
<ul>
<li><del>初始化fastlane</del><br><del><code>fastlane init</code></del><br><del>不过这个步骤对我们来说可以跳过，在init后提示你输入一些东西，包括上传需要用到的APPLE ID什么的一堆东西，由于我们并不涉及这些，所以我们使用更方便的方式</del></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建一个fastlane文件夹</span><br><span class="line"># 进入fastlane目录</span><br><span class="line"># 创建一个Fastfile文件</span><br><span class="line">mkdir fastlane</span><br><span class="line">cd fastlane</span><br><span class="line">touch Fastfile</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/目录结构.png" alt="目录结构"></p>
<h3 id="1、修改Fastfile"><a href="#1、修改Fastfile" class="headerlink" title="1、修改Fastfile"></a>1、修改Fastfile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc &#39;描述航道作用&#39;</span><br><span class="line">lane :航道名称 do |options|</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; options 可以用来传递参数</span><br><span class="line">&#x2F;&#x2F; 示例：varName &#x3D; options[:name]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 航道上需要执行的操作</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>航道上要扫描的操作可以到<a href="https://docs.fastlane.tools/actions" target="_blank" rel="noopener">Actions</a>上查找，可以通过关键字搜索，如下图<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/cocoapods.png" alt="cocoapods"><br>点进去可以看到具体的使用及参数说明</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/使用说明.png" alt="使用说明"></p>
<p>这里附上本人的Fastfile内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc &#39;LXFUpdatePodTool 航道用来自动化升级维护私有库&#39;</span><br><span class="line">lane : LXFUpdatePodTool do |options|</span><br><span class="line"></span><br><span class="line">tagNum &#x3D; options[:tag]</span><br><span class="line">podspecName &#x3D; options[:specName]</span><br><span class="line"></span><br><span class="line"># 航道上需要执行的操作</span><br><span class="line"># 具体action到 https:&#x2F;&#x2F;docs.fastlane.tools&#x2F;actions 上面查找</span><br><span class="line"># 这里的路径以仓库根目录为准</span><br><span class="line"></span><br><span class="line"># 1、修改spec文件（修改s.version，s.description等）</span><br><span class="line"># 2、pod install （使Example与pod下来的库产生关联）</span><br><span class="line">cocoapods(</span><br><span class="line">  clean: true,</span><br><span class="line">  podfile: &quot;.&#x2F;Example&#x2F;Podfile&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3、提交本地仓库代码至远程仓库</span><br><span class="line">git_add(path: &quot;.&quot;)</span><br><span class="line">git_commit(path: &quot;.&quot;, message: &quot;upgrade repo&quot;)</span><br><span class="line">push_to_git_remote</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4、打标签，并提交至远程</span><br><span class="line">add_git_tag(</span><br><span class="line">  tag: tagNum</span><br><span class="line">)</span><br><span class="line">push_git_tags</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 5、验证spec，并提至私有索引库</span><br><span class="line">pod_lib_lint(allow_warnings: true)</span><br><span class="line"># 因为本地索引库repo的名字是基本上不会去改变的，所以这里直接写死 LXFSpecs</span><br><span class="line"># podspec的名字需要由外界传入</span><br><span class="line">pod_push(path: &quot;#&#123;podspecName&#125;.podspec&quot;, repo: &quot;LXFSpecs&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h3 id="2、验证Fastfile"><a href="#2、验证Fastfile" class="headerlink" title="2、验证Fastfile"></a>2、验证Fastfile</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane lanes</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/Fastfile验证成功.png" alt="Fastfile验证成功"></p>
<h3 id="3、执行fastlane"><a href="#3、执行fastlane" class="headerlink" title="3、执行fastlane"></a>3、执行fastlane</h3><p><strong>需要在组件仓库的根目录下执行</strong><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/根目录.png" alt="根目录"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane LXFUpdatePodTool tag:0.1.1 specName:LXFMain</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/开始执行.png" alt="开始执行"></p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/上传完成.png" alt="上传完成"></p>
<p>整个执行过程不超过30秒～</p>
<h2 id="四、自定义Action"><a href="#四、自定义Action" class="headerlink" title="四、自定义Action"></a>四、自定义Action</h2><p>以上的过程已经可以完成一整个自动化更新了，但是有一点需要注意的是，这个输入的tag可能会面临一个问题，那就是本地和远程都可能已经存在，即发生冲突，这个时候我们可以选择自动删除本地和远程冲突的那个tag，再重新上传当前tag</p>
<h3 id="1、创建一个新的action"><a href="#1、创建一个新的action" class="headerlink" title="1、创建一个新的action"></a>1、创建一个新的action</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane new_action</span><br></pre></td></tr></table></figure>
<p>按要求输入Action名称<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/输入action名称.png" alt="输入action名称"></p>
<p>完成后fastlane目录下就会多出一个名为actions的文件夹，里面存放的就是你自定义action<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/actions文件夹.png" alt=""></p>
<h3 id="2、编辑自定义action"><a href="#2、编辑自定义action" class="headerlink" title="2、编辑自定义action"></a>2、编辑自定义action</h3><p>打开remove_git_tag.rb，开始自定义我们的action吧，什么？不会语法怎么办？可以参考别人的嘛，上面给出的<a href="https://github.com/fastlane/fastlane/tree/master/fastlane/lib/fastlane/actions" target="_blank" rel="noopener">action的源码地址</a>就有用武之地了，比如<a href="https://github.com/fastlane/fastlane/blob/master/fastlane/lib/fastlane/actions/pod_push.rb" target="_blank" rel="noopener">pod_push</a>。这里我直接贴出我已经完成的主要代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 可以使用 fastlane action remove_git_tag 来参看详细描述</span><br><span class="line"></span><br><span class="line">def self.run(params)</span><br><span class="line">  # 这里写要执行的操作 </span><br><span class="line">  # params[:参数名称] 参数名称与下面self.available_options中的保持一致</span><br><span class="line">  tagNum &#x3D; params[:tagNum]</span><br><span class="line">  rmLocalTag &#x3D; params[:rmLocalTag]</span><br><span class="line">  rmRemoteTag &#x3D; params[:rmRemoteTag]</span><br><span class="line"></span><br><span class="line">  command &#x3D; []</span><br><span class="line">  if rmLocalTag</span><br><span class="line">    # 删除本地标签</span><br><span class="line">    # git tag -d 标签名称</span><br><span class="line">    command &lt;&lt; &quot;git tag -d #&#123;tagNum&#125;&quot;</span><br><span class="line">  end</span><br><span class="line">  if rmRemoteTag</span><br><span class="line">    # 删除远程标签</span><br><span class="line">    # git push origin :标签名称</span><br><span class="line">    command &lt;&lt; &quot;git push origin :#&#123;tagNum&#125;&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  result &#x3D; Actions.sh(command.join(&#39;&amp;&#39;))</span><br><span class="line">  UI.success(&quot;Successfully remove tag 🚀 &quot;)</span><br><span class="line">  return result</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def self.description</span><br><span class="line">  # 对当前脚本的简单描述</span><br><span class="line">  &quot;删除tag&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def self.details</span><br><span class="line">  # 对当前脚本的具体描述</span><br><span class="line">  &quot;使用当前action来删除本地和远程冲突的tag&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def self.available_options</span><br><span class="line">  # 用来传递参数</span><br><span class="line">  [ </span><br><span class="line">    FastlaneCore::ConfigItem.new(key: :tagNum,</span><br><span class="line">                                  description: &quot;输入即将删除的tag&quot;,</span><br><span class="line">                                  is_string: true),</span><br><span class="line">    FastlaneCore::ConfigItem.new(key: :rmLocalTag,</span><br><span class="line">                                  description: &quot;是否删除本地tag&quot;,</span><br><span class="line">                                  optional:true,</span><br><span class="line">                                  is_string: false,</span><br><span class="line">                                  default_value: true),</span><br><span class="line">    FastlaneCore::ConfigItem.new(key: :rmRemoteTag,</span><br><span class="line">                                  description: &quot;是否删除远程tag&quot;,</span><br><span class="line">                                  optional:true,</span><br><span class="line">                                  is_string: false,</span><br><span class="line">                                  default_value: true)</span><br><span class="line">  ]</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def self.authors</span><br><span class="line">  # 作者姓名</span><br><span class="line">  [&quot;LinXunFeng&quot;]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="3、查看action描述"><a href="#3、查看action描述" class="headerlink" title="3、查看action描述"></a>3、查看action描述</h3><p>同样，这里先cd到组件库的根目录下执行，原因是这个自定义action只存在当前根目录下的fastlane中，其它fastlane的非自定义的action就不用在当前根目录下操作～<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane action remove_git_tag</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/查看具体描述.png" alt="查看具体描述"></p>
<h3 id="4、测试执行"><a href="#4、测试执行" class="headerlink" title="4、测试执行"></a>4、测试执行</h3><p>先来看看当前组件库已存在的tag<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/已存在的tag.png" alt="已存在的tag"></p>
<p>可以看到，我是已经有一个<code>0.1.1</code>版本的了。这时我们再来执行一次LXFUpdatePodTool航道<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fastlane LXFUpdatePodTool tag:0.1.1 specName:LXFMain</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2018/04/iOS-组件化开发（四）：fastlane实现pod自动化/自动清除.png" alt="自动清除"></p>
<h2 id="五、工具拿走"><a href="#五、工具拿走" class="headerlink" title="五、工具拿走"></a>五、工具拿走</h2><p><a href="https://github.com/LinXunFeng/LXFUpdatePodTool" target="_blank" rel="noopener">LXFUpdatePodTool</a> 已经传到我的GitHub上，需要的同学就拿走吧，顺手给个Star咯 Orz</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Cocoapods</tag>
        <tag>iOS</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS - 视频采集详解</title>
    <url>/2017/10/16/iOS-%E8%A7%86%E9%A2%91%E9%87%87%E9%9B%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p><a href="https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/04_MediaCapture.html#//apple_ref/doc/uid/TP40010188-CH5-SW2" target="_blank" rel="noopener">苹果官方文档-AVFoundation</a></p>
<p>为了管理从相机或者麦克风等这样的设备捕获到的信息，我们需要输入对象(input)和输出对象(output)，并且使用一个会话(AVCaptureSession)来管理 input 和 output 之前的数据流</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<p><a href="https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/04_MediaCapture.html#//apple_ref/doc/uid/TP40010188-CH5-SW2" target="_blank" rel="noopener">苹果官方文档-AVFoundation</a></p>
<p>为了管理从相机或者麦克风等这样的设备捕获到的信息，我们需要输入对象(input)和输出对象(output)，并且使用一个会话(AVCaptureSession)来管理 input 和 output 之前的数据流：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th style="text-align:left">简介</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVCaptureDevice</td>
<td style="text-align:left">输入设备，例如 摄像头 麦克风</td>
</tr>
<tr>
<td>AVCaptureInput</td>
<td style="text-align:left">输入端口 [使用其子类]</td>
</tr>
<tr>
<td>AVCaptureOutput</td>
<td style="text-align:left">设备输出 [使用其子类]，输出视频文件或者静态图像</td>
</tr>
<tr>
<td>AVCaptureSession</td>
<td style="text-align:left">管理输入到输出的数据流</td>
</tr>
<tr>
<td>AVCaptureVideoPreviewLayer</td>
<td style="text-align:left">展示采集 预览View</td>
</tr>
</tbody>
</table>
<p>如图，通过单个 session，也可以管理多个 input 和 output 对象之间的数据流，从而得到视频、静态图像和预览视图<br><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/10/iOS-视频采集详解/1.png" alt="多个输入输出设备"></p>
<p>如图，input 可以有一个或多个输入端口，output 也可以有一个或多个数据来源（如：一个 <a href="https://developer.apple.com/documentation/avfoundation/avcapturemoviefileoutput" target="_blank" rel="noopener">AVCaptureMovieFileOutput</a> 对象可以接收视频数据和音频数据）</p>
<p>当添加 input 和 output 到 session 中时，session 会自动建立起一个连接(AVCaptureConnection)。我们可以使用这个 connection 来设置从 input 或者 从 output 得到的数据的有效性，也可以用来监控在音频信道中功率的平均值和峰值。</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/10/iOS-视频采集详解/2.png" alt="AVCaptureConnection"></p>
<h2 id="使用-Session-来管理数据流"><a href="#使用-Session-来管理数据流" class="headerlink" title="使用 Session 来管理数据流"></a>使用 Session 来管理数据流</h2><p>创建一个 session 用来管理捕获到的数据，需要先将 inputs 和 outputs 添加到 session 中，当 session 执行 [startRunning] 方法后就会开始将数据流发送至 session，通过执行[stopRunning] 方法来结束数据流的发送。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 inputs 和 outputs</span></span><br><span class="line"></span><br><span class="line">[session startRunning];</span><br></pre></td></tr></table></figure><br>在 [session startRunning] 之前我们需要进行一些基本的配置 (如：设备分辨率，添加输入输出对象等)</p>
<h3 id="设置分辨率"><a href="#设置分辨率" class="headerlink" title="设置分辨率"></a>设置分辨率</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置分辨率 720P 标清</span></span><br><span class="line"><span class="keyword">if</span> ([captureSession canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset1280x720</span>]) &#123;</span><br><span class="line">    captureSession.sessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附苹果官方文档中可供配置的分辨率列表</p>
<p><img src= "/img/loading.gif" data-src="https://linxunfeng.github.io/images/2017/10/iOS-视频采集详解/3.png" alt="分辨率列表"></p>
<p>其中高分辨率(AVCaptureSessionPresetHigh) 为默认值，会根据当前设备进行自适应，但是这样之后导出来的文件就会很大，一般情况下设置为标清(AVCaptureSessionPreset1280x720) 就可以了</p>
<h3 id="输入对象"><a href="#输入对象" class="headerlink" title="输入对象"></a>输入对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 直接使用后置摄像头</span><br><span class="line">AVCaptureDevice *videoDevice &#x3D; [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 在这个方法中的 mediaType 有三个选项供我们使用</span><br><span class="line">&#x2F;&#x2F; AVMediaTypeVideo 视频</span><br><span class="line">&#x2F;&#x2F; AVMediaTypeAudio 音频</span><br><span class="line">&#x2F;&#x2F; AVMediaTypeMuxed 混合(视频 + 音频)</span><br><span class="line">+ (nullable AVCaptureDevice *)defaultDeviceWithMediaType:(AVMediaType)mediaType;</span><br></pre></td></tr></table></figure>
<p>但是这种方式只能获取到后置摄像头，如果想要获取前置摄像头，可使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AVCaptureDevice *videoDevice;</span><br><span class="line">NSArray *devices &#x3D; [AVCaptureDevice devices];</span><br><span class="line">for (AVCaptureDevice *device in devices) &#123;</span><br><span class="line">   if(device.position &#x3D;&#x3D; AVCaptureDevicePositionFront) &#123;</span><br><span class="line">        &#x2F;&#x2F; 前置摄像头</span><br><span class="line">        videoDevice &#x3D; device;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过设备获取输入对象</span><br><span class="line">AVCaptureDeviceInput *videoInput &#x3D; [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:nil];</span><br><span class="line">&#x2F;&#x2F; 给会话添加输入</span><br><span class="line">if([captureSession canAddInput:videoInput]) &#123;</span><br><span class="line">    [captureSession addInput:videoInput];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="输出对象"><a href="#输出对象" class="headerlink" title="输出对象"></a>输出对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 视频输出：设置视频原数据格式：YUV, RGB </span><br><span class="line">&#x2F;&#x2F; 苹果不支持YUV的渲染，只支持RGB渲染，这意味着： YUV &#x3D;&gt; RGB</span><br><span class="line">AVCaptureVideoDataOutput *videoOutput &#x3D; [[AVCaptureVideoDataOutput alloc] init];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; videoSettings: 设置视频原数据格式 YUV FULL</span><br><span class="line">videoOutput.videoSettings &#x3D; @&#123;(NSString *)kCVPixelBufferPixelFormatTypeKey:@(kCVPixelFormatType_420YpCbCr8BiPlanarFullRange)&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置代理：获取帧数据</span><br><span class="line">&#x2F;&#x2F; 队列：串行&#x2F;并行，这里使用串行，保证数据顺序 </span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;LinXunFengSerialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">[videoOutput setSampleBufferDelegate:self queue:queue];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 给会话添加输出对象</span><br><span class="line">if([captureSession canAddOutput:videoOutput]) &#123;</span><br><span class="line">    &#x2F;&#x2F; 给会话添加输入输出就会自动建立起连接</span><br><span class="line">    [captureSession addOutput:videoOutput];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，输出对象可以设置帧率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 帧率：1秒10帧就差不多比较流畅了</span><br><span class="line">videoOutput.minFrameDuration &#x3D; CMTimeMake(1, 10);</span><br></pre></td></tr></table></figure>
<p>输出对象在设置视频原数据格式时使用 videoSettings 属性，需要赋值的类型是字典<br>格式有两种，一种是YUV，另一种是RGB（一般我们都使用YUV，因为体积比RGB小）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; key</span><br><span class="line">kCVPixelBufferPixelFormatTypeKey 指定解码后的图像格式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; value</span><br><span class="line">kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange  : YUV420 用于标清视频[420v]</span><br><span class="line">kCVPixelFormatType_420YpCbCr8BiPlanarFullRange   : YUV422 用于高清视频[420f] </span><br><span class="line">kCVPixelFormatType_32BGRA : 输出的是BGRA的格式，适用于OpenGL和CoreImage</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">1、前两种是相机输出YUV格式，然后转成RGBA，最后一种是直接输出BGRA，然后转成RGBA;</span><br><span class="line">2、420v 输出的视频格式为NV12；范围： (luma&#x3D;[16,235] chroma&#x3D;[16,240])</span><br><span class="line">3、420f 输出的视频格式为NV12；范围： (luma&#x3D;[0,255] chroma&#x3D;[1,255])</span><br></pre></td></tr></table></figure>
<h3 id="预览图层"><a href="#预览图层" class="headerlink" title="预览图层"></a>预览图层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AVCaptureVideoPreviewLayer *previewLayer &#x3D; [AVCaptureVideoPreviewLayer layerWithSession:captureSession];</span><br><span class="line">previewLayer.frame &#x3D; self.view.bounds;</span><br><span class="line">[self.view.layer  addSublayer:previewLayer];</span><br></pre></td></tr></table></figure>
<p>实时显示摄像头捕获到的图像，但不适用于滤镜渲染</p>
<h3 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark - AVCaptureVideoDataOutputSampleBufferDelegate</span><br><span class="line">&#x2F;*</span><br><span class="line"> CMSampleBufferRef: 帧缓存数据，描述当前帧信息</span><br><span class="line"> CMSampleBufferGetXXX : 获取帧缓存信息</span><br><span class="line"> CMSampleBufferGetDuration : 获取当前帧播放时间</span><br><span class="line"> CMSampleBufferGetImageBuffer : 获取当前帧图片信息</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 获取帧数据</span><br><span class="line">- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection &#123;</span><br><span class="line">    &#x2F;&#x2F; captureSession 会话如果没有强引用，这里不会得到执行</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;----- sampleBuffer ----- %@&quot;, sampleBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取帧播放时间</span></span><br><span class="line"><span class="built_in">CMTime</span> duration = <span class="built_in">CMSampleBufferGetDuration</span>(sampleBuffer);</span><br></pre></td></tr></table></figure>
<p>在代理方法中，可以把 sampleBuffer 数据渲染出来去显示画面。适用于滤镜渲染<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取图片帧数据</span><br><span class="line">CVImageBufferRef imageBuffer &#x3D; CMSampleBufferGetImageBuffer(sampleBuffer);</span><br><span class="line">CIImage *ciImage &#x3D; [CIImage imageWithCVImageBuffer:imageBuffer];</span><br><span class="line">UIImage *image &#x3D; [UIImage imageWithCIImage:ciImage];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    self.imageView.image &#x3D; image;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>需要注意的是：代理方法中的所有动作所在队列都是在异步串行队列中，所以更新UI的操作需要回到主队列中进行！！</p>
<p>但是此时会发现，画面是向左旋转了90度，因为默认采集的视频是横屏的，需要我们进一步做调整。以下步骤添加在[session startRunning];之前即可，但是一定要在添加了 input 和 output之后～<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取输入与输出之间的连接</span><br><span class="line">AVCaptureConnection *connection &#x3D; [videoOutput connectionWithMediaType:AVMediaTypeVideo];</span><br><span class="line">&#x2F;&#x2F; 设置采集数据的方向</span><br><span class="line">connection.videoOrientation &#x3D; AVCaptureVideoOrientationPortrait;</span><br><span class="line">&#x2F;&#x2F; 设置镜像效果镜像</span><br><span class="line">connection.videoMirrored &#x3D; YES;</span><br></pre></td></tr></table></figure></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/LinXunFeng/LXFAudioVideo" target="_blank" rel="noopener">LXFAudioVideo</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-面向协议方式封装空白页功能</title>
    <url>/2018/04/07/iOS-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E6%96%B9%E5%BC%8F%E5%B0%81%E8%A3%85%E7%A9%BA%E7%99%BD%E9%A1%B5%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>为了良好的交互体验，相信大家在对待<code>scrollView</code>无数据时的提示页都会使用一些第三方来定制，最典型的就是使用<a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" rel="noopener">DZNEmptyDataSet</a>。但是每个界面都写一堆与<code>DZNEmptyDataSetDelegate</code>，<code>DZNEmptyDataSetSource</code>相关的代码就不太好，那一般情况下自然的就会采用继承的方式来避免。而Swift除了可以面向对象编程，它还可以面向协议编程。那可不可以也用协议来解决情况呢？嘿嘿，这个可以有，那我们接下来就来试试怎么通过协议的方式来避免上述情况，并且实现一行代码添加空白页功能</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>为了良好的交互体验，相信大家在对待<code>scrollView</code>无数据时的提示页都会使用一些第三方来定制，最典型的就是使用<a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" rel="noopener">DZNEmptyDataSet</a>。但是每个界面都写一堆与<code>DZNEmptyDataSetDelegate</code>，<code>DZNEmptyDataSetSource</code>相关的代码就不太好，那一般情况下自然的就会采用继承的方式来避免。而Swift除了可以面向对象编程，它还可以面向协议编程。那可不可以也用协议来解决情况呢？嘿嘿，这个可以有，那我们接下来就来试试怎么通过协议的方式来避免上述情况，并且实现一行代码添加空白页功能</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果对面向协议有疑问的同学可以看下我之前的两篇文章</p>
<p><a href="/2017/09/12/iOS-Swift-面向协议编程（一）/">iOS - Swift 面向协议编程（一）</a> </p>
<p><a href="/2017/09/12/iOS-Swift-面向协议编程（二）/">iOS - Swift 面向协议编程（二）</a></p>
<p>之前的文章中提到了，协议除了起规范作用，还有别一个用处，就是赋予能力。我们现在的目的就是让目标控制器或者目标视图在遵守我们的协议后，就可以有实现空白页的功能。</p>
<h2 id="一、基本实现"><a href="#一、基本实现" class="headerlink" title="一、基本实现"></a>一、基本实现</h2><h3 id="1、创建协议"><a href="#1、创建协议" class="headerlink" title="1、创建协议"></a>1、创建协议</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK:- 空视图占位协议</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">LXFEmptyDataSetable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、确定面向类"><a href="#2、确定面向类" class="headerlink" title="2、确定面向类"></a>2、确定面向类</h3><p>确定我们面向的类，一般<code>tableView</code>或者<code>collectionView</code>都是写在控制器里，那我们面向的类就规定为<code>UIViewController</code>，或许也有人写在<code>UIView</code>里，不过这里先按<code>UIViewController</code>来写吧<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK:- UIViewController - 空视图占位协议</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">LXFEmptyDataSetable</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3、的实现的方法写在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、定义功能方法"><a href="#3、定义功能方法" class="headerlink" title="3、定义功能方法"></a>3、定义功能方法</h3><p>将<code>scrollView</code>传递进来，让我们定义的方法来暗地里做些操作<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lxf_EmptyDataSet</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">    scrollView.emptyDataSetDelegate = <span class="keyword">self</span></span><br><span class="line">    scrollView.emptyDataSetSource = <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4、设置数据源和代理"><a href="#4、设置数据源和代理" class="headerlink" title="4、设置数据源和代理"></a>4、设置数据源和代理</h3><p>在<code>3、定义功能方法</code>中将<code>delegate</code>和<code>source</code>设置为了<code>self</code> ，而协议是无法遵守再次遵守其它协议的，那让什么来遵守对应的协议呢？要明白这里的<code>self</code>指的是<code>UIViewController</code>,考虑到<code>UIView</code>的可能，这里我就让万物对象之父<code>NSObject</code>来遵守，并实现对应的数据源方法和代理方法<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span> : <span class="title">DZNEmptyDataSetDelegate</span>, <span class="title">DZNEmptyDataSetSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span><span class="params">(forEmptyDataSet scrollView: UIScrollView!)</span></span> -&gt; <span class="type">UIImage!</span> &#123;</span><br><span class="line">        <span class="comment">// 返回提示图片</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">title</span><span class="params">(forEmptyDataSet scrollView: UIScrollView!)</span></span> -&gt; <span class="type">NSAttributedString!</span> &#123;</span><br><span class="line">        <span class="comment">// 设置富文本标题</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">verticalOffset</span><span class="params">(forEmptyDataSet scrollView: UIScrollView!)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="comment">// 设置纵向偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二、定制空白页"><a href="#二、定制空白页" class="headerlink" title="二、定制空白页"></a>二、定制空白页</h2><p>通过上述步骤后，只要让<code>UIViewController</code>遵守我们的协议，再调用一下<code>lxf_EmptyDataSet</code>方法就可以实现数据空白页了。但是，这样直接写死的方式很不好，有时候一些场景是需要我们做出定制的，那怎么实现定制呢？协议又不能有自己的变量来存放我们的定制。</p>
<font color='red'><em>这里先做出一个限定，我们要使用重载方法来完成该功能，实现即可高定制，又可使用默认定制。</em></font>

<p>回到刚刚的话题，使用UserDefaults来实现可以吗？可以，但是比较麻烦，因为UserDefaults是单例，整个进程共用这一份资源，如果你当前<code>controller</code>遵守了我们的协议<code>LXFEmptyDataSetable</code>并做出了定制，那么当下一个<code>controller</code>在遵守协议后使用了<code>默认定制</code>时，那你要怎么办？还要区分<code>scrollView</code>，那就得保存当前<code>scrollView</code>，在退出当前<code>controller</code>后还要把对应的东西置空。好咯好咯，那你说到底要怎么搞才最合适？</p>
<blockquote>
<p>解决方案：拓展<code>UIScrollView</code>！！！有没有发现？，非常地恰巧，我们定义的方法<code>lxf_EmptyDataSet</code>需要外界将<code>UIScrollView</code>传递进来，在<code>DZNEmptyDataSet</code>的数据源方法和代理方法也有<code>scrollView</code>。那让<code>UIScrollView</code>来携带我们的定制就好啦。</p>
</blockquote>
<h3 id="1、定义定制相关的枚举"><a href="#1、定义定制相关的枚举" class="headerlink" title="1、定义定制相关的枚举"></a>1、定义定制相关的枚举</h3><p>这里我定义了常用的定制相关的枚举<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LXFEmptyDataSetAttributeKeyType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 纵向偏移(-50)  CGFloat</span></span><br><span class="line">    <span class="keyword">case</span> verticalOffset</span><br><span class="line">    <span class="comment">/// 提示语(暂无数据)  String</span></span><br><span class="line">    <span class="keyword">case</span> tipStr</span><br><span class="line">    <span class="comment">/// 提示语的font(system15)  UIFont</span></span><br><span class="line">    <span class="keyword">case</span> tipFont</span><br><span class="line">    <span class="comment">/// 提示语颜色(D2D2D2)  UIColor</span></span><br><span class="line">    <span class="keyword">case</span> tipColor</span><br><span class="line">    <span class="comment">/// 提示图(LXFEmptyDataPic) UIImage</span></span><br><span class="line">    <span class="keyword">case</span> tipImage</span><br><span class="line">    <span class="comment">/// 允许滚动(true) Bool</span></span><br><span class="line">    <span class="keyword">case</span> allowScroll</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2、拓展UIScrollView"><a href="#2、拓展UIScrollView" class="headerlink" title="2、拓展UIScrollView"></a>2、拓展UIScrollView</h3><p>为<code>UIScrollView</code>定义一个定制相关的属性字典<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIScrollView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">AssociatedKeys</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> lxf_emptyAttributeDict:[<span class="type">LXFEmptyDataSetAttributeKeyType</span> : <span class="type">Any</span>]?</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 属性字典</span></span><br><span class="line">    <span class="keyword">var</span> lxf_emptyAttributeDict: [<span class="type">LXFEmptyDataSetAttributeKeyType</span> : <span class="type">Any</span>]? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.lxf_emptyAttributeDict) <span class="keyword">as</span>? [<span class="type">LXFEmptyDataSetAttributeKeyType</span> : <span class="type">Any</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.lxf_emptyAttributeDict, newValue <span class="keyword">as</span> [<span class="type">LXFEmptyDataSetAttributeKeyType</span> : <span class="type">Any</span>]?, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、完善lxf-EmptyDataSet方法"><a href="#3、完善lxf-EmptyDataSet方法" class="headerlink" title="3、完善lxf_EmptyDataSet方法"></a>3、完善lxf_EmptyDataSet方法</h3><p>这里我们让外界通过闭包的方式来定制自己的空白页<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK:- UIViewController - 空视图占位协议</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">LXFEmptyDataSetable</span> <span class="title">where</span> <span class="title">Self</span> : <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">lxf_EmptyDataSet</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, attributeBlock: <span class="params">(<span class="params">()</span></span></span></span>-&gt;([<span class="type">LXFEmptyDataSetAttributeKeyType</span> : <span class="type">Any</span>]))? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        scrollView.lxf_emptyAttributeDict = attributeBlock != <span class="literal">nil</span> ? attributeBlock!() : <span class="literal">nil</span></span><br><span class="line">        scrollView.emptyDataSetDelegate = <span class="keyword">self</span></span><br><span class="line">        scrollView.emptyDataSetSource = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4、使用定制属性字典"><a href="#4、使用定制属性字典" class="headerlink" title="4、使用定制属性字典"></a>4、使用定制属性字典</h3><p>这里以返回提示图片的方法为例吧<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func image(forEmptyDataSet scrollView: UIScrollView!) -&gt; UIImage! &#123;</span><br><span class="line">    guard let tipImg &#x3D; scrollView.lxf_emptyAttributeDict?[.tipImage] as? UIImage else &#123;</span><br><span class="line">        return UIImage(named: &quot;LXFEmptyDataPic&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return tipImg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5、外界的使用姿势"><a href="#5、外界的使用姿势" class="headerlink" title="5、外界的使用姿势"></a>5、外界的使用姿势</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LXFEmptyDemoController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        initUI()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LXFEmptyDemoController</span>: <span class="title">LXFEmptyDataSetable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">initUI</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> tableView = <span class="type">UITableView</span>()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 高定制</span></span><br><span class="line">        <span class="keyword">self</span>.lxf_EmptyDataSet(tableView) &#123; () -&gt; ([<span class="type">LXFEmptyDataSetAttributeKeyType</span> : <span class="type">Any</span>]) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                .tipStr:<span class="string">"哟哟哟"</span>,</span><br><span class="line">                .verticalOffset:-<span class="number">150</span>,</span><br><span class="line">                .allowScroll: <span class="literal">false</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认定制</span></span><br><span class="line">        <span class="comment">// self.lxf_EmptyDataSet(tableView)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/2018/04/iOS-面向协议方式封装空白页功能/lxf_EmptyDataSet.png" alt="大功告成"></p>
<h2 id="三、开源库"><a href="#三、开源库" class="headerlink" title="三、开源库"></a>三、开源库</h2><p>我对这个过程进行一次整理，并做成一个名为 <a href="https://github.com/LinXunFeng/LXFProtocolTool" target="_blank" rel="noopener">LXFProtocolTool</a> 的库并上传至gitHub。可以使用<code>Cocoapods</code>的方式来安装使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;LXFProtocolTool&#39;</span><br></pre></td></tr></table></figure>
<p>我也将 <a href="http://linxunfeng.top/2017/09/12/iOS-Swift-面向协议编程（二）/">iOS - Swift 面向协议编程（二）</a> 中提及的通过协议便捷加载xib的功能也集成了进来。大家可以根据自己的需要在Podfile写明要安装的功能</p>
<ul>
<li>Xib加载</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;LXFProtocolTool&#x2F;LXFNibloadable&#39;</span><br></pre></td></tr></table></figure>
<ul>
<li>空白视图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;LXFProtocolTool&#x2F;LXFEmptyDataSetable&#39;</span><br></pre></td></tr></table></figure>
<p>创建这个库的目的是为了通过协议的方式来方便快捷地实现一些的实用功能，目前功能不多，不过往后会逐渐增加，或许你有什么想实现的功能也可以提出来，喜欢的就给个Star鼓励下我吧 🚀 🚀 🚀 </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>AppRTC实战</title>
    <url>/2018/06/07/AppRTC%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>记录AppRTC的搭建过程，实现iOS、Android、Browser同异设备的视频通信</p>
<a id="more"></a>
<The rest of contents | 余下全文>

<blockquote>
<p>1、记录AppRTC的搭建过程，实现iOS、安卓、browser同异设备的视频通信<br>2、以下直接以root身份进行操作，所有的需要下载的文件均放置于<code>/root</code>目录下，需要的话，可以自行决定存放位置，但是要注意修改相关的配置路径～</p>
</blockquote>
<h2 id="一、设备配置"><a href="#一、设备配置" class="headerlink" title="一、设备配置"></a>一、设备配置</h2><ul>
<li>阿里云ESC服务器 Ubuntu 16.04 64位</li>
<li>腾讯云域名</li>
</ul>
<h2 id="二、相关环境"><a href="#二、相关环境" class="headerlink" title="二、相关环境"></a>二、相关环境</h2><h3 id="1、JDK"><a href="#1、JDK" class="headerlink" title="1、JDK"></a>1、JDK</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add-apt-repository ppa:openjdk-r/ppa </span><br><span class="line">apt-get update </span><br><span class="line">apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
<h3 id="2、nodejs"><a href="#2、nodejs" class="headerlink" title="2、nodejs"></a>2、nodejs</h3><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs官网</a><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 这里的版本8.x可以按自己的需求去修改</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">apt-get install -y nodejs</span><br></pre></td></tr></table></figure><br>至此已经安装了最新版的nodejs和npm了,可以使用<code>-v</code>来查看当前版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>安装<code>grunt-cli</code>，后面需要<code>grunt</code>来构建房间服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm -g install grunt-cli</span><br></pre></td></tr></table></figure>
<h3 id="3、python与python-webtest"><a href="#3、python与python-webtest" class="headerlink" title="3、python与python-webtest"></a>3、python与python-webtest</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install python </span><br><span class="line">apt-get install python-webtest</span><br></pre></td></tr></table></figure>
<h3 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-cache search libevent</span><br><span class="line">apt-get install libevent-dev</span><br></pre></td></tr></table></figure>
<hr>

<h2 id="三、Room-Server-房间服务器"><a href="#三、Room-Server-房间服务器" class="headerlink" title="三、Room Server 房间服务器"></a>三、Room Server 房间服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone  https:&#x2F;&#x2F;github.com&#x2F;webrtc&#x2F;apprtc.git   </span><br><span class="line">cd apprtc</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h3 id="1、配置-constants-py"><a href="#1、配置-constants-py" class="headerlink" title="1、配置 constants.py"></a>1、配置 constants.py</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前目录 -- apprtc</span></span><br><span class="line">vim src/app_engine/constants.py</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这部分为 添加</span></span><br><span class="line">TURN_BASE_URL = <span class="string">'https://linxunfeng.top'</span> <span class="comment"># 修改为你自己当前服务器的域名，下面的亦是如此</span></span><br><span class="line">TURN_URL_TEMPLATE = <span class="string">'%s/turn.php?username=%s&amp;key=%s'</span> <span class="comment">#如果turn.php未实现，可使用默认配置</span></span><br><span class="line">CEOD_KEY = <span class="string">'lxf'</span> <span class="comment"># 这个很重要，后面配置turn时需要用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这部分为 修改</span></span><br><span class="line">ICE_SERVER_BASE_URL = <span class="string">'https://linxunfeng.top'</span></span><br><span class="line">ICE_SERVER_URL_TEMPLATE = <span class="string">'%s/iceconfig.php?key=%s'</span> <span class="comment">#如果iceconfig.php未实现，可用默认配置，但是Android Apk会有问题</span></span><br><span class="line">ICE_SERVER_API_KEY = os.environ.get(<span class="string">'ICE_SERVER_API_KEY'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary keys in the collider instance info constant.</span></span><br><span class="line">WSS_INSTANCE_HOST_KEY = <span class="string">'linxunfeng.top:8089'</span> <span class="comment">#信令服务器端口号8089  </span></span><br><span class="line">WSS_INSTANCE_NAME_KEY = <span class="string">'vm_name'</span></span><br><span class="line">WSS_INSTANCE_ZONE_KEY = <span class="string">'zone'</span></span><br><span class="line">WSS_INSTANCES = [&#123;</span><br><span class="line">    WSS_INSTANCE_HOST_KEY: <span class="string">'linxunfeng.top:8089'</span>,</span><br><span class="line">    WSS_INSTANCE_NAME_KEY: <span class="string">'wsserver-std'</span>,</span><br><span class="line">    WSS_INSTANCE_ZONE_KEY: <span class="string">'us-central1-a'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    WSS_INSTANCE_HOST_KEY: <span class="string">'linxunfeng.top:8089'</span>,</span><br><span class="line">    WSS_INSTANCE_NAME_KEY: <span class="string">'wsserver-std-2'</span>,</span><br><span class="line">    WSS_INSTANCE_ZONE_KEY: <span class="string">'us-central1-f'</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前目录 -- apprtc</span></span><br><span class="line">grunt build</span><br></pre></td></tr></table></figure>
<p>编译好后<code>apprtc</code>目录下就会多出一个名为<code>out</code>的目录，里面存放的就是编译好的<code>room server</code></p>
<h3 id="3、GoogleAppEngine的安装与配置"><a href="#3、GoogleAppEngine的安装与配置" class="headerlink" title="3、GoogleAppEngine的安装与配置"></a>3、GoogleAppEngine的安装与配置</h3><p>官网：<a href="https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Python" target="_blank" rel="noopener">GoogleAppEngine</a></p>
<p>可以在此路径找最新版本</p>
<blockquote>
<p>GoogleAppEngine -&gt; Python -&gt; Download and install the original App Engine SDK for Python.</p>
</blockquote>
<p>目前最新版本为：<a href="https://storage.googleapis.com/appengine-sdks/featured/google_appengine_1.9.70.zip" target="_blank" rel="noopener">google_appengine_1.9.70.zip</a></p>
<ul>
<li>下载 GoogleAppEngine</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://storage.googleapis.com/appengine-sdks/featured/google_appengine_1.9.70.zip</span><br></pre></td></tr></table></figure>
<ul>
<li>解压</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip google_appengine_1.9.70.zip</span><br></pre></td></tr></table></figure>
<ul>
<li>设置环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH="$PATH:/root/google_appengine/"</span><br></pre></td></tr></table></figure>
<ul>
<li>应用环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h3 id="4、开启-Room-Server"><a href="#4、开启-Room-Server" class="headerlink" title="4、开启 Room Server"></a>4、开启 Room Server</h3><ul>
<li>基本命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前路径 -- /root/google_appengine</span></span><br><span class="line">./dev_appserver.py --host=linxunfeng.top ../apprtc/out/app_engine/</span><br></pre></td></tr></table></figure>
<p><strong>如果你使用的是阿里云服务器，这里就不能用域名<code>linxunfeng.top</code>来启动<code>room server</code>，而是使用本地网卡地址</strong>，否则就会提示</p>
<blockquote>
<p>raise BindError(‘Unable to bind %s:%s’ % self.bind_addr)<br>google.appengine.tools.devappserver2.wsgi_server.BindError: Unable to bind linxunfeng.top:8080</p>
</blockquote>
<ul>
<li>查看网卡</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@xxx:~/google_appengine# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:16:3e:08:b4:02  </span><br><span class="line">          inet addr:172.18.141.108  Bcast:172.18.143.255  Mask:255.255.240.0</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./dev_appserver.py --host=172.18.141.108 ../apprtc/out/app_engine/</span><br></pre></td></tr></table></figure>
<p>这样就好了吗？不，虽然没有报错，但是你用浏览器打开你的域名看看…<br>这里直接给出最终命令，具体原因看 <a href="#1、Request-host-is-not-whitelist-enabled">疑难杂症 - 1</a></p>
<ul>
<li>最终命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./dev_appserver.py --enable_host_checking=false --host=172.18.141.108 ../apprtc/out/app_engine/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想直接后台运行，则使用如下命令</span></span><br><span class="line">nohup ./dev_appserver.py --enable_host_checking=false --host=172.18.141.108 ../apprtc/out/app_engine/ &amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问 room server</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;域名:8080</span><br></pre></td></tr></table></figure>
<h2 id="四、Collider-Server-信令服务器"><a href="#四、Collider-Server-信令服务器" class="headerlink" title="四、Collider Server 信令服务器"></a>四、Collider Server 信令服务器</h2><h3 id="1、拷贝collider源码"><a href="#1、拷贝collider源码" class="headerlink" title="1、拷贝collider源码"></a>1、拷贝collider源码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前路径 -- /root</span></span><br><span class="line">mkdir -p goWorkspace/src</span><br></pre></td></tr></table></figure>
<p>把<code>apprtc/src/collider/</code>目录下的三个目录（collider、collidermain、collidertest）复制到<code>goWorkspace/src/</code>目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -rf apprtc/src/collider/* /goWorkspace/src</span><br></pre></td></tr></table></figure>
<h3 id="2、修改代码"><a href="#2、修改代码" class="headerlink" title="2、修改代码"></a>2、修改代码</h3><ul>
<li>修改房间服务器的地址</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> goWorkspace/src/collidermain/main.go</span></span><br><span class="line">var roomSrv = flag.String("room-server", "https://域名", "The origin of the room server")</span><br></pre></td></tr></table></figure>
<ul>
<li>修改网站证书路径</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> goWorkspace/src/collider/collider.go</span></span><br><span class="line"></span><br><span class="line">e = server.ListenAndServeTLS("/etc/letsencrypt/live/域名/fullchain.pem", "/etc/letsencrypt/live/域名/privkey.pem")</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如：</span></span><br><span class="line">e = server.ListenAndServeTLS("/etc/letsencrypt/live/linxunfeng.top/fullchain.pem", "/etc/letsencrypt/live/linxunfeng.top/privkey.pem")</span><br></pre></td></tr></table></figure>
<p>相关的SSL证书<code>fullchain.pem</code>和<code>privkey.pem</code>在后面的nginx配置中会提到，这里先写上</p>
<h3 id="3、安装与配置环境"><a href="#3、安装与配置环境" class="headerlink" title="3、安装与配置环境"></a>3、安装与配置环境</h3><ul>
<li>下载GO语言环境</li>
</ul>
<p>FQ 到 <a href="https://golang.org/dl/" target="_blank" rel="noopener">GO官网</a>上下载最新版本</p>
<p>当前最新版本：<a href="https://dl.google.com/go/go1.10.2.linux-amd64.tar.gz" target="_blank" rel="noopener">go1.10.2.linux-amd64.tar.gz</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前路径 -- /root</span></span><br><span class="line">wget https://dl.google.com/go/go1.10.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>修改profile</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>打开<code>profile</code>后添加如下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GOROOT=/root/go</span><br><span class="line">export GOPATH=/root/goWorkspace</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>应用环境变量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>
<h3 id="4、编译"><a href="#4、编译" class="headerlink" title="4、编译"></a>4、编译</h3><p>进入目录 <code>goWorkspace/src/</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get collidermain</span><br><span class="line">go install collidermain</span><br></pre></td></tr></table></figure>
<p>这里的编译过程需要翻墙，如果无法翻墙，请看以下内容，如果可以则直接跳至第5小点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前路径 -- /root/goWorkspace/src</span></span><br><span class="line">mkdir -p golang.org/x </span><br><span class="line">cd golang.org/x/</span><br><span class="line">git clone https://github.com/golang/net</span><br></pre></td></tr></table></figure>
<p><code>git clone</code>成功后再执行上面的两行编译命令</p>
<h3 id="5、开启-Collider-Server"><a href="#5、开启-Collider-Server" class="headerlink" title="5、开启 Collider Server"></a>5、开启 Collider Server</h3><p>进入<code>goWorkspace</code>下的<code>bin</code>目录，执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前路径 -- /root/goWorkspace/bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -tls=<span class="literal">true</span> : 指需要数字证书</span></span><br><span class="line">./collidermain -port=8089 -tls=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想直接后台运行，则使用如下命令</span></span><br><span class="line">nohup ./collidermain -port=8089 -tls=true &amp;</span><br></pre></td></tr></table></figure>
<h2 id="五、STUN-TURN服务器"><a href="#五、STUN-TURN服务器" class="headerlink" title="五、STUN\TURN服务器"></a>五、STUN\TURN服务器</h2><h3 id="1、安装coturn"><a href="#1、安装coturn" class="headerlink" title="1、安装coturn"></a>1、安装<code>coturn</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install coturn</span><br></pre></td></tr></table></figure>
<h3 id="2、修改配置"><a href="#2、修改配置" class="headerlink" title="2、修改配置"></a>2、修改配置</h3><ul>
<li>coturn</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/default/coturn</span><br></pre></td></tr></table></figure>
<p>把TURNSERVER_ENABLED=1的注释去掉</p>
<ul>
<li>turnserver.conf</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/turnserver.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">listening-device=eth0 #此处eth0是电脑网卡名称</span><br><span class="line">listening-port=3478 #turn服务器的端口号</span><br><span class="line">relay-device=eth0 #此处eth0是电脑网卡名称</span><br><span class="line">min-port=49152</span><br><span class="line">max-port=65535</span><br><span class="line">Verbose</span><br><span class="line">fingerprint</span><br><span class="line">lt-cred-mech</span><br><span class="line">use-auth-secret</span><br><span class="line">static-auth-secret=lxf #此处要和房间服务器配置时constants.py文件中的CODE_KEY保持一致。</span><br><span class="line">user=lxf:0x8638170519dd1309044bca55319ff929</span><br><span class="line">user=lxf:lxf</span><br><span class="line">stale-nonce</span><br><span class="line">cert=/usr/local/etc/turn_server_cert.pem</span><br><span class="line">pkey=/usr/local/etc/turn_server_pkey.pem</span><br><span class="line">no-loopback-peers</span><br><span class="line">no-multicast-peers</span><br><span class="line">mobility</span><br><span class="line">no-cli</span><br></pre></td></tr></table></figure>
<p>上述文件中 0x8638170519dd1309044bca55319ff929： </p>
<p><code>turnadmin -k -u lxf -r north.gov -p lxf</code></p>
<blockquote>
<p>-k 表示生成一个long-term credential key<br>-u 表示用户名<br>-p 表示密码<br>-r 表示Realm域</p>
</blockquote>
<p>coturn的证书生成（即配置文件中cert和pkey)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:2048 -keyout /usr/local/etc/turn_server_pkey.pem -out /usr/local/etc/turn_server_cert.pem -days 99999 -nodes</span><br></pre></td></tr></table></figure>
<h3 id="3、启动coturn服务器"><a href="#3、启动coturn服务器" class="headerlink" title="3、启动coturn服务器"></a>3、启动coturn服务器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service coturn start</span><br></pre></td></tr></table></figure>
<p>用浏览器打开<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;域名:3478</span><br></pre></td></tr></table></figure></p>
<p>显示如下内容则说明成功开启服务</p>
<blockquote>
<p>TURN Server<br>use https connection for the admin session</p>
</blockquote>
<h2 id="六、配置nginx服务器"><a href="#六、配置nginx服务器" class="headerlink" title="六、配置nginx服务器"></a>六、配置nginx服务器</h2><h3 id="1、生成SSL证书"><a href="#1、生成SSL证书" class="headerlink" title="1、生成SSL证书"></a>1、生成SSL证书</h3><p>这里使用let’s encrypt颁发的免费SSL证书 <a href="https://certbot.eff.org" target="_blank" rel="noopener">certbot.eff.org</a></p>
<ul>
<li>安装软件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">apt-get install software-properties-common  </span><br><span class="line">add-apt-repository ppa:certbot/certbot  </span><br><span class="line">apt-get update </span><br><span class="line">apt-get install python-certbot-nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>生成证书</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certbot --nginx certonly</span><br></pre></td></tr></table></figure>
<p>SSL证书生成的目录为：<code>/etc/letsencrypt/live/域名/</code>，里面存放着四个文件<code>cert.pem,chain.pem,fullchain.pem,privkey.pem</code></p>
<h3 id="2、安装php和php-fpm"><a href="#2、安装php和php-fpm" class="headerlink" title="2、安装php和php-fpm"></a>2、安装php和php-fpm</h3><ul>
<li>安装php和php-fpm</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install php  </span><br><span class="line">apt-get install php7.0-fpm</span><br></pre></td></tr></table></figure>
<h3 id="3、安装与配置nginx"><a href="#3、安装与配置nginx" class="headerlink" title="3、安装与配置nginx"></a>3、安装与配置nginx</h3><ul>
<li>安装nginx</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>修改nginx配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>
<p>将下面的<code>linxunfeng.top</code>修改为你自己的域名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream roomserver &#123;</span><br><span class="line">       server linxunfeng.top:8080;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">       listen 80 ;</span><br><span class="line">       server_name linxunfeng.top; </span><br><span class="line">       return  301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        #listen 80 default_server;</span><br><span class="line">        #listen [::]:80 default_server;</span><br><span class="line"></span><br><span class="line">        # SSL configuration</span><br><span class="line">        #</span><br><span class="line">        # listen 443 ssl default_server;</span><br><span class="line">        # listen [::]:443 ssl default_server;</span><br><span class="line">        listen 443;</span><br><span class="line">        #</span><br><span class="line">        # Note: You should disable gzip for SSL traffic.</span><br><span class="line">        # See: https://bugs.debian.org/773332</span><br><span class="line">        #</span><br><span class="line">        # Read up on ssl_ciphers to ensure a secure configuration.</span><br><span class="line">        # See: https://bugs.debian.org/765782</span><br><span class="line">        #</span><br><span class="line">        # Self signed certs generated by the ssl-cert package</span><br><span class="line">        # Don't use them in a production server!</span><br><span class="line">        #</span><br><span class="line">        # include snippets/snakeoil.conf;</span><br><span class="line"></span><br><span class="line">        root /var/www/html;</span><br><span class="line"></span><br><span class="line">        # Add index.php to the list if you are using PHP</span><br><span class="line">        index index.html index.htm index.nginx-debian.html;</span><br><span class="line"></span><br><span class="line">        server_name linxunfeng.top; # 添加域名，如不添加，生成SSL证书时可能会有问题</span><br><span class="line"></span><br><span class="line">        #location / &#123;</span><br><span class="line">                # First attempt to serve request as file, then</span><br><span class="line">                # as directory, then fall back to displaying a 404.</span><br><span class="line">        #       try_files $uri $uri/ =404;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">                include snippets/fastcgi-php.conf;</span><br><span class="line">        #</span><br><span class="line">        #       # With php7.0-cgi alone:</span><br><span class="line">        #       fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">        #       # With php7.0-fpm:</span><br><span class="line">                fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123; </span><br><span class="line">                proxy_pass http://roomserver$request_uri;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate /etc/letsencrypt/live/linxunfeng.top/fullchain.pem;</span><br><span class="line">        ssl_certificate_key /etc/letsencrypt/live/linxunfeng.top/privkey.pem;</span><br><span class="line">        </span><br><span class="line">        # deny access to .htaccess files, if Apache's document root</span><br><span class="line">        # concurs with nginx's one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #       deny all;</span><br><span class="line">        #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="turn-php-与-iceconfig-php"><a href="#turn-php-与-iceconfig-php" class="headerlink" title="turn.php 与 iceconfig.php"></a>turn.php 与 iceconfig.php</h3><p>在<code>/var/www/html/</code>目录下创建两个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch turn.php iceconfig.php</span><br></pre></td></tr></table></figure>
<h4 id="turn-php"><a href="#turn-php" class="headerlink" title="turn.php"></a>turn.php</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    $request_username = $_GET[<span class="string">"username"</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($request_username)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"username == null"</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $request_key = $_GET[<span class="string">"key"</span>];</span><br><span class="line">    $time_to_live = <span class="number">600</span>;</span><br><span class="line">    $timestamp = time() + $time_to_live;<span class="comment">//失效时间</span></span><br><span class="line">    $response_username = $timestamp.<span class="string">":"</span>.$_GET[<span class="string">"username"</span>];</span><br><span class="line">    $response_key = $request_key;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($response_key)) &#123;</span><br><span class="line">        $response_key = <span class="string">"code_key"</span>;</span><br><span class="line">    &#125; <span class="comment">//constants.py中CEOD_KEY</span></span><br><span class="line">    $response_password = getSignature($response_username, $response_key);</span><br><span class="line">    $jsonObj = <span class="keyword">new</span> Response();</span><br><span class="line">    $jsonObj-&gt;username = $response_username;</span><br><span class="line">    $jsonObj-&gt;password = $response_password;</span><br><span class="line">    $jsonObj-&gt;ttl = <span class="number">86400</span>;</span><br><span class="line">    <span class="comment">//此处需配置自己的服务器</span></span><br><span class="line">    $jsonObj-&gt;uris= <span class="keyword">array</span>(<span class="string">"stun:linxunfeng.top:3478"</span>,<span class="string">"turn:linxunfeng.top:3478?transport=udp"</span>,<span class="string">"turn:linxunfeng.top?transport=tcp"</span>);</span><br><span class="line">    <span class="keyword">echo</span> json_encode($jsonObj);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HMAC-SHA1算法生成签名值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $str 源串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $key 密钥</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 签名值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSignature</span><span class="params">($str, $key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $signature = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (function_exists(<span class="string">'hash_hmac'</span>)) &#123;</span><br><span class="line">        $signature = base64_encode(hash_hmac(<span class="string">"sha1"</span>, $str, $key, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $blocksize = <span class="number">64</span>;</span><br><span class="line">        $hashfunc = <span class="string">'sha1'</span>;</span><br><span class="line">        <span class="keyword">if</span> (strlen($key) &gt; $blocksize) &#123;</span><br><span class="line">            $key = pack(<span class="string">'H*'</span>, $hashfunc($key));</span><br><span class="line">        &#125;</span><br><span class="line">        $key = str_pad($key, $blocksize, chr(<span class="number">0x00</span>));</span><br><span class="line">        $ipad = str_repeat(chr(<span class="number">0x36</span>), $blocksize);</span><br><span class="line">        $opad = str_repeat(chr(<span class="number">0x5c</span>), $blocksize);</span><br><span class="line">        $hmac = pack(</span><br><span class="line"><span class="string">'H*'</span>,</span><br><span class="line">    $hashfunc(</span><br><span class="line">($key ^ $opad) . pack(</span><br><span class="line"><span class="string">'H*'</span>,</span><br><span class="line">    $hashfunc(</span><br><span class="line">($key ^ $ipad) . $str</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line">        $signature = base64_encode($hmac);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $signature;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Response</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> $username = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">public</span> $password = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">public</span> $ttl = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">public</span> $uris = <span class="keyword">array</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>iceconfig.php</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    $request_username = <span class="string">"lxf"</span>;  <span class="comment">//配置成自己的turn服务器用户名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($request_username)) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"username == null"</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $request_key = <span class="string">"lxf"</span>;  <span class="comment">//配置成自己的turn服务器密码</span></span><br><span class="line">    $time_to_live = <span class="number">600</span>;</span><br><span class="line">    $timestamp = time() + $time_to_live;<span class="comment">//失效时间</span></span><br><span class="line">    $response_username = $timestamp.<span class="string">":"</span>.$_GET[<span class="string">"username"</span>];</span><br><span class="line">    $response_key = $request_key;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($response_key)) &#123;</span><br><span class="line">        $response_key = <span class="string">"CEOD_KEY"</span>;</span><br><span class="line">    &#125;<span class="comment">//constants.py中CEOD_KEY</span></span><br><span class="line">    $response_password = getSignature($response_username, $response_key);</span><br><span class="line">    $arrayObj = <span class="keyword">array</span>();</span><br><span class="line">    $arrayObj[<span class="number">0</span>][<span class="string">'username'</span>] = $response_username;</span><br><span class="line">    $arrayObj[<span class="number">0</span>][<span class="string">'credential'</span>] = $response_password;</span><br><span class="line">    <span class="comment">//配置成自己的stun/turn服务器</span></span><br><span class="line">    $arrayObj[<span class="number">0</span>][<span class="string">'urls'</span>][<span class="number">0</span>] = <span class="string">"stun:linxunfeng.top:3478"</span>;</span><br><span class="line">    $arrayObj[<span class="number">0</span>][<span class="string">'urls'</span>][<span class="number">1</span>] = <span class="string">"turn:linxunfeng.top:3478?transport=tcp"</span>;</span><br><span class="line">    $arrayObj[<span class="number">0</span>][<span class="string">'uris'</span>][<span class="number">0</span>] = <span class="string">"stun:linxunfeng.top:3478"</span>;</span><br><span class="line">    $arrayObj[<span class="number">0</span>][<span class="string">'uris'</span>][<span class="number">1</span>] = <span class="string">"turn:linxunfeng.top:3478?transport=tcp"</span>;</span><br><span class="line">    $jsonObj = <span class="keyword">new</span> Response();</span><br><span class="line">    $jsonObj-&gt;lifetimeDuration = <span class="string">"300.000s"</span>;</span><br><span class="line">    $jsonObj-&gt;iceServers = $arrayObj;</span><br><span class="line">    <span class="keyword">echo</span> json_encode($jsonObj);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HMAC-SHA1算法生成签名值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $str 源串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $key 密钥</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 签名值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSignature</span><span class="params">($str, $key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $signature = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (function_exists(<span class="string">'hash_hmac'</span>)) &#123;</span><br><span class="line">        $signature = base64_encode(hash_hmac(<span class="string">"sha1"</span>, $str, $key, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $blocksize = <span class="number">64</span>;</span><br><span class="line">        $hashfunc = <span class="string">'sha1'</span>;</span><br><span class="line">        <span class="keyword">if</span> (strlen($key) &gt; $blocksize) &#123;</span><br><span class="line">            $key = pack(<span class="string">'H*'</span>, $hashfunc($key));</span><br><span class="line">        &#125;</span><br><span class="line">        $key = str_pad($key, $blocksize, chr(<span class="number">0x00</span>));</span><br><span class="line">        $ipad = str_repeat(chr(<span class="number">0x36</span>), $blocksize);</span><br><span class="line">        $opad = str_repeat(chr(<span class="number">0x5c</span>), $blocksize);</span><br><span class="line">        $hmac = pack(</span><br><span class="line"><span class="string">'H*'</span>,</span><br><span class="line">    $hashfunc(</span><br><span class="line">($key ^ $opad) . pack(</span><br><span class="line"><span class="string">'H*'</span>,</span><br><span class="line">    $hashfunc(</span><br><span class="line">($key ^ $ipad) . $str</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line">        $signature = base64_encode($hmac);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $signature;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Response</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> $username = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">public</span> $password = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">public</span> $ttl = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">public</span> $uris = <span class="keyword">array</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>重启Nginx服务器和php7.0-fpm</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service nginx restart </span><br><span class="line">service php7.0-fpm restart</span><br></pre></td></tr></table></figure>
<h2 id="七、各端运行测试"><a href="#七、各端运行测试" class="headerlink" title="七、各端运行测试"></a>七、各端运行测试</h2><h3 id="1、Browser"><a href="#1、Browser" class="headerlink" title="1、Browser"></a>1、Browser</h3><p>浏览器直接打开即可，如果不能访问摄像头之类的，请查看<a href="#2、浏览器无法访问摄像头">疑难杂症 - 2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;域名</span><br></pre></td></tr></table></figure>
<h3 id="2、Android"><a href="#2、Android" class="headerlink" title="2、Android"></a>2、Android</h3><p><a href="https://github.com/duqian291902259/webrtc-android-demo-apprtc" target="_blank" rel="noopener">webrtc-android-demo-apprtc</a></p>
<p>直接安装手机，打开软件，点击右上角的扳手跳转至设置界面，滚到界面最下方，找到<code>Room server URL.</code>，将其修改为刚刚搭建好的服务器域名即可，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;linxunfeng.top</span><br></pre></td></tr></table></figure>
<h3 id="3、iOS"><a href="#3、iOS" class="headerlink" title="3、iOS"></a>3、iOS</h3><p><a href="https://github.com/ISBX/apprtc-ios" target="_blank" rel="noopener">GitHub - ISBX/apprtc-ios</a></p>
<p>打开<code>AppRTC</code>项目，分别修改以下两个文件</p>
<p><code>ARTCVideoChatViewController.m</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_HOST_URL @<span class="meta-string">"https://linxunfeng.top"</span></span></span><br></pre></td></tr></table></figure>
<p><code>Pods -&gt; Development Pods -&gt; AppRTC -&gt; Lib -&gt; ARDAppClient.m</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *kARDRoomServerHostUrl =</span><br><span class="line">    <span class="string">@"https://linxunfeng.top"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *kARDDefaultSTUNServerUrl =</span><br><span class="line">    <span class="string">@"stun:linxunfeng.top:3478"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *kARDTurnRequestUrl =</span><br><span class="line">    <span class="string">@"https://linxunfeng.top"</span></span><br><span class="line">    <span class="string">@"/turn?username=lxf&amp;key=lxf"</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索 kARDDefaultSTUNServerUrl </span></span><br><span class="line">- (RTCICEServer *)defaultSTUNServer &#123;</span><br><span class="line">  <span class="built_in">NSURL</span> *defaultSTUNServerURL = [<span class="built_in">NSURL</span> URLWithString:kARDDefaultSTUNServerUrl];</span><br><span class="line">  <span class="keyword">return</span> [[RTCICEServer alloc] initWithURI:defaultSTUNServerURL</span><br><span class="line">                                  username:<span class="string">@"lxf"</span></span><br><span class="line">                                  password:<span class="string">@"lxf"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><h3 id="1、Request-host-is-not-whitelist-enabled"><a href="#1、Request-host-is-not-whitelist-enabled" class="headerlink" title="1、Request host is not whitelist enabled"></a>1、Request host is not whitelist enabled</h3><blockquote>
<p>具体提示<br>Request host is not whitelist enabled for this server. Please use the –host command-line flag to whitelist a specific host (recommended) or use –enable_host_checking to disable host checking. See the command-line flags help text for more information. </p>
</blockquote>
<p><a href="https://stackoverflow.com/questions/47988810/use-ngrok-url-as-callback-url-for-facebook-webhook-but-is-recognized-not-white" target="_blank" rel="noopener">参考链接</a></p>
<p>执行dev_appserver.py时，加上如下参数<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--enable_host_checking=false</span><br></pre></td></tr></table></figure></p>
<p>完整指令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./dev_appserver.py --enable_host_checking=false --host=172.18.141.108 ../apprtc/out/app_engine/</span><br></pre></td></tr></table></figure></p>
<h3 id="2、浏览器无法访问摄像头"><a href="#2、浏览器无法访问摄像头" class="headerlink" title="2、浏览器无法访问摄像头"></a>2、浏览器无法访问摄像头</h3><p>浏览器访问设备的摄像头是需要使用<code>https</code>链接或者<code>localhost</code>来访问</p>
<h3 id="3、端口"><a href="#3、端口" class="headerlink" title="3、端口"></a>3、端口</h3><p>阿里云等国内大厂提供的服务器基本上都有一个叫安全组的玩意儿，我们搭建AppRTC服务器的所有服务所需的端口均要添加至安全组</p>
<h3 id="4、Failed-to-execute-‘pushState’-on-‘History’"><a href="#4、Failed-to-execute-‘pushState’-on-‘History’" class="headerlink" title="4、Failed to execute ‘pushState’ on ‘History’"></a>4、Failed to execute ‘pushState’ on ‘History’</h3><blockquote>
<p>Failed to start signaling: Failed to execute ‘pushState’ on ‘History’: A history state object with URL ‘<a href="http://linxunfeng.top/r/598600855’">http://linxunfeng.top/r/598600855’</a> cannot be created in a document with origin ‘<a href="https://linxunfeng.top’" target="_blank" rel="noopener">https://linxunfeng.top’</a> and URL ‘<a href="https://linxunfeng.top/">https://linxunfeng.top/</a></p>
</blockquote>
<p>解决方法有两种</p>
<ul>
<li>解决方法1： </li>
</ul>
<blockquote>
<p> 房间服务器编译完成后，在/root/apprtc/out/app_engine/js/apprtc.debug.js文件中找到window.history.pushState({‘roomId’: roomId, ‘roomLink’: roomLink}, roomId, roomLink)，把这句话注释掉，重新运行即可。（如果重新编译，需要重新修改）</p>
</blockquote>
<ul>
<li>解决方法2： </li>
</ul>
<blockquote>
<p> 在/root/apprtc/src/web_app/js/appcontroller.js文件中找到window.history.pushState({‘roomId’: roomId, ‘roomLink’: roomLink}, roomId, roomLink)，把这句话注释掉，然后重新编译，重新运行房间服务器即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker - Compose的使用</title>
    <url>/2021/04/05//pages/e3acb4//</url>
    <content><![CDATA[<h2 id="一、服务编排"><a href="#一、服务编排" class="headerlink" title="一、服务编排"></a>一、服务编排</h2><blockquote>
<p>服务编排：按照一定的业务规则批量管理容器</p>
</blockquote>
<p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启动和停止，那么维护的工作量就会很大。</p>
<p>比如这些工作：</p>
<ul>
<li>要从 <code>Dockerfile build image</code> 或者去 <code>dockerhub</code> 拉取 <code>image</code> </li>
<li>要创建多个 <code>container</code> </li>
<li>要管理这些 <code>container</code> (启动停止删除)</li>
</ul>
<p>这时候需要使用官方推出的服务编排</p>
<h2 id="二、Docker-Compose"><a href="#二、Docker-Compose" class="headerlink" title="二、Docker Compose"></a>二、Docker Compose</h2><blockquote>
<p><code>Docker Compose</code> 是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止</p>
</blockquote>
<p>使用步骤：</p>
<ol>
<li>利用 <code>Dockerfile</code> 定义运行环境镜像</li>
<li>使用 <code>docker-compose.yml</code> 定义组成应用的各服务（启动顺序、关联关系等）</li>
<li>运行 <code>docker-compose up</code> 启动应用</li>
</ol>
<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>如果使用的是 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop</a>，那就不需要再额外安装 <code>Compose</code> 了，因为它已经包含了 <code>Docker Compose</code> 。</p>
<p>下面是 <code>Linux</code> 系统下安装 <code>Compose</code> 的方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以编译好的二进制包方式安装到Linux系统中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -L https://github.com/docker/compose/releases/download/1.28.6/run.sh &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置文件可执行权限</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本信息（-v 或 --version 都可以）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose --version</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker-compose -v</span></span><br></pre></td></tr></table></figure>
<h3 id="2、卸载"><a href="#2、卸载" class="headerlink" title="2、卸载"></a>2、卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 二进制包方式安装的，删除二进制文件即可</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="3、实战"><a href="#3、实战" class="headerlink" title="3、实战"></a>3、实战</h3><p>先来编写配置文件，新建一个 <code>docker-compose.yml</code> 文件，文件名是固定的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch docker-compose.yml</span><br></pre></td></tr></table></figure>
<p>这里我用 <code>VSCode</code> 打开进行编辑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">code docker-compose.yml</span><br></pre></td></tr></table></figure>
<p>文件内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line">  <span class="attr">nginx:</span> <span class="comment"># 服务名字自行定义</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span> <span class="comment"># 指定通过nginx该镜像进行启动，这里可以指定镜像的版本号，如果不指定，默认为latest</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口映射，即 -p 参数，将宿主机的80端口映射到容器的80端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8090</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">links:</span> <span class="comment"># 指明当前服务可以访问到jenkins这个服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 目录映射，即 -v 参数，（宿主机目录:容器目录）</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/data/lxf/nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class="line">  <span class="attr">jenkins:</span> <span class="comment"># 服务名字自行定义</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">expose:</span>  <span class="comment"># 暴露指定的端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8080"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5000"</span></span><br></pre></td></tr></table></figure>
<p>创建 <code>~/data/lxf/nginx/conf.d</code> 目录，并进入该目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/data/lxf/nginx/conf.d</span><br><span class="line">cd ~/data/lxf/nginx/conf.d</span><br></pre></td></tr></table></figure>
<p>在该目录中创建一个 <code>conf</code> 文件，比如 <code>lxf.conf</code> ，文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  access_log off;</span><br><span class="line">  </span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;jenkins:8080;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置反向代理，当访问 <code>80</code> 端口时会反向代理到 <code>http://jenkins:8080</code>，这里的 <code>jenkins</code> 就是上述 <code>docker-compose.yml</code> 文件中 <code>links</code> 指定的 <code>jenkins</code> </p>
<p>在 <code>docker-compose.yml</code> 文件所在目录，使用 <code>docker-compose</code> 启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d: 后台启动</span></span><br><span class="line">docker-compse up [-d]</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210405143327.png" alt=""></p>
<p>测试访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:8090</span><br><span class="line">或</span><br><span class="line">本机ip:8090</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210405143344.png" alt=""></p>
<h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose 官方文档</a> </p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker - Dockerfile的使用</title>
    <url>/2021/01/31//pages/05278d//</url>
    <content><![CDATA[<blockquote>
<p>Dockerfile: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<p>应用: 将部署过程中涉及到的所有步骤全部写入到 <code>Dockerfile</code> 中，到时只需要执行 <code>Dockerfile</code> 就可以自动完成相应的操作</p>
</blockquote>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="编辑Dockerfile"><a href="#编辑Dockerfile" class="headerlink" title="编辑Dockerfile"></a>编辑Dockerfile</h3><p>在当前目录下创建 <code>Dockerfile</code> 并进行编辑<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure><br>操作：启动 <code>ubuntu</code> 镜像，在启动起来后去更新 <code>ubuntu</code> 容器下的软件资源<br>内容如下<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># From: 启动运行一个镜像资源</span></span><br><span class="line"><span class="keyword">From</span> ubuntu</span><br><span class="line"><span class="comment"># Run: 在启动起来的容器中执行指令</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update</span></span><br></pre></td></tr></table></figure></p>
<h3 id="运行Dockerfile"><a href="#运行Dockerfile" class="headerlink" title="运行Dockerfile"></a>运行Dockerfile</h3><p>构建镜像命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t [镜像名]:[版本号] [Dockerfile所在目录]</span><br></pre></td></tr></table></figure><br>指定在当前目录下去查找 <code>Dockerfile</code> 文件，并将 <code>Dockerfile</code> 自动化处理后的（更新了软件资源）容器打成名为 <code>lxf</code> 的镜像资源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t lxf .</span><br></pre></td></tr></table></figure>
<p>执行效果：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145009.png" alt=""><br>待执行完成后，当前拥有的镜像资源就多出了 <code>lxf</code> 这一个，可以看到 <code>lxf</code> 这个镜像的大小是要比 <code>ubuntu</code> 的镜像要大一点的<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145041.png" alt=""></p>
<h2 id="基础指令详解"><a href="#基础指令详解" class="headerlink" title="基础指令详解"></a>基础指令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><br>说明：</p>
<ul>
<li><code>FROM</code> 是 <code>Dockerfile</code> 里的第一条而且只能是除了首行注释之外的第一条指令</li>
</ul>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell模式</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> &lt;<span class="built_in">command</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exec模式</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]</span></span><br></pre></td></tr></table></figure><br>说明：</p>
<ul>
<li>表示当前镜像构建时候运行的命令</li>
</ul>
<p>注释：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shell 模式：类似于 /bin/bash -c command </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exec 模式：类似于 RUN ["/bin/bash", "-c", "command"] </span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"echo"</span>, <span class="string">"hello"</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>执行多条指令</p>
<ul>
<li><p>一条条指令写</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> world</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将指令用 <code>&amp;&amp;</code> 连接起来</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> hello &amp;&amp; <span class="built_in">echo</span> world</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure><br>说明：</p>
<ul>
<li>指定该 <code>Dockerfile</code> 文件的维护者信息</li>
</ul>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><blockquote>
<p>设置容器对外开放的端口</p>
</blockquote>
<p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure><br>解释：</p>
<ul>
<li>设置 <code>Docker</code> 容器对外暴露的端口号， <code>Docker</code> 为了安全，不会自动对外打开端口，如果需要外部提供访问，还需要启动容器时增加 <code>-p</code> 或者 <code>-P</code> 参数对容器的端口进行分配。</li>
</ul>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><blockquote>
<p>设置容器在启动后去执行一个命令</p>
</blockquote>
<p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exec 模式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>,<span class="string">"param2"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shell模式</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure><br>解释：</p>
<ul>
<li>每个 <code>Dockerfile</code> 中只能有一个 <code>ENTRYPOINT</code> ，当指定多个时，只有最后一个起效。</li>
</ul>
<p><code>EXPOSE</code> 和 <code>ENTRYPOINT</code> 结合使用的例子，可以全文看完后再回到这里看该例子<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用django镜像资源</span></span><br><span class="line"><span class="keyword">From</span> django</span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home</span></span><br><span class="line"><span class="comment"># 创建一个名为lxf的django项目</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> django-admin startproject lxf</span></span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home/lxf</span></span><br><span class="line"><span class="comment"># 对外开放8000端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"><span class="comment"># 容器启动后，将django服务开启，并指定端口号为8000</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> python3 manage.py runserver 0.0.0.0:8000</span></span><br></pre></td></tr></table></figure><br>执行构建镜像命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t lxf .</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145109.png" alt=""><br>现在我们将构建好的 <code>lxf</code> 容器运行起来，并随机分配端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit -P lxf</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145121.png" alt=""><br>可以看到， <code>Docker</code> 为我们随机分配了 <code>55001</code> 端口映射到容器的 <code>8000</code> 端口，并且可以正常访问到容器的 <code>django</code> 服务<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145133.png" alt=""></p>
<h2 id="文件指令详解"><a href="#文件指令详解" class="headerlink" title="文件指令详解"></a>文件指令详解</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]</span></span><br></pre></td></tr></table></figure><br>说明：</p>
<ul>
<li>将指定的 <code>&lt;src&gt;</code> 文件复制到容器文件系统中的 <code>&lt;dest&gt;</code> </li>
<li><code>src</code> 指的是宿主机，<code>dest</code>  指的是容器</li>
<li>如果源文件是个压缩文件，则 <code>Docker</code> 会自动帮解压到指定的容器中(无论目标是文件还是目录，都会当成目录处理)。</li>
</ul>
<p>如：将宿主机下的 <code>./data</code> 目录下的所有文件(夹)，全部复制到容器的 <code>/home</code> 目录下<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./data /home</span></span><br></pre></td></tr></table></figure><br>注：目录本身即 <code>data</code> 目录并不会复制到容器中，只复制 <code>data</code> 目录下的文件(夹)，如果想连同 <code>data</code> 文件夹也复制过去，可以修改为如下指令<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ./data /home/data</span></span><br></pre></td></tr></table></figure></p>
<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]</span></span><br></pre></td></tr></table></figure><br>解释：</p>
<ul>
<li>单纯复制文件场景， <code>Docker</code> 推荐使用 <code>COPY</code> </li>
<li>如果源文件是个压缩文件， <code>Docker</code> 会直接将压缩文件复制进容器内，不会像 <code>ADD</code> 那样先解压再复制</li>
</ul>
<p>注： <code>COPY</code> 与 <code>ADD</code> 基本上是一样的，只是面对源文件是压缩文件时处理方式不同而已， <code>ADD</code> 会先解压再将解压后的内容复制到容器， <code>COPY</code> 不会进行解压，而是直接将压缩包复制过去</p>
<h2 id="环境指令详解"><a href="#环境指令详解" class="headerlink" title="环境指令详解"></a>环境指令详解</h2><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><blockquote>
<p>设置环境变量</p>
</blockquote>
<p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure><br>解释：</p>
<ul>
<li>设置环境变量，可以在 <code>RUN</code> 之前使用，然后 <code>RUN</code> 命令时调用，容器启动时这些环境变量都会被指定</li>
</ul>
<p>如：设置了环境变量 <code>name</code> ，并赋值为 <code>lxf</code> ，使用 <code>RUN</code> 命令打印 <code>name</code> 变量的值，可以成功打印出来<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name=lxf</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$name</span> <span class="comment"># 会打印出lxf</span></span></span><br></pre></td></tr></table></figure><br>并且，当进入容器后也可以正常打印出该变量的值<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@5721971f92e4:/# echo $name</span><br><span class="line">lxf</span><br></pre></td></tr></table></figure></p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><blockquote>
<p>切换目录</p>
</blockquote>
<p>格式：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure><br>解释：</p>
<ul>
<li>切换目录，为后续的 <code>RUN</code> 、 <code>CMD</code> 、 <code>ENTRYPOINT</code> 指令配置工作目录。 </li>
<li>相当于 <code>cd</code> 命令，可以使用多个 <code>WORKDIR</code> 指令进行多次切换，后续命令如果参数是相对路径，则会基于之前命令指定的路径</li>
<li>如果我们指定切换到一个不存在的目录， <code>Docker</code> 会帮我们自动创建相应的目录</li>
</ul>
<p>举例：<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure><br>最终路径为 <code>/a/b/c</code> </p>
<p>如果我们想要容器被运行起来时，自动进入到 <code>/home</code> ，可以按如下指令设置<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home</span></span><br></pre></td></tr></table></figure><br>执行 <code>Dockerfile</code> 构建镜像完成后运行起来，此时容器便会自动进入到 <code>/home</code> 目录<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145219.png" alt=""><br>对比一下之前没有设置使用过 <code>WORKDIR</code> ，运行起来的容器，会默认进入到根目录<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145231.png" alt=""></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker - 安装、加速和基本使用</title>
    <url>/2021/01/24//pages/2ffb7f//</url>
    <content><![CDATA[<blockquote>
<p>Docker 容器是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何安装了docker引擎的服务器上</p>
</blockquote>
<p>本文主要以 <code>Mac</code> 平台为例</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="方式一-Homebrew"><a href="#方式一-Homebrew" class="headerlink" title="方式一: Homebrew"></a>方式一: Homebrew</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install docker</span><br></pre></td></tr></table></figure>
<h3 id="方式二-桌面程序"><a href="#方式二-桌面程序" class="headerlink" title="方式二: 桌面程序"></a>方式二: 桌面程序</h3><blockquote>
<p>我使用该方式</p>
</blockquote>
<p>访问 <a href="https://www.docker.com/get-started，在" target="_blank" rel="noopener">https://www.docker.com/get-started，在</a> <code>Docker Desktop</code> 下选择你当前系统对应的软件进行下载安装</p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124215528.png" alt=""></p>
<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><h4 id="Daocloud"><a href="#Daocloud" class="headerlink" title="Daocloud"></a>Daocloud</h4><blockquote>
<p>实测，速度不咋地</p>
</blockquote>
<p>打开 <a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">daocloud.io</a> 网站，注册并登录，点击加速器按钮，或者直接打开 <a href="https://www.daocloud.io/mirror，打开的页面上会显示与你账号相关的加速地址" target="_blank" rel="noopener">https://www.daocloud.io/mirror，打开的页面上会显示与你账号相关的加速地址</a></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124215606.png" alt=""></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><blockquote>
<p>实测，速度杠杠的，推荐使用</p>
</blockquote>
<table>
<thead>
<tr>
<th>镜像</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker中国区官方镜像</td>
<td><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a></td>
</tr>
<tr>
<td>网易</td>
<td><a href="http://hub-mirror.c.163.com" target="_blank" rel="noopener">http://hub-mirror.c.163.com</a></td>
</tr>
<tr>
<td>ustc</td>
<td><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn</a></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote>
<p>该部分内容取自 <code>daocloud</code></p>
</blockquote>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;xxx.m.daocloud.io</span><br></pre></td></tr></table></figure>
<p>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。</p>
<h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p>Docker For Mac</p>
<p>右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中加入下面的镜像地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.m.daocloud.io</span><br></pre></td></tr></table></figure>
<p>点击 Apply &amp; Restart 按钮使设置生效。</p>
<p>Docker Toolbox 等配置方法请参考<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox" target="_blank" rel="noopener">帮助文档</a>。</p>
<p>我自己的版本是 <code>3.1.0(51484)</code> ，与上述的不太一致。</p>
<p>如图所示，切换到 <code>Docker Engine</code> 下，在右侧所示的 <code>JSON</code> 内容中添加 <code>registry-mirrors</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;registry-mirrors&quot;: [&quot;你的加速器地址&quot;]</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124215627.png" alt=""></p>
<p>最后点击 <code>Apply&amp;Restart</code> 按钮即可。</p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>Docker For Windows</p>
<p>在桌面右下角状态栏中右键 docker 图标，修改在 Docker Daemon 标签页中的 json ，把下面的地址:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.m.daocloud.io</span><br></pre></td></tr></table></figure>
<p>加到” registry-mirrors”的数组里。点击 Apply 。</p>
<p>Docker Toolbox 等配置方法请参考<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox" target="_blank" rel="noopener">帮助文档</a>。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker version 20.10.2, build 2291f61</span><br></pre></td></tr></table></figure>
<h3 id="查看Docker信息"><a href="#查看Docker信息" class="headerlink" title="查看Docker信息"></a>查看Docker信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<p>可以使用该命名查看当前的镜像地址数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">Registry: https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;</span><br><span class="line">Labels:</span><br><span class="line">Experimental: true</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0&#x2F;8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https:&#x2F;&#x2F;registry.docker-cn.com&#x2F;</span><br><span class="line"> http:&#x2F;&#x2F;hub-mirror.c.163.com&#x2F;</span><br><span class="line"> https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&#x2F;</span><br><span class="line">Live Restore Enabled: false</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker - 操作容器</title>
    <url>/2021/01/31//pages/861244//</url>
    <content><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142731.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142751.png" alt=""></p>
<h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>这里我使用 <code>ubuntu</code> 镜像，创建一个名为 <code>lxfubuntu</code> 的容器，并运行进入容器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run -it --name [容器名] [镜像名] /bin/bash</span></span><br><span class="line"></span><br><span class="line">docker run -it --name lxfubuntu ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br>命令参数详解：</p>
<ul>
<li><code>--name</code> : 定义容器名称，如果不使用，则会随机产生一个名字</li>
<li><code>-i</code> : 让容器的标准输入保持打开</li>
<li><code>-t</code> : 让 <code>docker</code> 分配一个伪终端，并绑定到窗口的标准输入上</li>
<li><code>-d</code> : 以守护进程的方式运行容器，不占用终端</li>
<li><code>/bin/bash</code> : 执行一个命令</li>
</ul>
<p>如图，执行后即可进入容器中<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142815.png" alt=""></p>
<p>如果想创建并以守护进程的方式运行容器，可以使用 <code>-d</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit --name lxfubuntu1 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142828.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker start [container_id]</span></span><br><span class="line"></span><br><span class="line">docker start c97abc3f151a</span><br></pre></td></tr></table></figure>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>如果我们想进入上述提及的以守护进程方式运行的容器中，可以使用 <code>docker exec</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it lxfubuntu1 /bin/bash</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131142848.png" alt=""><br>如果在此时退出该守护进程的容器时，该容器依旧在后台运行</p>
<h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><p>两种方式</p>
<ul>
<li>方法一： 终端输入 <code>exit</code> 后回车</li>
<li>方法二： <code>Ctrl + D</code> </li>
</ul>
<p>如果容器是以守护进程的方式运行，在进入容器后退出，不停止容器的运行，即依旧在后台运行，否则将在容器退出时顺带停止容器</p>
<h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker stop [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker stop lxfubuntu1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker stop c97abc3f151a</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143004.png" alt=""></p>
<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker start [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker start lxfubuntu1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker start c97abc3f151a</span><br></pre></td></tr></table></figure>
<h2 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker restart [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker restart lxfubuntu1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker restart c97abc3f151a</span><br></pre></td></tr></table></figure>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><p>查看正在运行的容器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></p>
<p>查看所有的容器，包括已经停止的容器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">docker container ls --all</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker ps --all</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143019.png" alt=""></p>
<p>如果只是想查看容器的ID，可以使用参数 <code>-q</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143032.png" alt=""></p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker [container] rm [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker container rm lxfubuntu</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker rm lxfubuntu1</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143045.png" alt=""></p>
<p>如果删除一个正在运行的容器，需要加 <code>-f</code><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143103.png" alt=""></p>
<p>结合上述查看容器中 <code>-q</code> 的功能，可以实现批量删除容器的功能<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker ps -aq 获取所有的容器id</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure></p>
<h2 id="查看容器详情"><a href="#查看容器详情" class="headerlink" title="查看容器详情"></a>查看容器详情</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker inspect [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker inspect lxfubuntu1</span><br></pre></td></tr></table></figure>
<h2 id="查看容器状态"><a href="#查看容器状态" class="headerlink" title="查看容器状态"></a>查看容器状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker container stats [container_id|container_name]</span></span><br><span class="line"></span><br><span class="line">docker container stats lxfubuntu1</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143123.png" alt=""></p>
<h2 id="打包容器为新的镜像资源"><a href="#打包容器为新的镜像资源" class="headerlink" title="打包容器为新的镜像资源"></a>打包容器为新的镜像资源</h2><blockquote>
<p>容器在安装了各种各样的服务后，将该容器打包为镜像资源，接着将该镜像资源进行打包，最后再发给其它人使用</p>
</blockquote>
<p>将 <code>lxfubuntu1</code> 这个容器打包成名为 <code>my_image</code> 的镜像<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker commit 容器名 镜像资源名</span></span><br><span class="line">docker commit lxfubuntu1 my_image</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143137.png" alt=""></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker - 操作镜像资源</title>
    <url>/2021/01/24//pages/084bf9//</url>
    <content><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224049.jpeg" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224119.png" alt=""></p>
<h2 id="搜索镜像资源"><a href="#搜索镜像资源" class="headerlink" title="搜索镜像资源"></a>搜索镜像资源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224150.png" alt=""><br>一般选择 <code>STARS</code> 数最大的</p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>比如拉取上提及的 <code>nginx</code> 镜像<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image pull nginx</span><br></pre></td></tr></table></figure><br>命令执行后就开始对镜像进行拉取了<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224211.png" alt=""></p>
<h2 id="查看当前拥有的镜像"><a href="#查看当前拥有的镜像" class="headerlink" title="查看当前拥有的镜像"></a>查看当前拥有的镜像</h2><blockquote>
<p>镜像ID: 镜像的唯一标识，如果镜像ID相同，则说明是同一个镜像</p>
<p>TAG: 用来区分不同的发行版本，如果不指定具体标记，则默认使用latest来标记信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224239.png" alt=""></p>
<h2 id="查看镜像的详情信息"><a href="#查看镜像的详情信息" class="headerlink" title="查看镜像的详情信息"></a>查看镜像的详情信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker image inspect 镜像名</span></span><br><span class="line">docker image inspect ubuntu</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224256.png" alt=""></p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>完整写法<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image rm ubuntu</span><br></pre></td></tr></table></figure><br>简洁写法<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi ubuntu</span><br></pre></td></tr></table></figure><br>除了可以根据镜像名来删除外，也可以使用镜像ID，如使用上述的 <code>ubuntu</code> 镜像ID<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi f643c72bc252</span><br></pre></td></tr></table></figure><br>如果我们对同一个镜像打了多个 <code>tag</code> ，导致同一个镜像ID存在多个镜像名称，那此时可以使用 <code>name:tag</code> 的格式来删除镜像，如：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker rmi ubuntu_lxf:v1.0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker tag 当前镜像名:镜像版本 新的镜像名:新的版本</span></span><br><span class="line">docker tag ubuntu:latest ubuntu_lxf:latest</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker tag ubuntu:latest ubuntu_lxf:v1.0</span></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224315.png" alt=""><br>注：</p>
<ul>
<li><code>ubuntu</code> 和 <code>ubuntu_lxf</code> 的 <code>IMAGE_ID</code> 是相同的</li>
<li>结合删除镜像的命令就可以实现镜像重命名功能</li>
</ul>
<h2 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h2><blockquote>
<p>docker save 会保存镜像的所有历史记录和元数据信息</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker save -o 包文件 镜像</span></span><br><span class="line">docker save -o ubuntu.tar ubuntu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker save 镜像1 ... 镜像n &gt; 包文件</span></span><br><span class="line">docker save ubuntu nginx &gt; lxf_images.tar</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224337.png" alt=""></p>
<h2 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h2><p>先删除 <code>ubuntu</code> 镜像<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224351.png" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker load -i 镜像包名</span></span><br><span class="line">docker load -i ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker load &lt; 镜像包名</span></span><br><span class="line">docker load &lt; ubuntu.tar</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker load --input 镜像包名</span></span><br><span class="line">docker load --input ubuntu.tar</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224416.png" alt=""><br>可以看到， <code>ubuntu</code> 镜像已经成功导入进来了</p>
<h2 id="查看镜像历史"><a href="#查看镜像历史" class="headerlink" title="查看镜像历史"></a>查看镜像历史</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker image <span class="built_in">history</span> 镜像名</span></span><br><span class="line"></span><br><span class="line">docker image history ubuntu</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210124224432.png" alt=""></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker - 数据管理</title>
    <url>/2021/01/31//pages/867207//</url>
    <content><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131145525.jpeg" alt=""></p>
<h2 id="拷贝数据"><a href="#拷贝数据" class="headerlink" title="拷贝数据"></a>拷贝数据</h2><h3 id="宿主机文件-gt-容器内"><a href="#宿主机文件-gt-容器内" class="headerlink" title="宿主机文件 -&gt; 容器内"></a>宿主机文件 -&gt; 容器内</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录 容器名:容器内的目录路径</span><br></pre></td></tr></table></figure>
<p>如：把宿主机当前目录下的 <code>lxf.sh</code> 文件，拷贝到  <code>lxfubuntu1</code> 容器下的 <code>/data</code> 目录中<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp lxf.sh lxfubuntu1:/data</span><br></pre></td></tr></table></figure></p>
<h3 id="容器内-gt-宿主机文件"><a href="#容器内-gt-宿主机文件" class="headerlink" title="容器内 -&gt; 宿主机文件"></a>容器内 -&gt; 宿主机文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器名:容器内需要拷贝的文件或目录 宿主机目录</span><br></pre></td></tr></table></figure>
<p>如：把 <code>lxfubuntu1</code> 容器中 <code>/data</code> 目录下的 <code>lxf.sh</code> 文件，拷贝到宿主机 <code>~/lxf/</code> 目录下<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp lxfubuntu1:/data/lxf.sh ~/lxf/</span><br></pre></td></tr></table></figure></p>
<h2 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h2><blockquote>
<p>数据卷管理就是将容器的某个目录，映射到宿主机，作为数据存储同步的目录</p>
</blockquote>
<p>命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name [容器名字] -v [宿主机目录]:[容器目录] [镜像名称] [命令(可选)]</span><br></pre></td></tr></table></figure><br>下面进行操作示范：</p>
<p>在宿主机创建一个名为 <code>data</code> 的目录，这个名字可任意<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir data</span><br></pre></td></tr></table></figure><br>将宿主机的 <code>data</code> 目录映射到容器中的 <code>/home</code> 目录<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v ~/lxf/data:/home ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br><code>-v</code> ：挂载一个数据卷<br>接着，我在容器的 <code>/home</code> 目录下创建一个 <code>lxfdir</code> 目录<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143655.png" alt=""><br>此时，宿主机的 <code>data</code> 目录下也会同步多了一个 <code>lxfdir</code> 目录<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143708.png" alt=""></p>
<p>这个宿主机的 <code>data</code> 目录就叫数据卷。</p>
<p>除了宿主机与容器之间可以进行数据交互外，如果两个容器的目录都映射到同一个宿主机目录，那还可以让多个容器间进行数据共享。</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><blockquote>
<p>数据卷容器也是一个容器，目的是专门用于提供数据卷给其它容器挂载，从而实现多个容器之间同步数据的更新。</p>
</blockquote>
<h3 id="创建数据卷模板容器"><a href="#创建数据卷模板容器" class="headerlink" title="创建数据卷模板容器"></a>创建数据卷模板容器</h3><p>命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker create -v [容器数据卷目录] --name [容器名字] [镜像名称] [命令(可选)]</span><br></pre></td></tr></table></figure><br>对<code>ubuntu</code> 镜像做了文件映射，得到数据卷目录为 <code>/data</code> 的模板容器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker create -v /data ubuntu</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143736.png" alt=""><br>注意看该模板容器的状态是 <code>Created</code> ，即并没有运行，容器名为  <code>determined_nightingale</code>  </p>
<h3 id="基于数据卷模板创建容器"><a href="#基于数据卷模板创建容器" class="headerlink" title="基于数据卷模板创建容器"></a>基于数据卷模板创建容器</h3><p>命令:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from [数据卷容器id/name] -tid --name [容器名字] [镜像名称] [命令(可选)]</span><br></pre></td></tr></table></figure><br>创建 <code>lxfubuntu1</code> 容器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --volumes-from determined_nightingale --name lxfubuntu1 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143750.png" alt=""><br>在容器的根目录下，会基于上述模板创建了一个名为 <code>data</code> 的目录（原 <code>ubuntu</code> 镜像中是没有的）</p>
<p>我们再创建一个 <code>lxfubuntu2</code> 容器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --volumes-from determined_nightingale --name lxfubuntu2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143805.png" alt=""><br>此时，我们在 <code>lxfubuntu1</code> 的 <code>data</code> 目录下创建一个名为 <code>lxf</code> 的目录， <code>lxfubuntu2</code> 的 <code>data</code> 目录中也会同步到相同的数据<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143817.png" alt=""><br>这样，只要我们是基于数据卷模板容器创建出来的容器，就可以得到一个数据共享的 <code>data</code> 目录，在该 <code>data</code> 目录中对文件的操作，都可以同步到各个由该模板容器创建出来的容器中。</p>
<h3 id="与宿主机同步文件"><a href="#与宿主机同步文件" class="headerlink" title="与宿主机同步文件"></a>与宿主机同步文件</h3><blockquote>
<p> 数据卷容器可以实现多个容器的数据同步，但是数据是保存在数据卷内，并没有保存到宿主机的文件目录中。</p>
<p>如果想将宿主机的文件同步到各个容器，可以使用 <code>docker cp</code> 将宿主机下的文件拷贝到数据卷容器即可，反之亦然</p>
</blockquote>
<p>如：把宿主机当前目录下的 <code>lxf.sh</code> 文件，拷贝到数据卷容器 <code>determined_nightingale</code> 中 <code>/data</code> 目录下<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp lxf.sh determined_nightingale:/data</span><br></pre></td></tr></table></figure><br>如：把数据卷容器 <code>determined_nightingale</code> 中 <code>/data</code> 目录下的 <code>lxf.sh</code> 文件，拷贝到宿主机 <code>~/lxf</code> 目录下<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp determined_nightingale:/data/lxf.txt ~/lxf</span><br></pre></td></tr></table></figure><br>是不是有人要问了，如果我基于数据卷模板创建容器时，顺带设置数据卷呢？，命令如下所示<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v ~/lxf/data:/data --volumes-from determined_nightingale --name lxfubuntu3 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br>很遗憾，只有数据卷配置生效，数据卷容器配置不生效～</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker - 私有仓库Registry</title>
    <url>/2021/01/31//pages/bfa843//</url>
    <content><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143241.jpeg" alt=""></p>
<blockquote>
<p>私有仓库: 在本地（局域网）搭建的一个类似公共仓库的东西，我们可以将镜像提交到私有仓库中，供局域网内的其它人拉取使用。<br>本文以 <code>Registry</code> 为例，并在提供私有仓库的主机上操作</p>
</blockquote>
<h2 id="拉取私有仓库镜像"><a href="#拉取私有仓库镜像" class="headerlink" title="拉取私有仓库镜像"></a>拉取私有仓库镜像</h2><p>请先确保你当前拥有的镜像有 <code>registry</code><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143259.png" alt=""><br>如果没有，可以先拉取下来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image pull registry</span><br></pre></td></tr></table></figure>
<h2 id="设置私有仓库地址"><a href="#设置私有仓库地址" class="headerlink" title="设置私有仓库地址"></a>设置私有仓库地址</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<p>修改 <code>insecure-registries</code> 的值，提供私有仓库的主机的ip地址和端口<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  "insecure-registries":[</span><br><span class="line">    <span class="string">"192.168.1.234:5000"</span></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Mac软件版<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143315.png" alt=""><br><strong>修改后重新启动 <code>docker</code> 服务</strong></p>
<h2 id="运行私有仓库镜像资源"><a href="#运行私有仓库镜像资源" class="headerlink" title="运行私有仓库镜像资源"></a>运行私有仓库镜像资源</h2><p>将 <code>registry</code> 镜像生成一个容器并运行起来<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p 5000:5000 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个是容器使用的端口，第二个是本地端口，这里是本地端口映射到把容器的端口</span></span><br><span class="line">docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/lxf ❯ docker ps</span><br><span class="line">❯ docker ps</span><br><span class="line">CONTAINER ID   IMAGE      COMMAND                  CREATED         STATUS         PORTS      NAMES</span><br><span class="line">f12ad7ae43ca   registry   "/entrypoint.sh /etc…"   9 minutes ago   Up 9 minutes   5000/tcp   nostalgic_elion</span><br></pre></td></tr></table></figure><br>此时你可以访问如下地址，如果看到 <code>{}</code> 就说明 <code>Registry</code> 运行正常<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://192.168.1.234:5000/v2/</span><br></pre></td></tr></table></figure></p>
<h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><p>比如此时我要将 <code>ubuntu</code> 这个镜像上传到私有仓库<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 给ubuntu镜像打一个tag，命名需为 私有仓库主机ip:端口/镜像名:[版本号,不加默认为latest]</span></span><br><span class="line">docker tag ubuntu:latest 192.168.1.234:5000/ubuntu:v0.1</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143336.png" alt=""><br>开始上传镜像至本地的私有仓库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker push &lt;registry_ip&gt;:&lt;registry_port&gt;/&lt;image_name&gt;:&lt;image_tag&gt;</span></span><br><span class="line">docker push 192.168.1.234:5000/ubuntu:v0.1</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143349.png" alt=""></p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>先将本地的 <code>v0.1</code> 删掉<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi 192.168.1.234:5000/ubuntu:v0.1</span><br></pre></td></tr></table></figure><br>拉取私有仓库中 <code>ubuntu</code> 的 <code>0.1</code> 版本镜像<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull &lt;registry_ip&gt;:&lt;registry_port&gt;/&lt;image_name&gt;:&lt;image_tag&gt;</span></span><br><span class="line">docker pull 192.168.1.234:5000/ubuntu:v0.1</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143403.png" alt=""></p>
<h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p><code>Registry</code> 不支持通过 <code>docker search</code> 这种方式去搜索镜像，会报 <code>404</code> 的错误<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143415.png" alt=""><br>需要使用 <code>V2 API</code> 去查询</p>
<h3 id="列出仓库中所有的镜像"><a href="#列出仓库中所有的镜像" class="headerlink" title="列出仓库中所有的镜像"></a>列出仓库中所有的镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl 192.168.1.234:5000/v2/_catalog</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143430.png" alt=""></p>
<h3 id="列出指定镜像的所有标签"><a href="#列出指定镜像的所有标签" class="headerlink" title="列出指定镜像的所有标签"></a>列出指定镜像的所有标签</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> curl -X GET http://&lt;registry_ip&gt;:&lt;registry_port&gt;/v2/&lt;image_name&gt;/tags/list</span></span><br><span class="line">curl 192.168.1.234:5000/v2/lxf/tags/list</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143447.png" alt=""></p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>查找指定标签的镜像的 <code>digest</code> ，再根据这个 <code>digest</code> 来删除，以删除 <code>lxf:0.2</code> 镜像为例</p>
<p>先执行命令找到该镜像的 <code>digest</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -v --silent -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -X GET  http://192.168.1.234:5000/v2/lxf/manifests/0.2 2&gt;&amp;1 | grep Docker-Content-Digest | awk '&#123;print ($3)&#125;'</span><br></pre></td></tr></table></figure><br>得到输出值<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241</span><br></pre></td></tr></table></figure><br>根据 <code>digest</code> 来删除镜像<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -v --silent -H "Accept: application/vnd.docker.distribution.manifest.v2+json" -X DELETE http://192.168.1.234:5000/v2/lxf/manifests/sha256:4e4bc990609ed865e07afc8427c30ffdddca5153fd4e82c20d8f0783a291e241</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143500.png" alt=""><br>这个时候只是删除镜像的元数据，并没有真正从硬盘上删除镜像，需要执行垃圾回收才行。</p>
<h3 id="删除失败"><a href="#删除失败" class="headerlink" title="删除失败"></a>删除失败</h3><p>遇到 <code>405 UNSUPPORTED</code> 错误<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143512.png" alt=""></p>
<p>需要在运行 <code>Registry</code> 容器时设置<code>REGISTRY_STORAGE_DELETE_ENABLED</code> 为 <code>true</code> </p>
<p>举例</p>
<p><code>docker-compose.yaml</code>：设置环境变量</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">    <span class="attr">REGISTRY_STORAGE_DELETE_ENABLED:</span> <span class="string">"true"</span></span><br></pre></td></tr></table></figure>
<p><code>docker run</code>：添加参数<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -e REGISTRY_STORAGE_DELETE_ENABLED=<span class="string">"true"</span></span></span><br><span class="line">docker run -d -p 5000:5000 -e REGISTRY_STORAGE_DELETE_ENABLED="true" registry</span><br></pre></td></tr></table></figure></p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote>
<p>执行垃圾回收，上述删除的镜像才会真正从硬盘上移除</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it registry的容器名 /bin/registry garbage-collect /etc/docker/registry/config.yml</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143530.png" alt=""></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker - 网络管理</title>
    <url>/2021/01/31//pages/337d0f//</url>
    <content><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131150136.jpeg" alt=""></p>
<blockquote>
<p>默认情况下，容器和宿主机之间网络是隔离的 </p>
</blockquote>
<p>现在启动了一个 <code>nginx</code> 容器<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143943.png" alt=""><br>如图所示 <code>nginx</code> 使用了 <code>80</code> 端口，但是我们去浏览器里访问 <code>localhost:80</code> 是无法访问到 <code>nginx</code> 服务的<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131143955.png" alt=""><br>这个时候可以通过端口映射的方式，将容器中的端口，映射到宿主机的某个端口上，从而使我们能够通过宿主机的 <code>ip+端口</code> 的方式来访问容器里的内容</p>
<h2 id="随机端口映射"><a href="#随机端口映射" class="headerlink" title="随机端口映射"></a>随机端口映射</h2><blockquote>
<p><code>-P</code> ：自动绑定所有对外提供服务的容器端口，映射的端口会从没有使用的端口池中自动随机选择，如果连续启动多个容器的话，则下一个容器的端口默认是当前容器的端口号+1</p>
</blockquote>
<p>命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -P [镜像名称]</span><br></pre></td></tr></table></figure><br>在刚才的命令基本上加 <code>-P</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit -P --name lxfnginx nginx</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144009.png" alt=""><br>这样宿主机的 <code>55000</code> 端口就映射到了窗口的 <code>80</code> 端口，访问也是成功的。<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144026.png" alt=""></p>
<h2 id="指定端口映射"><a href="#指定端口映射" class="headerlink" title="指定端口映射"></a>指定端口映射</h2><p>命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p [宿主机ip]:[宿主机端口]:[容器端口] --name [容器名称] [镜像名称]</span><br></pre></td></tr></table></figure><br>将宿主机上的 <code>8000</code> 端口映射到 <code>nginx</code> 容器的 <code>80</code> 端口<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit -p 8000:80 --name lxfnginx nginx</span><br></pre></td></tr></table></figure><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144045.png" alt=""><br>再去访问 <code>localhost:8000</code> 时也是可以正常访问到的<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144059.png" alt=""></p>
<p><code>0.0.0.0</code> 表示地址全匹配，即 <code>127.0.0.1</code> 或者宿主机的局域网IP <code>192.168.1.x</code> 这种都可以访问到 <code>nginx</code> 服务，如果我们想指定绑定的 <code>IP</code> ，可以在映射端口前加上 <code>IP</code> 即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit -p 192.168.1.234:8000:80 --name lxfnginx nginx</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144117.png" alt=""><br>虽然图中显示的是 <code>127.0.0.1:55000-&gt;80</code> ，但是经过测试</p>
<ul>
<li><code>192.168.1.234:8000</code> 是可以正常访问</li>
<li><code>127.0.0.1:55000</code> 和 <code>127.0.0.1:8000</code> 无法访问</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144134.png" alt=""></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210131144148.png" alt=""></p>
<h2 id="多端口映射"><a href="#多端口映射" class="headerlink" title="多端口映射"></a>多端口映射</h2><p>命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p [宿主机端口1]:[容器端口1]  -p [宿主机端口2]:[容器端口2] --name [容器名称] [镜像名称]</span><br></pre></td></tr></table></figure><br>如下命令所示<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 7000:443 -p 8000:80 --name lxfnginx nginx</span><br></pre></td></tr></table></figure></p>
<h2 id="共享网络"><a href="#共享网络" class="headerlink" title="共享网络"></a>共享网络</h2><blockquote>
<p>共享网络: 容器与宿主机共享网络信息</p>
</blockquote>
<p>默认情况下，容器的网络信息与宿主机是相互独立的，这样会有什么问题呢？</p>
<p>假如运行一个提供了 <code>django</code> 服务的容器，宿主机本地提供了 <code>MySql</code> 服务，此时容器想访问宿主机的数据库，是无法访问到的，这个时候容器就需要共享宿主机的网络</p>
<p>在启动容器时，加上 <code>--network=host</code> 即可共享网络，命令如下<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -dit --network=host lxf_django</span><br></pre></td></tr></table></figure><br>这样，容器与宿主机的网络就是共享的状态，此时的容器也就可以访问到宿主机的数据库了</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter - 低版本在iOS14上遇到的问题与解决方案</title>
    <url>/2020/09/29/Flutter/Flutter%20-%20%E4%BD%8E%E7%89%88%E6%9C%AC%E5%9C%A8iOS14%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>近期将测试机升级至 iOS14 ，测试使用 Flutter混合开发 的线上 APP，没发现什么问题，但是使用 Xcode 安装APP 的场景下，断开 Xcode 后再运行却闪退了。</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>近期将测试机升级至 <code>iOS14</code> ，测试使用 <code>Flutter混合开发</code> 的线上 <code>APP</code>，没发现什么问题，但是使用 <code>Xcode</code> 安装<code>APP</code>的场景下，断开 <code>Xcode</code> 后再运行却闪退了。</p>
<p>公司的 <code>APP</code> 测试结果如下：</p>
<table>
<thead>
<tr>
<th>APP来源</th>
<th>是否闪退</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>线上</td>
<td>否</td>
<td>release</td>
</tr>
<tr>
<td>蒲公英</td>
<td>是</td>
<td>debug</td>
</tr>
<tr>
<td>Xcode</td>
<td>是（断开 <code>Xcode</code> 后再打开 <code>APP</code> ）</td>
<td>debug</td>
</tr>
</tbody>
</table>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>闪退的原因是因为 <code>Flutter SDK</code>,  <code>Flutter</code> 官方的更新速度也是快，对 <code>iOS14</code> 进行了说明：  <a href="https://flutter.dev/docs/development/ios-14" target="_blank" rel="noopener">Flutter官网说明链接</a></p>
<p>大致意思就是说，如果我们在 <code>iOS14</code> 的真机上安装了 <code>debug模式</code> 编译出来的 <code>flutter</code> 应用，那么在断开编译安装连接后，将无法从桌面上打开该应用程序。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>再次是使用 <code>Xcode</code> 或 <code>flutter run</code> 来运行。</li>
<li>设置 <code>Flutter</code> 模块的编译模式为 <code>profile</code> 或 <code>release</code></li>
</ol>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol>
<li>该闪退的情况只发生在真机，并且在模拟器运行的时候， <code>Flutter</code> 模块的编译模式需要为 <code>debug</code>， 如果设置了 <code>release</code>，编译将会报错。</li>
<li>官方指出如果是 <code>纯Flutter项目</code> 可以直接使用 <code>master channel</code> 的 <code>Flutter版本</code> 秒杀这个问题，但对混合开发并没有该说明，加上我们是使用闲鱼的 <code>flutter_boost</code> 实现的混合开发，限制了 <code>Flutter</code> 的版本，所以我也就没有去实践该方案对我们是否可行</li>
</ol>
<h2 id="二、尝试解决"><a href="#二、尝试解决" class="headerlink" title="二、尝试解决"></a>二、尝试解决</h2><p>根据自己的实际情况，我选择了上述的第二个解决方案。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>用 <code>Xcode</code> 打开工程项目，在 <code>Build Settings</code> 的最下方找到 <code>User-Defined</code>，点击 <code>+</code> 按钮，添加一个键为 <code>FLUTTER_BUILD_MODE</code> ，值为 <code>release</code> 的配置。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/09/Flutter-低版本在iOS14上遇到的问题与解决方案/01.png" alt=""></p>
<p><img src= "/img/loading.gif" data-src="/images/2020/09/Flutter-低版本在iOS14上遇到的问题与解决方案/03.png" alt=""></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>再次运行到真机上，断开 <code>Xcode</code> 运行也不会崩溃了</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>真机的问题看似是解决了，但是会有问题</p>
<p>问题一：<code>release</code> 或 <code>profile</code> 模式下，<code>Flutter</code> 使用的是 <code>AOT</code>，一些功能不能使用，如：代码断点调试，热重载</p>
<p>问题二：上面也提到了，模拟器只能运行在 <code>debug</code> 模式下，而我们无法避免会在真机和模拟器之间反复切换运行，每次切换就需要手动调整 <code>FLUTTER_BUILD_MODE</code> 的值，十分麻烦</p>
<p>那有什么好的办法解决上面遇到的问题呢？</p>
<h2 id="三、优化方案"><a href="#三、优化方案" class="headerlink" title="三、优化方案"></a>三、优化方案</h2><p>其实，真机上的 <code>APP</code> 在断开 <code>Xcode</code> 后无法运行，这个对我们开发者来说不是什么问题，问题是给到测试人员就必须要可以打开才行，包括蒲公英上的包，所以为了节省这些不必要的时间，我们需要自己动手撸一个帮助我们切换 <code>Flutter编译模式</code> 的脚本。</p>
<p>在修改 <code>FLUTTER_BUILD_MODE</code> 的值时，我从 <code>git</code> 中发现，实际上是修改了 <code>项目.xcodeproj</code>，那目前有什么工具可以帮助我们修改 <code>xcodeproj</code> 文件呢？</p>
<p>这里我找到了<a href="https://github.com/kronenthaler/mod-pbxproj" target="_blank" rel="noopener">mod-pbxproj</a>，安装和使用在该库的 <code>wiki</code> 上写的很清楚，这里就不再赘述了，直接上代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> getopt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pbxproj <span class="keyword">import</span> XcodeProject</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    argv = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment"># 处理flutter_build_mode</span></span><br><span class="line">    flutter_build_mode = (<span class="literal">False</span>, <span class="string">"release"</span>)</span><br><span class="line">    <span class="comment"># target名称</span></span><br><span class="line">    target_name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        opts, args = getopt.getopt(argv, <span class="string">"p:m:t:"</span>, [<span class="string">"path=, mode=, target="</span>])</span><br><span class="line">    <span class="keyword">except</span> getopt.GetoptError:</span><br><span class="line">        print(<span class="string">'switch_flutter_build_mode.py -p "plist文件路径" -m "模式(release|debug)" -t "target名称"'</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> opt, arg <span class="keyword">in</span> opts:</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> [<span class="string">"-p"</span>, <span class="string">"--path"</span>]:</span><br><span class="line">            project_path = arg</span><br><span class="line">            <span class="keyword">if</span> len(project_path) == <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">'请输入项目的地址'</span>)</span><br><span class="line">                sys.exit(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> [<span class="string">"-m"</span>, <span class="string">"--mode"</span>]:</span><br><span class="line">            flutter_build_mode = (<span class="literal">True</span>, arg <span class="keyword">if</span> len(arg) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">"release"</span>)</span><br><span class="line">        <span class="keyword">if</span> opt <span class="keyword">in</span> [<span class="string">"-t"</span>, <span class="string">"--target"</span>]:</span><br><span class="line">            target_name = arg</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理flutter</span></span><br><span class="line">    <span class="keyword">if</span> flutter_build_mode[<span class="number">0</span>]:</span><br><span class="line">        fileName = project_path.split(<span class="string">"/"</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fileName.endswith(<span class="string">"xcodeproj"</span>):</span><br><span class="line">            print(<span class="string">"请使用-p指定.xcodeproj文件的路径"</span>)</span><br><span class="line">            sys.exit(<span class="number">3</span>)</span><br><span class="line">        project = XcodeProject.load(project_path + <span class="string">'/project.pbxproj'</span>)</span><br><span class="line">        <span class="comment"># 设置 User-Defined (如果target_name是None，则每个target都会设置flag)</span></span><br><span class="line">        project.set_flags(<span class="string">'FLUTTER_BUILD_MODE'</span>, flutter_build_mode[<span class="number">1</span>], target_name)</span><br><span class="line">        project.save()</span><br></pre></td></tr></table></figure>
<p>使用也很简单，终端直接输入如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python switch_flutter_build_mode.py -p 'xxx/项目.xcodeproj' -t target名称 -m release</span><br></pre></td></tr></table></figure>
<p>各参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td><code>xcodeproj</code> 文件的路径</td>
</tr>
<tr>
<td>-t</td>
<td><code>target</code> 名称</td>
</tr>
<tr>
<td>-m</td>
<td>编译模式 ( <code>release</code>、<code>debug</code>、<code>profile</code> )</td>
</tr>
</tbody>
</table>
<p>PS: 脚本基于 <code>Python3</code> </p>
<p>我们是使用 <code>Jenkins</code> 进行打包并自动上传至蒲公英的，所以只需要在 <code>Jenkins</code> 中配置打包前调用该脚本即可。</p>
<p>最后再结合 <a href="http://fitztrev.github.io/shuttle/" target="_blank" rel="noopener">Shuttle</a> 这个软件，就可以实现以界面的方式去切换编译模式了</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/09/Flutter-低版本在iOS14上遇到的问题与解决方案/02.png" alt=""></p>
<h2 id="四、最后说两句"><a href="#四、最后说两句" class="headerlink" title="四、最后说两句"></a>四、最后说两句</h2><p>本文是基于 <code>Flutter混合开发</code> 进行说明的，如果有什么不对或不足的地方，欢迎指正，感谢大家的阅读</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter - 打印好用的Debug日志</title>
    <url>/2020/06/26/Flutter/Flutter%20-%20%E6%89%93%E5%8D%B0%E5%A5%BD%E7%94%A8%E7%9A%84Debug%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>做 <code>iOS</code> 开发时这个功能很常用， 在 <code>OC</code> 和 <code>Swift</code> 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，但是在 <code>Dart</code> 中并不提供这些，那有什么办法实现它呢？</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h2><p>做 <code>iOS</code> 开发时这个功能很常用， 在 <code>OC</code> 和 <code>Swift</code> 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，但是在 <code>Dart</code> 中并不提供这些，那有什么办法实现它呢？</p>
<p>我们回想在开发过程中，是不是发现只要一不小心抛异常，就可以看到类似如下的打印内容，而且还能清楚的知道异常是在哪个文件和哪一行的代码造成的。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/抛异常.png" alt=""></p>
<blockquote>
<p>所以如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。</p>
</blockquote>
<h2 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h2><p>在 <code>dart:core</code> 中提供了 <code>堆栈跟踪(StackTrace)</code>，可以通过 <code>StackTrace.current</code> 取到当前的堆栈信息，打印如下图所示，会发现这不好拿到我们想要的信息。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/StackTrace.png" alt=""></p>
<p>这里我用到了官方开发的一个包 <a href="https://pub.dev/packages/stack_trace" target="_blank" rel="noopener">stack_trace</a>，它可以将堆栈信息变得更多人性化，并方便我们查看堆栈信息和获取想要的数据。</p>
<p><strong>ps: <code>stack_trace</code> 在 <code>Flutter</code> 环境下直接导包即可使用，而在纯 <code>Dart</code> 下需要将其添加为依赖于<code>pubspec.yaml</code>中。</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">stack_trace:</span> <span class="string">^1.9.3</span></span><br></pre></td></tr></table></figure>
<p>那下面我们来试试 <a href="https://pub.dev/packages/stack_trace" target="_blank" rel="noopener">stack_trace</a> 的威力吧<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:stack_trace/stack_trace.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 StackTrace 对象转换成 Chain 对象</span></span><br><span class="line"><span class="comment">// 当然，这里也可以直接用 Chain.current();</span></span><br><span class="line"><span class="keyword">final</span> chain = Chain.forTrace(StackTrace.current);</span><br><span class="line"><span class="comment">// 拿出其中一条信息</span></span><br><span class="line"><span class="keyword">final</span> frames = chain.toTrace().frames;</span><br><span class="line"><span class="keyword">final</span> frame = frames[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"所在文件：<span class="subst">$&#123;frame.uri&#125;</span> 所在行 <span class="subst">$&#123;frame.line&#125;</span> 所在列 <span class="subst">$&#123;frame.column&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// flutter: 所在文件：package:flutterlog/main.dart 所在行 55 所在列 23</span></span><br></pre></td></tr></table></figure></p>
<h2 id="三、呈上代码"><a href="#三、呈上代码" class="headerlink" title="三、呈上代码"></a>三、呈上代码</h2><p>下面我做了一点封装，直接拿走即可使用，打印效果如下所示：</p>
<p>完整的代码和示例请到GitHub上<a href="https://github.com/LinXunFeng/flutter_log" target="_blank" rel="noopener">【查看】</a>。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/打印效果.png" alt=""></p>
<p>代码：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> FLogMode &#123;</span><br><span class="line">  debug,    <span class="comment">// 💚 DEBUG</span></span><br><span class="line">  warning,  <span class="comment">// 💛 WARNING</span></span><br><span class="line">  info,     <span class="comment">// 💙 INFO</span></span><br><span class="line">  error,    <span class="comment">// ❤️ ERROR</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FLog(<span class="built_in">dynamic</span> msg, &#123; FLogMode mode = FLogMode.debug &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kReleaseMode) &#123; <span class="comment">// release模式不打印</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> chain = Chain.current(); <span class="comment">// Chain.forTrace(StackTrace.current);</span></span><br><span class="line">  <span class="comment">// 将 core 和 flutter 包的堆栈合起来（即相关数据只剩其中一条）</span></span><br><span class="line">  chain = chain.foldFrames((frame) =&gt; frame.isCore || frame.package == <span class="string">"flutter"</span>);</span><br><span class="line">  <span class="comment">// 取出所有信息帧</span></span><br><span class="line">  <span class="keyword">final</span> frames = chain.toTrace().frames;</span><br><span class="line">  <span class="comment">// 找到当前函数的信息帧</span></span><br><span class="line">  <span class="keyword">final</span> idx = frames.indexWhere((element) =&gt; element.member == <span class="string">"FLog"</span>);</span><br><span class="line">  <span class="keyword">if</span> (idx == <span class="number">-1</span> || idx+<span class="number">1</span> &gt;= frames.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用当前函数的函数信息帧</span></span><br><span class="line">  <span class="keyword">final</span> frame = frames[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> modeStr = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">switch</span>(mode) &#123;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.debug:</span><br><span class="line">      modeStr = <span class="string">"💚 DEBUG"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.warning:</span><br><span class="line">      modeStr = <span class="string">"💛 WARNING"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.info:</span><br><span class="line">      modeStr = <span class="string">"💙 INFO"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.error:</span><br><span class="line">      modeStr = <span class="string">"❤️ ERROR"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$modeStr</span> <span class="subst">$&#123;frame.uri.toString().split(<span class="string">"/"</span>).last&#125;</span>(<span class="subst">$&#123;frame.line&#125;</span>) - <span class="subst">$msg</span> "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter - 解决混合开发iOS脚本打包遇到的问题</title>
    <url>/2020/08/12/Flutter/Flutter%20-%20%E8%A7%A3%E5%86%B3%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91iOS%E8%84%9A%E6%9C%AC%E6%89%93%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>使用Xcode手动打包是正常的，但是使用脚本打包会报错</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<p>使用 <code>Xcode</code> 手动打包是正常的，但是使用脚本打包会报错，错误如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The following build commands failed:</span><br><span class="line">	PhaseScriptExecution [CP-User]\ Run\ Flutter\ Build\ Script .../Script-C3A097A8FE12FF5F875B057C.sh</span><br><span class="line">	</span><br><span class="line">flutter build ios --release</span><br><span class="line">then re-run Archive from Xcode.</span><br><span class="line">Command PhaseScriptExecution failed with a nonzero exit code</span><br></pre></td></tr></table></figure>
<h2 id="定位错误"><a href="#定位错误" class="headerlink" title="定位错误"></a>定位错误</h2><p><img src= "/img/loading.gif" data-src="/images/2020/08/Flutter-解决混合开发iOS脚本打包遇到的问题/01.png" alt=""></p>
<p>到 <code>Flutter</code> 环境目录下，按图上所示地址找到 <code>xcode_backend.sh</code>，也可以直接看 <a href="https://github.com/flutter/flutter/blob/bcc42901ad6bb3ec644be225b5f9cd998852e0ef/packages/flutter_tools/bin/xcode_backend.sh#L90-L101" target="_blank" rel="noopener">官方脚本链接</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Archive builds (ACTION=install) should always run <span class="keyword">in</span> release mode.</span></span><br><span class="line">if [[ "$ACTION" == "install" &amp;&amp; "$build_mode" != "release" ]]; then</span><br><span class="line">  EchoError "========================================================================"</span><br><span class="line">  EchoError "ERROR: Flutter archive builds must be run in Release mode."</span><br><span class="line">  EchoError ""</span><br><span class="line">  EchoError "To correct, ensure FLUTTER_BUILD_MODE is set to release or run:"</span><br><span class="line">  EchoError "flutter build ios --release"</span><br><span class="line">  EchoError ""</span><br><span class="line">  EchoError "then re-run Archive from Xcode."</span><br><span class="line">  EchoError "========================================================================"</span><br><span class="line">  exit -1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>可以看到，官方脚本的说明里面给出两个解决方案</p>
<blockquote>
<p>方案一：直接设置 <code>FLUTTER_BUILD_MODE</code> 为 <code>release</code></p>
<p>方案二：先运行 <code>flutter build ios --release</code> ，再使用 <code>Xcode</code> 去打包</p>
</blockquote>
<p>这里我们是用 <code>Jenkins</code> 脚本进行打包，所以方案二不适用，方案一更加方便些</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置Flutter的编译模式为release</span></span><br><span class="line">export FLUTTER_BUILD_MODE=release</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行原有项目的打包脚本</span></span><br><span class="line">./script/build_iOS.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>FQ-Terminal下的代理工具ProxyChains-NG</title>
    <url>/2019/01/01/Others/FQ-Terminal%E4%B8%8B%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7ProxyChains-NG/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>是不是你也遇到过，在 <code>Shadowsocks</code> 使用 <code>全局</code> 模式下，终端依旧无法 <code>ping</code> 通谷歌？这是因为 <code>Shadowsocks</code> 仅针对代理应用软件，但是一些终端下执行的命令是无法代理的。所以本篇就来介绍一下如何使你的终端也走代理进行访问。  </p>
<a id="more"></a>
<The rest of contents | 余下全文>



<blockquote>
<p>是不是你也遇到过，在 <code>Shadowsocks</code> 使用 <code>全局</code> 模式下，终端依旧无法 <code>ping</code> 通谷歌？这是因为 <code>Shadowsocks</code> 仅针对代理应用软件，但是一些终端下执行的命令是无法代理的。所以本篇就来介绍一下如何使你的终端也走代理进行访问。</p>
</blockquote>
<h2 id="方案一：终端下的all-proxy"><a href="#方案一：终端下的all-proxy" class="headerlink" title="方案一：终端下的all_proxy"></a>方案一：终端下的all_proxy</h2><blockquote>
<p>这里以 <code>zshrc</code> + <code>Shadowsocks</code> 为例</p>
<ul>
<li><p>打开 <code>Shadowsocks</code>，模式选为 <code>PAC自动模式</code> 或 <code>全局模式</code> </p>
</li>
<li><p>如果不是使用 <code>.zshrc</code> 就 编辑 <code>~/.bashrc</code>，下面的同理</p>
</li>
</ul>
</blockquote>
<h3 id="1、打开-zshrc"><a href="#1、打开-zshrc" class="headerlink" title="1、打开 .zshrc"></a>1、打开 <code>.zshrc</code></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>
<h3 id="2、添加命令"><a href="#2、添加命令" class="headerlink" title="2、添加命令"></a>2、添加命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias proxy='export all_proxy=socks5://127.0.0.1:1086'</span><br><span class="line">alias unproxy='unset all_proxy'</span><br></pre></td></tr></table></figure>
<h3 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h3><p>先应用一下配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>终端下敲入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxy</span><br></pre></td></tr></table></figure>
<p>这样就应用上代理了，使用 <code>curl</code> 获取一下 <code>cip.cc</code> 来查看当前所使用的 <code>ip</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl cip.cc</span><br></pre></td></tr></table></figure>
<p>如果不想使用代理了，就使用如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unproxy</span><br></pre></td></tr></table></figure>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>这种方式我个人是亲测无效的，不知道是不是我人品问题，还是我的 MAC 有问题，有兴趣的小伙伴可以试试。</p>
<h2 id="方案二：ProxyChains-NG"><a href="#方案二：ProxyChains-NG" class="headerlink" title="方案二：ProxyChains-NG"></a>方案二：ProxyChains-NG</h2><p>proxychains-ng是proxychains的加强版，主要有以下功能和不足：</p>
<ul>
<li>支持http/https/socks4/socks5</li>
<li>支持认证</li>
<li>远端dns查询</li>
<li>多种代理模式</li>
<li>不支持udp/icmp转发</li>
<li>少部分程序和在后台运行的可能无法代理</li>
</ul>
<p>详情可见 <a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="noopener">GitHub地址</a></p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>这里以 <code>MAC</code> + <code>homebrew</code> 为例，如果你还没有安装的话可以参考下方命令，详细可见官网 <a href="https://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">Homebrew</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将命令粘贴至终端并回车进行安装</span></span><br><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure>
<h3 id="关闭SIP"><a href="#关闭SIP" class="headerlink" title="关闭SIP"></a>关闭SIP</h3><p>macOS 10.11 后下由于开启了 SIP（System Integrity Protection） 会导致命令行下 proxychains-ng 代理的模式失效，如果你要使用 proxychains-ng 这种简单的方法，就需要先关闭 SIP。</p>
<p>具体的关闭方法如下：</p>
<ul>
<li>部分关闭 SIP</li>
</ul>
<blockquote>
<p>重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。<br>实用工具（Utilities）-&gt; 终端（Terminal）。<br>输入命令<code>csrutil enable --without debug</code>运行。<br>重启进入系统后，终端里输入 csrutil status，结果中如果有 Debugging Restrictions: disabled 则说明关闭成功。</p>
</blockquote>
<ul>
<li>完全关闭 SIP</li>
</ul>
<blockquote>
<p>重启Mac，按住Option键进入启动盘选择模式，再按⌘ + R进入Recovery模式。<br>实用工具（Utilities）-&gt; 终端（Terminal）。<br>输入命令<code>csrutil disable</code>运行。<br>重启进入系统后，终端里输入 csrutil status，结果中如果有 System Integrity Protection status:disabled. 则说明关闭成功。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install proxychains-ng</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>使用 Homebrew 安装完成后的配置文件路径为 <code>/usr/local/etc/proxychains.conf</code></p>
<p>打开它，找到 <code>[ProxyList]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">socks5  127.0.0.1 1086</span><br></pre></td></tr></table></figure>
<p>proxychains-ng支持多种代理模式,默认是选择 strict_chain。</p>
<ul>
<li>dynamic_chain ：动态模式,按照代理列表顺序自动选取可用代理</li>
<li>strict_chain ：严格模式,严格按照代理列表顺序使用代理，所有代理必须可用</li>
<li>round_robin_chain ：轮询模式，自动跳过不可用代理</li>
<li>random_chain ：随机模式,随机使用代理</li>
</ul>
<p>给proxychains4增加一个别名，在 ~/.zshrc或~/.bashrc末尾加入如下行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias pc='proxychains4'</span><br></pre></td></tr></table></figure>
<p>这样就可以使用 <code>pc</code> 来 指代 <code>proxychains4</code>，简化输入。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pc curl cip.cc</span><br></pre></td></tr></table></figure>
<p>如果你使用 <code>iTerm</code> 的话可以配置快捷键来实现前缀补全功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在 iTerm -&gt; Preferences -&gt; Profiles -&gt; Keys 中，新建一个快捷键，例如 ⌥ + p ，Action 选择 Send Hex Code，键值为 0x1 0x70 0x63 0x20 0xd，保存生效。</span><br></pre></td></tr></table></figure>
<p>更多的Hex Code可以到 <a href="https://manytricks.com/keycodes/" target="_blank" rel="noopener">manytricks</a> 上查找。</p>
<p>使用场景：敲了一长串的命令后想使用代理功能时，就可以直接使用快捷键 <code>⌥ + p</code> ，这样就会自动在命令的最前面加上 <code>pc</code> </p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains4 curl cip.cc</span><br><span class="line"></span><br><span class="line">// 如果你设置了别名的话可以使用 pc 指代 proxychains4</span><br><span class="line">pc curl cip.cc</span><br></pre></td></tr></table></figure>
<p>可以看到这就代理上了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP	: xxx.xxx.xxx.xxx</span><br><span class="line">地址	: 美国  加利福尼亚州  洛杉矶</span><br><span class="line">运营商	: it7.net</span><br><span class="line"></span><br><span class="line">数据二	: 美国</span><br><span class="line"></span><br><span class="line">数据三	: 美国加利福尼亚洛杉矶</span><br><span class="line"></span><br><span class="line">URL	: http:&#x2F;&#x2F;www.cip.cc&#x2F;xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>FQ</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 Could not find &#39;faraday&#39; ...  gem(s) (Gem::LoadError)</title>
    <url>/2020/08/29/iOS/%E8%A7%A3%E5%86%B3%20Could%20not%20find%20faraday%20...%20%20gem(s)%20(Gem%20LoadError)/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>`to_specs’: Could not find ‘faraday’ (&gt;= 0.7.4) among 77 total gem(s) (Gem::LoadError)</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="一、遇到的问题"><a href="#一、遇到的问题" class="headerlink" title="一、遇到的问题"></a>一、遇到的问题</h2><p>报错内容如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/dependency.rb:319:in `to_specs': Could not find 'faraday' (&gt;= 0.7.4) among 77 total gem(s) (Gem::LoadError)</span><br><span class="line">Checked in 'GEM_PATH=/Users/lxf/.fastlane/bin/bundle/bin:/Users/lxf/.fastlane/bin/bundle/lib/ruby/gems/2.2.0', execute `gem env` for more information</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1439:in `block in activate_dependencies'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `each'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `activate_dependencies'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1410:in `activate'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1442:in `block in activate_dependencies'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `each'</span><br><span class="line">	from /Users/xxx/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1428:in `activate_dependencies'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/specification.rb:1410:in `activate'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems.rb:196:in `rescue in try_activate'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems.rb:193:in `try_activate'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:125:in `rescue in require'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/site_ruby/2.2.0/rubygems/core_ext/kernel_require.rb:40:in `require'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/gems/fastlane-2.28.3/bin/fastlane:9:in `&lt;top (required)&gt;'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/bin/fastlane:22:in `load'</span><br><span class="line">	from /Users/lxf/.fastlane/bin/bundle/bin/fastlane:22:in `&lt;main&gt;'</span><br></pre></td></tr></table></figure></p>
<p>在执行 <code>fastlane</code> 命令时遇到了上面那个错误</p>
<h2 id="二、解决方案："><a href="#二、解决方案：" class="headerlink" title="二、解决方案："></a>二、解决方案：</h2><p>执行如下几行命令即可，解决方案出自: <a href="https://github.com/fastlane/fastlane/issues/15740#issuecomment-560277535" target="_blank" rel="noopener">链接</a><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/gems/faraday-0.*</span><br><span class="line">rm -rf $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0/specifications/faraday-0.*</span><br><span class="line">gem install faraday -v 0.17.0 --install-dir $HOME/.fastlane/bin/bundle/lib/ruby/gems/2.2.0</span><br></pre></td></tr></table></figure></p>
<p>接着再执行 <code>fastlane</code> 命令试试看吧~</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart - 抽象类的实例化</title>
    <url>/2020/06/07/Flutter/Dart-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>抽象类不能用于创建实例，但是有没有发现，<code>Dart</code> 提供的 <code>Map</code> 和 <code>List</code> 就是抽象类，却可以直接使用它们创建出一个实例对象</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="一、抽象类的使用"><a href="#一、抽象类的使用" class="headerlink" title="一、抽象类的使用"></a>一、抽象类的使用</h2><p><code>Dart</code> 抽象类可以只声明方法，也可以有具体的方法实现，但是不能直接用抽象类来创建实例，只能被继承使用或者充当接口。</p>
<p>定义一个抽象类 <code>Animal</code><br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 仅声明eat方法</span></span><br><span class="line">  <span class="keyword">void</span> eat();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明方法，且有具体实现</span></span><br><span class="line">  <span class="keyword">void</span> sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继承使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"喵喵吃"</span>);</span><br><span class="line">    sleep();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以不实现 sleep 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>充当接口<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"吃"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 必须实现 sleep 方法</span></span><br><span class="line">  <span class="keyword">void</span> sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'睡'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实例化<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> animal = Animal();</span><br><span class="line"><span class="comment">// 抽象类实例化会报错</span></span><br><span class="line"><span class="comment">// Error: The class 'Test' is abstract and can't be instantiated.</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<ul>
<li>抽象类不能实例化。</li>
<li>继承: 子类比较实现抽象方法，子类可以不重写抽象类中已实现的方法。</li>
<li>接口: 必须实现抽象类中声明的所有方法</li>
</ul>
</blockquote>
<h2 id="二、抽象类的实例化"><a href="#二、抽象类的实例化" class="headerlink" title="二、抽象类的实例化"></a>二、抽象类的实例化</h2><p>上面提到了抽象类不能用于创建实例，但是有没有发现，<code>Dart</code> 提供的 <code>Map</code> 和 <code>List</code> 就是抽象类，却可以直接使用它们创建出一个实例对象<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> list = <span class="built_in">List</span>();</span><br><span class="line"><span class="keyword">final</span> dict = <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;();</span><br></pre></td></tr></table></figure><br>我们来看一下 <code>Map</code> 的源码：<br><img src= "/img/loading.gif" data-src="/images/2020/06/Dart-抽象类的实例化/Map源码.png" alt="Map源码"></p>
<p><code>Map</code> 的确是抽象类，不过此时我们也注意到了，在 <code>Map</code> 这个抽象类中，定义了一个工厂构造方法，<strong>这就是使抽象类可实例化的关键所在，因为工厂方法可以返回一个实例对象，但这个对象的类型不一定就是当前类!</strong></p>
<p>在这个地方，<code>Map</code> 的工厂方法并没有具体的实现，而只是在工厂构造方法前加了一个关键字 <code>external</code>。<br><code>external</code> 关键字可以让方法的声明与实现分离，即 可以由外部来帮我们完成具体的方法实现，那外部如何才能关联到该声明的方法呢？这里就需要用到注解 <code>@patch</code>，使外部的方法实现与该声明的方法绑定</p>
<blockquote>
<p><code>external</code> 可以分离方法的声明与实现<br><code>@patch</code> 关联某个类中用 <code>external</code> 修饰的方法的实现</p>
</blockquote>
<p>根据如下路径可以找到 <code>Map</code> 的具体实现源码<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/map_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="keyword">factory</span> <span class="built_in">Map</span>() =&gt; <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;();</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里使用了 <code>LinkedHashMap</code> 来实现 <code>Map</code> 。</p>
<p>我们再去看一下 <code>LinkedHashMap</code> 的实现源码，路径如下：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/collection/linked_hash_map.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">external</span> <span class="keyword">factory</span> LinkedHashMap(</span><br><span class="line">    &#123;<span class="built_in">bool</span> <span class="built_in">Function</span>(K, K)? equals,</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">Function</span>(K)? hashCode,</span><br><span class="line">    <span class="built_in">bool</span> <span class="built_in">Function</span>(<span class="built_in">dynamic</span>)? isValidKey&#125;);</span><br></pre></td></tr></table></figure><br>这里我们又发现 <code>LinkedHashMap</code> 也仅仅只是声明，找到具体实现</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/collection_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@patch</span></span><br><span class="line">  <span class="keyword">factory</span> LinkedHashMap(</span><br><span class="line">      &#123;<span class="built_in">bool</span> equals(K key1, K key2)?,</span><br><span class="line">      <span class="built_in">int</span> hashCode(K key)?,</span><br><span class="line">      <span class="built_in">bool</span> isValidKey(potentialKey)?&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValidKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hashCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (equals == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> _InternalLinkedHashMap&lt;K, V&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        hashCode = _defaultHashCode;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (identical(identityHashCode, hashCode) &amp;&amp;</span><br><span class="line">            identical(identical, equals)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> _CompactLinkedIdentityHashMap&lt;K, V&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        equals ??= _defaultEquals;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hashCode ??= _defaultHashCode;</span><br><span class="line">      equals ??= _defaultEquals;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _CompactLinkedCustomHashMap&lt;K, V&gt;(equals, hashCode, isValidKey);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>LinkedHashMap</code>的工厂构造方法返回的实例类型是 <code>_InternalLinkedHashMap</code> 或 <code>_CompactLinkedCustomHashMap</code> ，这里我们再看一下这两个类的实现源码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/_internal/vm/lib/compact_hash.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pragma</span>(<span class="string">"vm:entry-point"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InternalLinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">_HashVMBase</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span></span></span><br><span class="line"><span class="class">        <span class="title">MapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">_LinkedHashMapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">_HashBase</span>,</span></span><br><span class="line"><span class="class">        <span class="title">_OperatorEqualsAndHashCode</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  _InternalLinkedHashMap() &#123;</span><br><span class="line">    _index = <span class="keyword">new</span> Uint32List(_HashBase._INITIAL_INDEX_SIZE);</span><br><span class="line">    _hashMask = _HashBase._indexSizeToHashMask(_HashBase._INITIAL_INDEX_SIZE);</span><br><span class="line">    _data = <span class="keyword">new</span> <span class="built_in">List</span>.filled(_HashBase._INITIAL_INDEX_SIZE, <span class="keyword">null</span>);</span><br><span class="line">    _usedData = <span class="number">0</span>;</span><br><span class="line">    _deletedKeys = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CompactLinkedIdentityHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">_HashFieldBase</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span></span></span><br><span class="line"><span class="class">        <span class="title">MapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">_LinkedHashMapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">_HashBase</span>,</span></span><br><span class="line"><span class="class">        <span class="title">_IdenticalAndIdentityHashCode</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  _CompactLinkedIdentityHashMap() : <span class="keyword">super</span>(_HashBase._INITIAL_INDEX_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CompactLinkedCustomHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">_HashFieldBase</span></span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">MapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">_LinkedHashMapMixin</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">_HashBase</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _equality;</span><br><span class="line">  <span class="keyword">final</span> _hasher;</span><br><span class="line">  <span class="keyword">final</span> _validKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(koda): Ask gbracha why I cannot have fields _equals/_hashCode.</span></span><br><span class="line">  <span class="built_in">int</span> _hashCode(e) =&gt; _hasher(e);</span><br><span class="line">  <span class="built_in">bool</span> _equals(e1, e2) =&gt; _equality(e1, e2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> containsKey(<span class="built_in">Object</span>? o) =&gt; _validKey(o) ? <span class="keyword">super</span>.containsKey(o) : <span class="keyword">false</span>;</span><br><span class="line">  V? <span class="keyword">operator</span> [](<span class="built_in">Object</span>? o) =&gt; _validKey(o) ? <span class="keyword">super</span>[o] : <span class="keyword">null</span>;</span><br><span class="line">  V? remove(<span class="built_in">Object</span>? o) =&gt; _validKey(o) ? <span class="keyword">super</span>.remove(o) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  _CompactLinkedCustomHashMap(<span class="keyword">this</span>._equality, <span class="keyword">this</span>._hasher, validKey)</span><br><span class="line">      : _validKey = (validKey != <span class="keyword">null</span>) ? validKey : <span class="keyword">new</span> _TypeTest&lt;K&gt;().test,</span><br><span class="line">        <span class="keyword">super</span>(_HashBase._INITIAL_INDEX_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它们都是一个普通的类，没有工厂构造方法，也就是说 <code>Map</code> 中的 <code>external factory Map();</code> 最终返回的最终实例类型为 <code>_InternalLinkedHashMap</code> 或 <code>_CompactLinkedCustomHashMap</code></p>
<p>我们可以做一个简单的验证<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> map = <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">print</span>(map.runtimeType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// _InternalLinkedHashMap&lt;dynamic, dynamic&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们来试着来实例化一个抽象类吧<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> eat();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"睡觉"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Animal() &#123;</span><br><span class="line">    <span class="keyword">return</span> Cat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> eat() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"吃"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> sleep() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'睡'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> animal = Animal();</span><br><span class="line"><span class="built_in">print</span>(animal.runtimeType); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果: Cat</span></span><br></pre></td></tr></table></figure>
<p>可能会有同学要问了，这里用的是接口的方式，可以用继承的方式吗？<br><strong>很遗憾不行，因为在抽象类中定义了工厂构造方法后，在子类中不能定义除工厂构造方法外的其它构造方法了，会报错~</strong></p>
<p>总结一下：</p>
<blockquote>
<p>抽象类无法直接创建实例，但是可以通过实现工厂构造方法来间接实现抽象类的实例化！</p>
</blockquote>
<h2 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h2><p>那饶了这么一大圈，为什么不直接在声明的时候就给它实现了呢？🤔<br>这样做的好处就是：</p>
<blockquote>
<ul>
<li>复用同一套API的声明</li>
<li>可以针对不同的平台做不同的实现</li>
</ul>
</blockquote>
<p>而 <code>针对不同的平台做不同的实现</code> 这一点在下方给出的源码中可以看出</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/io/file_system_entity.dart</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">_FileSystemWatcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> Stream&lt;FileSystemEvent&gt; _watch(</span><br><span class="line">      <span class="built_in">String</span> path, <span class="built_in">int</span> events, <span class="built_in">bool</span> recursive);</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">get</span> isSupported;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flutter/bin/cache/dart-sdk/lib/_internal/vm/bin/file_patch.dart</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@patch</span></span><br><span class="line"><span class="keyword">static</span> Stream&lt;FileSystemEvent&gt; _watch(</span><br><span class="line">    <span class="built_in">String</span> path, <span class="built_in">int</span> events, <span class="built_in">bool</span> recursive) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isLinux) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _InotifyFileSystemWatcher(path, events, recursive)._stream;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isWindows) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _Win32FileSystemWatcher(path, events, recursive)._stream;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Platform.isMacOS) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _FSEventStreamFileSystemWatcher(path, events, recursive)</span><br><span class="line">        ._stream;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> FileSystemException(</span><br><span class="line">      <span class="string">"File system watching is not supported on this platform"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter - 混合开发</title>
    <url>/2020/07/12/Flutter/Flutter%20-%20%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>目前大多数公司都有自己开发多年的项目，不可能直接用 <code>Flutter</code> 从头开发一套，那样不实现，除非是小项目，因此只能是在原有的基础上用 <code>Flutter</code> 来开发新业务或重构旧业务，而这里就需要用到 <code>Flutter</code> 的 <code>混合开发</code></p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<blockquote>
<p>目前大多数公司都有自己开发多年的项目，不可能直接用 <code>Flutter</code> 从头开发一套，那样不实现，除非是小项目，因此只能是在原有的基础上用 <code>Flutter</code> 来开发新业务或重构旧业务，而这里就需要用到 <code>Flutter</code> 的 <code>混合开发</code></p>
</blockquote>
<h3 id="一、创建Flutter模块"><a href="#一、创建Flutter模块" class="headerlink" title="一、创建Flutter模块"></a>一、创建Flutter模块</h3><p>使用混合开发就不能像之前一样直接上来就创建一个 <code>Flutter</code> 项目，而是要使用 <code>Flutter模板</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> flutter_module_lxf 可以随便你命名</span></span><br><span class="line">flutter create --template module flutter_module_lxf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> --template 可以替换为 -t</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> flutter create -t module flutter_module_lxf</span></span><br></pre></td></tr></table></figure>
<p>创建出来的 <code>Flutter</code> 模块依然是可以像之前创建的<code>Flutter项目</code> 一样打开和运行的。 </p>
<p>目录下有也有 <code>ios</code> 和 <code>android</code> 目录，只不过前面加了个点 ，成了点目录。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS01.png" alt=""></p>
<h2 id="二、iOS"><a href="#二、iOS" class="headerlink" title="二、iOS"></a>二、iOS</h2><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><blockquote>
<p>通过 <code>Cocoapods</code> ，将 <code>Flutter</code> 模块编译成一个库，再到原生项目中进行引入和使用即可</p>
</blockquote>
<p>在 <code>Podfile</code> 中添加两行配置</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定我们刚刚创建的 Flutter 模块的路径</span></span><br><span class="line">flutter_application_path = <span class="string">'../flutter_module_lxf'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接脚本文件的路径: .ios/Flutter/podhelper.rb</span></span><br><span class="line">load File.join(flutter_application_path, <span class="string">'.ios'</span>, <span class="string">'Flutter'</span>, <span class="string">'podhelper.rb'</span>)</span><br></pre></td></tr></table></figure>
<p>在每个需要引用 <code>Flutter</code> 的 <code>Target</code> 下，都需要添加一行配置</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">install_all_flutter_pods(flutter_application_path)</span><br></pre></td></tr></table></figure>
<p>添加后如下所示：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">flutter_application_path = <span class="string">'../flutter_module_lxf'</span></span><br><span class="line">load File.join(flutter_application_path, <span class="string">'.ios'</span>, <span class="string">'Flutter'</span>, <span class="string">'podhelper.rb'</span>)</span><br><span class="line"></span><br><span class="line">use_frameworks!</span><br><span class="line">target <span class="string">'LXFFlutterHybridDemo'</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">  install_all_flutter_pods(flutter_application_path)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>添加完成后，执行一次 <code>pod install</code></p>
<p>混合开发混合开发<img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS02.png" alt=""></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>两个步骤</p>
<ol>
<li>获取 Flutter引擎 <code>FlutterEngine</code></li>
<li>通过 <code>FlutterEngine</code> 创建 <code>FlutterViewController</code></li>
</ol>
</blockquote>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>AppDelegate</code> 类中声明一个 <code>FlutterEngine</code> 变量，在 <code>didFinishLaunchingWithOptions</code> 方法中启动 <code>Flutter引擎</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AppDelegate.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Flutter</span><br><span class="line"></span><br><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建 Flutter引擎</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> flutterEngine = <span class="type">FlutterEngine</span>(name: <span class="string">"lxf"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动 Flutter引擎</span></span><br><span class="line">        flutterEngine.run()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>ViewController</code> 中添加一个按钮，点击弹出 <code>Flutter模块</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewController.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> btn = <span class="type">UIButton</span>(type: .custom)</span><br><span class="line">  btn.frame = <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">200</span>, width: <span class="number">200</span>, height: <span class="number">44</span>)</span><br><span class="line">  btn.backgroundColor = .black</span><br><span class="line">  btn.addTarget(<span class="keyword">self</span>, action: #selector(showFlutterVc), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">  btn.setTitle(<span class="string">"弹出Flutter模块"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line">  <span class="keyword">self</span>.view.addSubview(btn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">showFlutterVc</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建FlutterViewController</span></span><br><span class="line">  <span class="comment">// 这里的 engine 可以传 nil，Flutter会帮我们自动创建一个引擎，但是性能较差</span></span><br><span class="line">  <span class="keyword">let</span> flutterVc = <span class="type">FlutterViewController</span>(engine: fetchFlutterEngine(), nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">self</span>.present(flutterVc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchFlutterEngine</span><span class="params">()</span></span> -&gt; <span class="type">FlutterEngine</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">UIApplication</span>.shared.delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span>).flutterEngine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS04.jpg" alt=""></p>
<p>如果遇到报 <code>Command PhaseScriptExecution failed with a nonzero exit code</code> 错误，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS03.png" alt=""></p>
<p>请先用 <code>Android Studio</code> 或 <code>VSCode</code> 打开 <code>Flutter模块</code> 项目并运行到iOS设备上，让其帮我们对iOS项目进行一些初始化配置。成功运行后就可以关闭 <code>Flutter模块</code> 项目的运行了，接着再用 <code>Xcode</code> 打开原生项目运行即可。</p>
<h4 id="修改初始路由"><a href="#修改初始路由" class="headerlink" title="修改初始路由"></a>修改初始路由</h4><p>官方文档里面提到，修改初始路由，需要在 <code>Flutter引擎</code> 在 <code>run</code> 之前，通过 <code>invokeMethod</code> 调用 <code>setInitialRoute</code> 方法进行设置，代码如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改初始路由</span></span><br><span class="line">flutterEngine.navigationChannel.invokeMethod(<span class="string">"setInitialRoute"</span>, arguments: <span class="string">"/other"</span>)</span><br><span class="line"><span class="comment">// 启动 Flutter引擎</span></span><br><span class="line">flutterEngine.run()</span><br></pre></td></tr></table></figure>
<p>但是，我发现这样写并没有起任何作用，在 <code>Flutter</code> 的官方 <code>issue</code> 上也有人提到这个问题： <a href="https://github.com/flutter/flutter/issues/59895" target="_blank" rel="noopener">【setInitialRoute is broken for iOS add-to-app #59895】</a>，目前只能官方进行修复和调整 <code>API</code></p>
<p>临时可以使用如下方式实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> flutterVc = <span class="type">FlutterViewController</span>(project: <span class="type">FlutterDartProject</span>(), nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">flutterVc.setInitialRoute(<span class="string">"/other"</span>)</span><br><span class="line"><span class="keyword">self</span>.present(flutterVc, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>虽然这么写可以实现这个功能，但是会有明显的类似卡顿的现象，因为使用这种方式去创建 <code>FlutterViewController</code> 之前，会隐式创建和启动一个 <code>FlutterEngine</code>，而我们弹出 <code>FlutterViewController</code> 时 <code>FlutterEngine</code> 还没加载完毕，所以我们会看到先弹出了一个透明的界面，再显示 <code>/other</code> 路由对应的界面视图。</p>
<h4 id="使用-FlutterAppDelegate"><a href="#使用-FlutterAppDelegate" class="headerlink" title="使用 FlutterAppDelegate"></a>使用 FlutterAppDelegate</h4><p>使用 <code>FlutterAppDelegate</code>这个不是必要的操作，但是如果你想让 <code>Flutter模块</code> 也能使用原生的功能的话，建议使用</p>
<blockquote>
<p> 原生功能</p>
<ul>
<li>处理 <code>openURL</code> 的回调</li>
<li>列表视图在点击状态栏后滚到顶部</li>
</ul>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">FlutterAppDelegate</span></span></span><br></pre></td></tr></table></figure>
<p>更具体的使用，请阅读 <a href="https://flutter.dev/docs/development/add-to-app/ios/add-flutter-screen?tab=no-engine-vc-swift-tab#using-the-flutterappdelegate" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="三、Android"><a href="#三、Android" class="headerlink" title="三、Android"></a>三、Android</h2><p>修改安卓项目 根目录下的 <code>settings.gradle</code> 文件 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line"></span><br><span class="line">include <span class="string">':app'</span>                                    <span class="comment">// assumed existing content</span></span><br><span class="line">setBinding(<span class="keyword">new</span> Binding([<span class="string">gradle:</span> <span class="keyword">this</span>]))                                <span class="comment">// new</span></span><br><span class="line">evaluate(<span class="keyword">new</span> File(                                                     <span class="comment">// new</span></span><br><span class="line">  settingsDir.parentFile,                                              <span class="comment">// new</span></span><br><span class="line">  <span class="comment">// 这里的 flutter_module_lxf 请修改为你自己创建的Flutter模板目录名称</span></span><br><span class="line">  <span class="string">'flutter_module_lxf/.android/include_flutter.groovy'</span>                 <span class="comment">// new</span></span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS09.png" alt=""></p>
<p>修改安卓项目 <code>app</code> 目录下的 <code>build.gradle</code> 文件 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/build.gradle</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 配置flutter依赖</span></span><br><span class="line">  implementation project(<span class="string">':flutter'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在编译的时候遇到如下错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Default interface methods are only supported starting with Android N (--min-api 24): void androidx.lifecycle.DefaultLifecycleObserver.onCreate(androidx.lifecycle.LifecycleOwner)</span><br></pre></td></tr></table></figure>
<p>请确认是否指定了使用 <code>Java 8</code> 进行编译 <a href="https://flutter.dev/docs/development/add-to-app/android/project-setup#java-8-requirement" target="_blank" rel="noopener">【官方文档 -  Java 8 requirement】</a></p>
<p>修改安卓项目  <code>app</code> 目录下的 <code>build.gradle</code> 文件 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; app&#x2F;build.gradle</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">	...</span><br><span class="line">  compileOptions &#123;</span><br><span class="line">      sourceCompatibility 1.8</span><br><span class="line">      targetCompatibility 1.8</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS08.png" alt=""></p>
<p>修改 <code>app/src/main/AndroidManifest.xml</code> 文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// app/src/main/AndroidManifest.xml</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">"io.flutter.embedding.android.FlutterActivity"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:hardwareAccelerated</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:windowSoftInputMode</span>=<span class="string">"adjustResize"</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS10.png" alt=""></p>
<p>添加一个按钮，点击弹出 <code>Flutter模块</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  activity_main.xml  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/btn"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"弹出Flutter模块"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"#000000"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">"#ffffff"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">"btnClick"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btnClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    startActivity(</span><br><span class="line">        FlutterActivity.createDefaultIntent(<span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、调试与热重载"><a href="#四、调试与热重载" class="headerlink" title="四、调试与热重载"></a>四、调试与热重载</h2><blockquote>
<p>由于当前我们是使用原生开发工具(如：Xcode)来运行项目，每次修改我们的<br> <code>Flutter模块</code> 的代码，也就需要重新运行才能看到效果，不像之前按下 <code>Cmd + s</code> 就能进行热重载。这样 <code>Flutter模块</code> 的开发效率极其低下，那有没有办法可以让我们像之前开发 <code>Flutter</code> 项目时那样进行 <code>热重载</code> 呢？答案是有的</p>
</blockquote>
<p><code>Flutter</code> 官方提供了 <code>flutter attach</code> ，以辅助我们开发，到终端下执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter attach</span><br></pre></td></tr></table></figure>
<p>如果当前有多个设备，会提示我们需要指定 <code>attach</code> 哪个设备</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS05.png" alt=""></p>
<p>按要求加上指定参数即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter attach -d FE305309-9E79-418D-BA3F-7EFECF2980BC</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS06.png" alt=""></p>
<p>如图，这样就关联上了，你在 <code>dart</code> 文件里面对界面进行任何修改后，按 <code>r</code> 进行热重载，按 <code>R</code> 进行热启动。</p>
<p>如果你使用的是 <code>Android Studio</code>，可以直接选择对应的设备后，点击右边的 <code>Flutter Attach</code> 按钮，执行成功后就可以跟之前一样按 <code>Cmd + s</code> 进行热重载了。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/07/Flutter-混合开发/混合开发iOS07.png" alt=""></p>
<h2 id="五、资料"><a href="#五、资料" class="headerlink" title="五、资料"></a>五、资料</h2><ul>
<li><p>GitHub</p>
<p><a href="https://github.com/LinXunFeng/LXFFlutterHybridDemo" target="_blank" rel="noopener">LXFFlutterHybridDemo</a></p>
</li>
<li><p>官方文档</p>
<p><a href="https://flutter.dev/docs/development/add-to-app" target="_blank" rel="noopener">add-to-app</a> | <a href="https://flutter.dev/docs/development/add-to-app/ios" target="_blank" rel="noopener">add-to-app/ios</a> | <a href="https://flutter.dev/docs/development/add-to-app/android" target="_blank" rel="noopener">add-to-app/android</a> |  <a href="https://flutter.dev/docs/development/add-to-app/debugging" target="_blank" rel="noopener">Debugging &amp; hot reload</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>分享 - Flutter打造好用的打印工具类</title>
    <url>/2020/09/11/Share/%E5%88%86%E4%BA%AB%20-%20Flutter%E6%89%93%E9%80%A0%E5%A5%BD%E7%94%A8%E7%9A%84%E6%89%93%E5%8D%B0%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h2><p>做 <code>iOS</code> 开发的同学都知道，我们在平时开发过程中，经常会用到非常实用的自定义打印功能，方便我们快速定位是在哪个控制器，哪一行代码。</p>
<p> 在 <code>OC</code> 和 <code>Swift</code> 中都可以很轻松实现，因为系统本来就提供了用于日志输出的预处理宏，只要我们拿来拼接就可以了，这里以 <code>Swift</code> 的打印为例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LogType</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> error = <span class="string">"❤️ ERROR"</span></span><br><span class="line">    <span class="keyword">case</span> warning = <span class="string">"💛 WARNING"</span></span><br><span class="line">    <span class="keyword">case</span> info = <span class="string">"💙 INFO"</span></span><br><span class="line">    <span class="keyword">case</span> debug = <span class="string">"💚 DEBUG"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> log = <span class="type">Logger</span>.shared</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">Logger</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> logDateFormatter: <span class="type">DateFormatter</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> f = <span class="type">DateFormatter</span>()</span><br><span class="line">        f.dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span></span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">error</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">        file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">        function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">        line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="type">LXFLog</span>(message, type: .error, file : file, function: function, line: line)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">warning</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">        file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">        function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">        line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="type">LXFLog</span>(message, type: .warning, file : file, function: function, line: line)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">info</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">        file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">        function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">        line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="type">LXFLog</span>(message, type: .info, file : file, function: function, line: line)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">debug</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">        file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">        function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">        line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="type">LXFLog</span>(message, type: .debug, file : file, function: function, line: line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK:- 自定义打印方法</span></span><br><span class="line"><span class="comment">// target -&gt; Build Settings 搜索 Other Swift Flags</span></span><br><span class="line"><span class="comment">// 设置Debug 添加 -D DEBUG</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LXFLog</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> message : T,</span></span></span><br><span class="line"><span class="function"><span class="params">    type: LogType,</span></span></span><br><span class="line"><span class="function"><span class="params">    file : StaticString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">    function : StaticString = #function,</span></span></span><br><span class="line"><span class="function"><span class="params">    line : UInt = #line</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">    <span class="keyword">let</span> time = <span class="type">Logger</span>.logDateFormatter.string(from: <span class="type">Date</span>())</span><br><span class="line">    <span class="keyword">let</span> fileName = (file.description <span class="keyword">as</span> <span class="type">NSString</span>).lastPathComponent</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(time) \(type.rawValue) \(fileName):(\(line))-\(message)"</span>)</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用及打印结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">log.debug(<span class="string">"models count -- \(models.count)"</span>)</span><br><span class="line">log.warning(<span class="string">"models count -- \(models.count)"</span>)</span><br><span class="line">log.info(<span class="string">"models count -- \(models.count)"</span>)</span><br><span class="line">log.error(<span class="string">"models count -- \(models.count)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">💚 DEBUG XXXViewController.swift:(79)-models count -- 10</span></span><br><span class="line"><span class="comment">💛 WARNING XXXViewController.swift:(80)-models count -- 10</span></span><br><span class="line"><span class="comment">💙 INFO XXXViewController.swift:(81)-models count -- 10</span></span><br><span class="line"><span class="comment">❤️ ERROR XXXViewController.swift:(82)-models count -- 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>OC</code> 和 <code>Swift</code> 的预处理宏对应表</p>
<table>
<thead>
<tr>
<th>OC</th>
<th>Swift</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>__FILE__</td>
<td>#file</td>
<td>打印当前文件路径</td>
</tr>
<tr>
<td>__LINE__</td>
<td>#line</td>
<td>打印当前行号，整数</td>
</tr>
<tr>
<td>__FUNCTION__</td>
<td>#function</td>
<td>打印当前函数或方法</td>
</tr>
</tbody>
</table>
<p>但是在 <code>Dart</code> 中并没有提供这些功能，但是这个功能对我们来说确实又非常需要，那有什么办法实现它呢？</p>
<center><br>  <span style="font-size:300px; text-alignment:center">🤔</span><br></center>



<p>我们回想在开发过程中，是不是发现只要一不小心抛异常，就可以看到类似如下的打印内容，而且还能清楚的知道异常是在哪个文件和哪一行的代码造成的。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/抛异常.png" alt=""></p>
<blockquote>
<p>所以如果我们可以在调用函数时拿到当前调用堆栈，就可以取到一系列想要的数据。</p>
</blockquote>
<h2 id="二、实践"><a href="#二、实践" class="headerlink" title="二、实践"></a>二、实践</h2><p>在 <code>dart:core</code> 中提供了 <code>堆栈跟踪(StackTrace)</code>，可以通过 <code>StackTrace.current</code> 取到当前的堆栈信息，打印如下图所示，会发现这不好拿到我们想要的信息。</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/StackTrace.png" alt=""></p>
<p>这里我用到了官方开发的一个包 <a href="https://pub.dev/packages/stack_trace" target="_blank" rel="noopener">stack_trace</a>，它可以将堆栈信息变得更多人性化，并方便我们查看堆栈信息和获取想要的数据。</p>
<p><strong>ps: <code>stack_trace</code> 在 <code>Flutter</code> 环境下直接导包即可使用，而在纯 <code>Dart</code> 下需要将其添加为依赖于<code>pubspec.yaml</code>中。</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">stack_trace:</span> <span class="string">^1.9.3</span></span><br></pre></td></tr></table></figure>
<p>那下面我们来试试 <a href="https://pub.dev/packages/stack_trace" target="_blank" rel="noopener">stack_trace</a> 的威力吧<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:stack_trace/stack_trace.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 StackTrace 对象转换成 Chain 对象</span></span><br><span class="line"><span class="comment">// 当然，这里也可以直接用 Chain.current();</span></span><br><span class="line"><span class="comment">// final chain = Chain.current();</span></span><br><span class="line"><span class="keyword">final</span> chain = Chain.forTrace(StackTrace.current);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(chain);</span><br></pre></td></tr></table></figure></p>
<p>打印内容：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">flutter: package:flutter_test1/main.dart <span class="number">79</span>:<span class="number">17</span>       _MyHomePageState.test_print</span><br><span class="line">package:flutter_test1/main.dart <span class="number">38</span>:<span class="number">5</span>                 _MyHomePageState._incrementCounter</span><br><span class="line">package:flutter/src/material/ink_well.dart <span class="number">779</span>:<span class="number">19</span>    _InkResponseState._handleTap</span><br><span class="line">package:flutter/src/material/ink_well.dart <span class="number">862</span>:<span class="number">36</span>    _InkResponseState.build.&lt;fn&gt;</span><br><span class="line">package:flutter/src/gestures/recognizer.dart <span class="number">182</span>:<span class="number">24</span>  GestureRecognizer.invokeCallback</span><br><span class="line">package:flutter/src/gestures/tap.dart <span class="number">504</span>:<span class="number">11</span>         TapGestureRecognizer.handleTapUp</span><br><span class="line">package:flutter/src/gestures/tap.dart <span class="number">282</span>:<span class="number">5</span>          BaseTapGestureRecognizer._checkUp</span><br><span class="line">package:flutter/src/gestures/tap.dart <span class="number">254</span>:<span class="number">7</span>          BaseTapGestureRecognizer.acceptGesture</span><br><span class="line">package:flutter/src/gestures/arena.dart <span class="number">156</span>:<span class="number">27</span>       GestureArenaManager.sweep</span><br><span class="line">package:flutter/src/gestures/binding.dart <span class="number">222</span>:<span class="number">20</span>     GestureBinding.handleEvent</span><br><span class="line">package:flutter/src/gestures/binding.dart <span class="number">198</span>:<span class="number">22</span>     GestureBinding.dispatchEvent</span><br><span class="line">package:flutter/src/gestures/binding.dart <span class="number">156</span>:<span class="number">7</span>      GestureBinding._handle&lt;…&gt;</span><br></pre></td></tr></table></figure>
<p>工具代码雏形：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:stack_trace/stack_trace.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 StackTrace 对象转换成 Chain 对象</span></span><br><span class="line"><span class="comment">// 当然，这里也可以直接用 Chain.current();</span></span><br><span class="line"><span class="keyword">final</span> chain = Chain.forTrace(StackTrace.current);</span><br><span class="line"><span class="comment">// 拿出其中一条信息</span></span><br><span class="line"><span class="keyword">final</span> frames = chain.toTrace().frames;</span><br><span class="line"><span class="keyword">final</span> frame = frames[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"所在文件：<span class="subst">$&#123;frame.uri&#125;</span> 所在行 <span class="subst">$&#123;frame.line&#125;</span> 所在列 <span class="subst">$&#123;frame.column&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// flutter: 所在文件：package:flutterlog/main.dart 所在行 55 所在列 23</span></span><br></pre></td></tr></table></figure>
<p><code>Frame</code> 类的属性</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// <span class="markdown">A single stack frame. Each frame points to a precise location in Dart code.</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frame</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">The URI of the file in which the code is located.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This URI will usually have the scheme <span class="code">`dart`</span>, <span class="code">`file`</span>, <span class="code">`http`</span>, or <span class="code">`https`</span>.</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Uri</span> uri;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The line number on which the code location is located.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">This can be null, indicating that the line number is unknown or</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">unimportant.</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> line;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// <span class="markdown">The name of the member in which the code location occurs.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Anonymous closures are represented as <span class="code">`&lt;fn&gt;`</span> in this member string.</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> member;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>uri</code> : 获取代码所在文件的路径</li>
<li><code>line</code> : 获取代码所在行</li>
<li><code>member</code> : 获取所在方法</li>
</ul>
<p>打印看一下 :</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// uri</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;frame.uri.toString()&#125;</span>"</span>);  <span class="comment">// package:flutter_test1/main.dart</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// member</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;frame.member&#125;</span>"</span>); <span class="comment">// _MyHomePageState.scheduleAsync.&lt;fn&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// line</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">$&#123;frame.line&#125;</span>"</span>); <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>
<h2 id="三、呈上代码"><a href="#三、呈上代码" class="headerlink" title="三、呈上代码"></a>三、呈上代码</h2><p>下面我做了一点封装，直接拿走即可使用，完整的代码和示例请到GitHub上<a href="https://github.com/LinXunFeng/flutter_log" target="_blank" rel="noopener">【查看】</a>。</p>
<p>代码：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// log.dart</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> FLogMode &#123;</span><br><span class="line">  debug,    <span class="comment">// 💚 DEBUG</span></span><br><span class="line">  warning,  <span class="comment">// 💛 WARNING</span></span><br><span class="line">  info,     <span class="comment">// 💙 INFO</span></span><br><span class="line">  error,    <span class="comment">// ❤️ ERROR</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FLog(<span class="built_in">dynamic</span> msg, &#123; FLogMode mode = FLogMode.debug &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (kReleaseMode) &#123; <span class="comment">// release模式不打印</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> chain = Chain.current(); <span class="comment">// Chain.forTrace(StackTrace.current);</span></span><br><span class="line">  <span class="comment">// 将 core 和 flutter 包的堆栈合起来（即相关数据只剩其中一条）</span></span><br><span class="line">  chain = chain.foldFrames((frame) =&gt; frame.isCore || frame.package == <span class="string">"flutter"</span>);</span><br><span class="line">  <span class="comment">// 取出所有信息帧</span></span><br><span class="line">  <span class="keyword">final</span> frames = chain.toTrace().frames;</span><br><span class="line">  <span class="comment">// 找到当前函数的信息帧</span></span><br><span class="line">  <span class="keyword">final</span> idx = frames.indexWhere((element) =&gt; element.member == <span class="string">"FLog"</span>);</span><br><span class="line">  <span class="keyword">if</span> (idx == <span class="number">-1</span> || idx+<span class="number">1</span> &gt;= frames.length) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用当前函数的函数信息帧</span></span><br><span class="line">  <span class="keyword">final</span> frame = frames[idx+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> modeStr = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">switch</span>(mode) &#123;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.debug:</span><br><span class="line">      modeStr = <span class="string">"💚 DEBUG"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.warning:</span><br><span class="line">      modeStr = <span class="string">"💛 WARNING"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.info:</span><br><span class="line">      modeStr = <span class="string">"💙 INFO"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FLogMode.error:</span><br><span class="line">      modeStr = <span class="string">"❤️ ERROR"</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"<span class="subst">$modeStr</span> <span class="subst">$&#123;frame.uri.toString().split(<span class="string">"/"</span>).last&#125;</span>(<span class="subst">$&#123;frame.line&#125;</span>) - <span class="subst">$msg</span> "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接使用FLog</span></span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mode：打印模式（默认值为debug）</span></span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>, mode: FLogMode.debug);</span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>, mode: FLogMode.warning);</span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>, mode: FLogMode.info);</span><br><span class="line">FLog(<span class="string">"flutter_log demo"</span>, mode: FLogMode.error);</span><br></pre></td></tr></table></figure>
<p>打印效果如下所示：</p>
<p><img src= "/img/loading.gif" data-src="/images/2020/06/Flutter-打印好用的Debug日志/打印效果.png" alt=""></p>
]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift - PropertyWrapper</title>
    <url>/2021/04/22/iOS/Swift%20-%20PropertyWrapper/</url>
    <content><![CDATA[<h2 id="一、知识点"><a href="#一、知识点" class="headerlink" title="一、知识点"></a>一、知识点</h2><blockquote>
<p>Property Wrapper，即属性包装器，其作用是将属性的 <code>定义代码</code> 与属性的<code>存储方式代码</code> 进行分离，抽取的<code>管理的存储代码</code>只需要编写一次，即可将功能应用于其它属性上。</p>
</blockquote>
<h3 id="1、基础用法"><a href="#1、基础用法" class="headerlink" title="1、基础用法"></a>1、基础用法</h3><p>功能需求：确保值始终小于或等于12</p>
<p>这里我们直接使用 <code>property wrapper</code> 进行封装演示</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TwelveOrLess</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// wrappedValue变量的名字是固定的</span></span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; number = <span class="built_in">min</span>(newValue, <span class="number">12</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.number = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallRectangle</span> </span>&#123;</span><br><span class="line">    @<span class="type">TwelveOrLess</span> <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    @<span class="type">TwelveOrLess</span> <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rectangle = <span class="type">SmallRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(rectangle.height) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">rectangle.height = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(rectangle.height) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">rectangle.height = <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(rectangle.height) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>这里可以注意到，在创建 <code>SmallRectangle</code> 实例时，并不需要初始化 <code>height</code> 和 <code>width</code></p>
<p>原因：<br>被 <code>property wrapper</code> 声明的属性，实际上在存储时的类型是 <code>TwelveOrLess</code>，只不过编译器施了一些魔法，让它对外暴露的类型依然是被包装的原来的类型。<br>上面的 <code>SmallRectangle</code>  结构体，等同于下方这种写法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallRectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _height = <span class="type">TwelveOrLess</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _width = <span class="type">TwelveOrLess</span>()</span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _height.wrappedValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _height.wrappedValue = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _width.wrappedValue &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; _width.wrappedValue = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、设置初始值"><a href="#2、设置初始值" class="headerlink" title="2、设置初始值"></a>2、设置初始值</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallNumber</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> maximum: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; number = <span class="built_in">min</span>(newValue, maximum) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        maximum = <span class="number">12</span></span><br><span class="line">        number = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(wrappedValue: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"init(wrappedValue:)"</span>)</span><br><span class="line">        maximum = <span class="number">12</span></span><br><span class="line">        number = <span class="built_in">min</span>(wrappedValue, maximum)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(wrappedValue: <span class="type">Int</span>, maximum: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"init(wrappedValue:maximum:)"</span>)</span><br><span class="line">        <span class="keyword">self</span>.maximum = maximum</span><br><span class="line">        number = <span class="built_in">min</span>(wrappedValue, maximum)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了 <code>@SmallNumber</code> 但没有指定初始化值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZeroRectangle</span> </span>&#123;</span><br><span class="line">    @<span class="type">SmallNumber</span> <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    @<span class="type">SmallNumber</span> <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> zeroRectangle = <span class="type">ZeroRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(zeroRectangle.height, zeroRectangle.width) <span class="comment">// 0 0</span></span><br></pre></td></tr></table></figure>
<p>使用了 <code>@SmallNumber</code> ，并指定初始化值</p>
<p>这里会调用 <code>init(wrappedValue:)</code> 方法 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnitRectangle</span> </span>&#123;</span><br><span class="line">    @<span class="type">SmallNumber</span> <span class="keyword">var</span> height: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">    @<span class="type">SmallNumber</span> <span class="keyword">var</span> width: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> unitRectangle = <span class="type">UnitRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(unitRectangle.height, unitRectangle.width) <span class="comment">// 1 1</span></span><br></pre></td></tr></table></figure>
<p>使用@SmallNumber，并传参进行初始化</p>
<p>这里会调用 <code>init(wrappedValue:maximum:)</code> 方法 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NarrowRectangle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 报错：Extra argument 'wrappedValue' in call</span></span><br><span class="line">    <span class="comment">// @SmallNumber(wrappedValue: 2, maximum: 5) var height: Int = 1</span></span><br><span class="line">    <span class="comment">// 这种初始化是可以的，调用 init(wrappedValue:maximum:) 方法</span></span><br><span class="line">    <span class="comment">// @SmallNumber(maximum: 9) var height: Int = 2</span></span><br><span class="line">    @<span class="type">SmallNumber</span>(wrappedValue: <span class="number">2</span>, maximum: <span class="number">5</span>) <span class="keyword">var</span> height: <span class="type">Int</span></span><br><span class="line">    @<span class="type">SmallNumber</span>(wrappedValue: <span class="number">3</span>, maximum: <span class="number">4</span>) <span class="keyword">var</span> width: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> narrowRectangle = <span class="type">NarrowRectangle</span>()</span><br><span class="line"><span class="built_in">print</span>(narrowRectangle.height, narrowRectangle.width) <span class="comment">// 2 3</span></span><br><span class="line"></span><br><span class="line">narrowRectangle.height = <span class="number">100</span></span><br><span class="line">narrowRectangle.width = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(narrowRectangle.height, narrowRectangle.width) <span class="comment">// 5 4</span></span><br></pre></td></tr></table></figure>
<h3 id="3、projectedValue"><a href="#3、projectedValue" class="headerlink" title="3、projectedValue"></a>3、projectedValue</h3><blockquote>
<p><code>projectedValue</code>为 <code>property wrapper</code> 提供了额外的功能（如：标志某个状态，或者记录 <code>property wrapper</code> 内部的变化等）</p>
<p>两者都是通过实例的属性名进行访问，唯一不同的地方在于，<code>projectedValue</code> 需要在属性名前加上 <code>$</code> 才可以访问</p>
<ul>
<li><code>wrappedValue</code>: <code>实例.属性名</code></li>
<li><code>projectedValue</code>: <code>实例.$属性名</code></li>
</ul>
</blockquote>
<p> 下面的代码将一个 <code>projectedValue</code> 属性添加到 <code>SmallNumber</code> 结构中，以在存储该新值之前跟踪该属性包装器是否调整了该属性的新值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallNumber1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> number: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> projectedValue: <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.number = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.projectedValue = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> wrappedValue: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> number &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> newValue &gt; <span class="number">12</span> &#123;</span><br><span class="line">                number = <span class="number">12</span></span><br><span class="line">                projectedValue = <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                number = newValue</span><br><span class="line">                projectedValue = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    @<span class="type">SmallNumber1</span> <span class="keyword">var</span> someNumber: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someStructure = <span class="type">SomeStructure</span>()</span><br><span class="line"></span><br><span class="line">someStructure.someNumber = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(someStructure.$someNumber) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">someStructure.someNumber = <span class="number">55</span></span><br><span class="line"><span class="built_in">print</span>(someStructure.$someNumber) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>someStructure.$someNumber</code> 访问的是 <code>projectedValue</code></p>
<h3 id="4、使用限制"><a href="#4、使用限制" class="headerlink" title="4、使用限制"></a>4、使用限制</h3><ul>
<li>不能在协议里的属性使用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Property 'sp' declared inside a protocol cannot have a wrapper</span></span><br><span class="line">    @<span class="type">SmallNumber1</span> <span class="keyword">var</span> sp: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不能在 extension 内使用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeStructure</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Extensions must not contain stored properties</span></span><br><span class="line">    @<span class="type">SmallNumber1</span> <span class="keyword">var</span> someProperty2: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不能在 <code>enum</code> 内使用</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Property wrapper attribute 'SmallNumber1' can only be applied to a property</span></span><br><span class="line">    @<span class="type">SmallNumber1</span> <span class="keyword">case</span> a</span><br><span class="line">    <span class="keyword">case</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>class</code> 里的 <code>wrapper property</code> 不能覆盖其他的 property</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span> </span>&#123;</span><br><span class="line">    @<span class="type">SmallNumber1</span> <span class="keyword">var</span> aProperty: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BClass</span>: <span class="title">AClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Cannot override with a stored property 'aProperty'</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> aProperty: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>wrapper</code> 属性不能定义 <code>getter</code> 或 <code>setter</code> 方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Property wrapper cannot be applied to a computed property</span></span><br><span class="line">    @<span class="type">SmallNumber1</span> <span class="keyword">var</span> someNumber: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>wrapper</code> 属性不能被 <code>lazy</code>、 <code>@NSCopying</code>、 <code>@NSManaged</code>、 <code>weak</code>、 或者 <code>unowned</code> 修饰 </li>
</ul>
<h2 id="二、实际应用"><a href="#二、实际应用" class="headerlink" title="二、实际应用"></a>二、实际应用</h2><blockquote>
<p><a href="https://github.com/jessesquires/Foil" target="_blank" rel="noopener">Foil</a> – 对 <code>UserDefaults</code> 进行了轻量级的属性包装第三方库</p>
<p>这部分我们主要简单的看下该第三方库的核心实现与使用</p>
</blockquote>
<h3 id="1、使用"><a href="#1、使用" class="headerlink" title="1、使用"></a>1、使用</h3><ul>
<li><p>声明</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明使用的key为flagEnabled，默认值为true</span></span><br><span class="line">@<span class="type">WrappedDefault</span>(key: <span class="string">"flagEnabled"</span>, defaultValue: <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> flagEnabled: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明使用的key为timestamp</span></span><br><span class="line">@<span class="type">WrappedDefaultOptional</span>(key: <span class="string">"timestamp"</span>)</span><br><span class="line"><span class="keyword">var</span> timestamp: <span class="type">Date?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取变量在UserDefault中对应存储的值</span></span><br><span class="line"><span class="keyword">self</span>.flagEnabled</span><br><span class="line"><span class="keyword">self</span>.timestamp</span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置UserDefault中对应存储的值</span></span><br><span class="line"><span class="keyword">self</span>.flagEnabled = <span class="literal">false</span></span><br><span class="line"><span class="keyword">self</span>.timestamp = <span class="type">Date</span>()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、核心代码"><a href="#2、核心代码" class="headerlink" title="2、核心代码"></a>2、核心代码</h3><p><code>WrappedDefault.swift</code> 文件</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">WrappedDefault</span>&lt;<span class="title">T</span>: <span class="title">UserDefaultsSerializable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _userDefaults: <span class="type">UserDefaults</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 使用UserDefaults是所使用的key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 从UserDefaults中获取到的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>._userDefaults.fetch(<span class="keyword">self</span>.key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>._userDefaults.save(newValue, <span class="keyword">for</span>: <span class="keyword">self</span>.key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">        keyName: <span class="type">String</span>,        </span><br><span class="line">        defaultValue: <span class="type">T</span>,</span><br><span class="line">        userDefaults: <span class="type">UserDefaults</span> = .standard</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key = keyName</span><br><span class="line">        <span class="keyword">self</span>._userDefaults = userDefaults</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对key所对应的值进行初始化（已有值则跳过，没有则进行初始化）</span></span><br><span class="line">        userDefaults.registerDefault(value: defaultValue, key: keyName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WrappedDefaultOptional.swift</code> 文件<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@propertyWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">WrappedDefaultOptional</span>&lt;<span class="title">T</span>: <span class="title">UserDefaultsSerializable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _userDefaults: <span class="type">UserDefaults</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> key: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 从UserDefaults中获取到的值，无则返回nil</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> wrappedValue: <span class="type">T?</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>._userDefaults.fetchOptional(<span class="keyword">self</span>.key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newValue = newValue &#123;</span><br><span class="line">                <span class="comment">// 更新值</span></span><br><span class="line">                <span class="keyword">self</span>._userDefaults.save(newValue, <span class="keyword">for</span>: <span class="keyword">self</span>.key)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除值</span></span><br><span class="line">                <span class="keyword">self</span>._userDefaults.delete(<span class="keyword">for</span>: <span class="keyword">self</span>.key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(keyName: <span class="type">String</span>,</span><br><span class="line">                userDefaults: <span class="type">UserDefaults</span> = .standard) &#123;</span><br><span class="line">        <span class="keyword">self</span>.key = keyName</span><br><span class="line">        <span class="keyword">self</span>._userDefaults = userDefaults</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、资料"><a href="#三、资料" class="headerlink" title="三、资料"></a>三、资料</h2><p><a href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID617" target="_blank" rel="noopener">Swift官方文档</a></p>
<p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" target="_blank" rel="noopener">apple / swift-evolution</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>打造Moya便捷解析库，提供RxSwift拓展</title>
    <url>/2018/05/24/iOS/%E6%89%93%E9%80%A0Moya%E4%BE%BF%E6%8D%B7%E8%A7%A3%E6%9E%90%E5%BA%93%EF%BC%8C%E6%8F%90%E4%BE%9BRxSwift%E6%8B%93%E5%B1%95/</url>
    <content><![CDATA[<Excerpt in index | 首页摘要> 

<p>MoyaMapper是基于Moya和SwiftyJSON封装的工具，以Moya的plugin的方式来实现间接解析，支持RxSwift</p>
<p>+<a id="more"></a></p>
<The rest of contents | 余下全文>

<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>1、相信大家在使用Swift开发时，<a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a>是首选的网络工具，在模型解析这一块，Swift版模型解析的相关第三方库有很多，本人最习惯用的就是<a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener">SwiftyJSON</a>。</p>
<p>2、下面会开始讲解整个主要的开发功能与思想。</p>
<p>3、以下内容是基于大家会使用Moya和SwiftJSON的前提下所著，还不会的同学可以先简单了解后再来阅读本篇文章哦～</p>
<h2 id="二、功能开发与思想讲解"><a href="#二、功能开发与思想讲解" class="headerlink" title="二、功能开发与思想讲解"></a>二、功能开发与思想讲解</h2><h3 id="1、尝试模型解析"><a href="#1、尝试模型解析" class="headerlink" title="1、尝试模型解析"></a>1、尝试模型解析</h3><p>Moya请求服务器返回的数据以Response类返回给我们，那我们就给Response类做一个扩展，这里以解析模型为例<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要传入一个参数，告知我们要转换出什么模型</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapObject</span>&lt;T: Modelable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="comment">// 模型解析过程</span></span><br><span class="line">    。。。</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Q: 那中间的解析过程该怎么写呢？</p>
<p>A: <strong>可以让开发者遵守某个协议，实现指定的转换方法并描述转换关系。其转换过程我们不需要知道，交给开发者即可。</strong></p>
<p>那接着我们来定义一个协议Modelable，并声明转换方法<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="number">_</span> json: JSON)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开发者创建一个<code>MyMoel</code>的结构体，遵守协议<code>Modelable</code>,并实现<code>mapping</code>，书写转换关系<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyModel</span>: <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _id = <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="number">_</span> json: JSON)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._id = json[<span class="string">"_id"</span>].stringValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以目前的现状来分析一下：<code>mapObject</code>可以让开发者传入<code>模型类型</code>，而我们的协议方法却并非是个类方法。那我们需要先得到这个<code>模型类型</code>的对象，再来调用<code>mapping</code>方法</p>
<h3 id="2、模型解析的驱动开发"><a href="#2、模型解析的驱动开发" class="headerlink" title="2、模型解析的驱动开发"></a>2、模型解析的驱动开发</h3><p>Q: 怎么得到这个对象？</p>
<p>A: <strong>可以在协议中声明一个初始化方法来创建对象。是的，我们在mapObject中创建对应模型类型的对象，调用mapping方法来转换数据，再把模型对象传出去即可。</strong></p>
<p>那我们在<code>Modelable</code>中声明一个init方法，并传入一个参数，区别于其它初始化方法<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="number">_</span> json: JSON)</span></span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> json: <span class="type">JSON</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OK，现在把<code>mapObject</code>方法补齐模型解析过程</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapObject</span>&lt;T: Modelable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> modelJson = <span class="type">JSON</span>(data)[<span class="string">"modelKey"</span>]</span><br><span class="line">    <span class="comment">// 模型解析过程</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="type">T</span>.<span class="keyword">init</span>(modelJson)</span><br><span class="line">    obj.mapping(modelJson)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、自定义解析键名"><a href="#3、自定义解析键名" class="headerlink" title="3、自定义解析键名"></a>3、自定义解析键名</h3><p>Q: 这样是搞定解析了，但是网络请求回来的json格式错综复杂，有什么办法可以让开发者来自行指定model对应的键名呢？</p>
<p>A: <strong>嗯嗯，既然解析过程是在 Response 扩展里操作的，那我们可以通过协议定义键名属性，并且使用 Runtime 给Response动态添加一个属性，来记录遵守协议后的相应类名</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ModelableParameterType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 请求成功时状态码对应的值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> successValue: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// 状态码对应的键</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> statusCodeKey: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// 请求后的提示语对应的键</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tipStrKey: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">/// 请求后的主要模型数据的键</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> modelKey: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK:- runtime</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">AssociatedKeys</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">var</span> lxf_modelableParameterKey = <span class="string">"lxf_modelableParameterKey"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> lxf_modelableParameter: <span class="type">ModelableParameterType</span>.<span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> value = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.lxf_modelableParameterKey) <span class="keyword">as</span> <span class="type">AnyObject</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> type = value <span class="keyword">as</span>? <span class="type">ModelableParameterType</span>.<span class="type">Type</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">NullParameter</span>.<span class="keyword">self</span> &#125;</span><br><span class="line">            <span class="keyword">return</span> type</span><br><span class="line">        &#125; <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedKeys</span>.lxf_modelableParameterKey, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>这里有个坑：_SwiftValue问题</strong> (献上 <a href="https://stackoverflow.com/questions/42033735/failing-cast-in-swift-from-any-to-protocol/42034523#42034523" target="_blank" rel="noopener">参考链接</a>)<br>如果我们存储的不是OC对象，那么<code>objc_getAssociatedObject</code>取出来的值的类型统统为<code>_SwiftValue</code>，直接<code>as? ModelableParameterType.Type</code>绝对是nil，需要在取出来后<code>as AnyObject</code>再转换为其它类型才会成功～～ </p>
</blockquote>
<p>现在开发者就可以创建一个类来遵守<code>ModelableParameterType</code>协议，并自定义解析键名<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetParameter</span> : <span class="title">ModelableParameterType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> successValue: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"false"</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> statusCodeKey: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"error"</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tipStrKey: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"errMsg"</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> modelKey: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"results"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4、插件注入"><a href="#4、插件注入" class="headerlink" title="4、插件注入"></a>4、插件注入</h3><p>Q: 厉害了，不过要在什么时机下存储这个自定义键名的<code>NetParameter</code>？</p>
<p>A: 额，这个～～～ 哦，对了，可以通过Moya提供的插件机制！</p>
<p>翻出Moya中的Plugin.Swift，找到这个<code>process</code>方法，看看方法说明。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 在结束之前，可以被用来修改请求结果</span></span><br><span class="line"><span class="comment">/// Called to modify a result before completion.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(<span class="number">_</span> result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Moya</span>.<span class="type">Response</span>, <span class="type">MoyaError</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>那好，我们也做一个插件<code>MoyaMapperPlugin</code>给开发者使用，在创建<code>MoyaMapperPlugin</code>时把自定义解析键名的类型传进来<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">MoyaMapperPlugin</span>: <span class="title">PluginType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parameter: <span class="type">ModelableParameterType</span>.<span class="type">Type</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">T</span>: <span class="type">ModelableParameterType</span>&gt;(<span class="number">_</span> type: <span class="type">T</span>.<span class="type">Type</span>) &#123;</span><br><span class="line">        parameter = type</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// modify response</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(<span class="number">_</span> result: Result&lt;Response, MoyaError&gt;, target: TargetType)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Response</span>, <span class="type">MoyaError</span>&gt; &#123;</span><br><span class="line">        <span class="number">_</span> = result.<span class="built_in">map</span> &#123; (response) -&gt; <span class="type">Response</span> <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 趁机添加相关数据 </span></span><br><span class="line">            response.lxf_modelableParameter = parameter</span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用：开发者在创建<code>MoyaProvider</code>对象时，顺便注入插件。(OS: 这一步堪称“注入灵魂”)<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">MoyaProvider</span>&lt;<span class="type">LXFNetworkTool</span>&gt;(plugins: [<span class="type">MoyaMapperPlugin</span>(<span class="type">NetParameter</span>.<span class="keyword">self</span>)])</span><br></pre></td></tr></table></figure></p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><blockquote>
<p>以上就是主要的踩坑过程了。模型数组解析和指定解析也跟这些差不多的，这里就不再赘述。本人已经将其封装成一个开源库 <a href="https://github.com/LinXunFeng/MoyaMapper" target="_blank" rel="noopener">MoyaMapper</a>，包含了上述已经和未曾说明的功能，下面会讲解如何去使用。以上部分可以称为开胃菜，目的就是平滑过渡到下面MoyaMapper的具体使用。</p>
</blockquote>
<p>可能单单使用<code>MoyaMapper</code>的默认子库<code>Core</code>，作用体会上并不会很深。但是，如果你也是使用RxSwift来开发项目的话，请安装<code>&#39;MoyaMapper/Rx&#39;</code>吧，绝对一个字：「爽」</p>
<h2 id="二、MoyaMapper的使用"><a href="#二、MoyaMapper的使用" class="headerlink" title="二、MoyaMapper的使用"></a>二、MoyaMapper的使用</h2><p><img src= "/img/loading.gif" data-src="/images/2018/05/打造Moya便捷解析库，提供RxSwift拓展/MoyaMapper.png" alt="MoyaMapper"></p>
<p>MoyaMapper是基于Moya和SwiftyJSON封装的工具，以Moya的plugin的方式来实现间接解析，支持RxSwift</p>
<p><img src= "/img/loading.gif" data-src="/images/2018/05/打造Moya便捷解析库，提供RxSwift拓展/JSON数据对照.png" alt="JSON数据对照"></p>
<h3 id="1、定义并注入自定义键名类"><a href="#1、定义并注入自定义键名类" class="headerlink" title="1、定义并注入自定义键名类"></a>1、定义并注入自定义键名类</h3><ol>
<li>定义一个遵守ModelableParameterType协议的结构体</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 各参数返回的内容请参考上面JSON数据对照图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetParameter</span> : <span class="title">ModelableParameterType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> successValue: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"false"</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> statusCodeKey: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"error"</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tipStrKey: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">""</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> modelKey: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"results"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>此外，这里还可以做简单的路径处理，以应付各种情况，以’&gt;’隔开</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设返回的json数据关于请求状态的相关数据如下所示，</span></span><br><span class="line">error: &#123;</span><br><span class="line">    'errorStatus':false</span><br><span class="line">    'errMsg':'error Argument type'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们指明解析路径：error对象下的errMsg字段，一层层表示下去即可</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> tipStrKey: <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"error&gt;errMsg"</span> &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>以plugin的方式传递给MoyaProvider</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MoyaMapperPlugin这里只需要传入类型</span></span><br><span class="line"><span class="type">MoyaProvider</span>&lt;<span class="type">LXFNetworkTool</span>&gt;(plugins: [<span class="type">MoyaMapperPlugin</span>(<span class="type">NetParameter</span>.<span class="keyword">self</span>)])</span><br></pre></td></tr></table></figure>
<h3 id="2、定义解析模型"><a href="#2、定义解析模型" class="headerlink" title="2、定义解析模型"></a>2、定义解析模型</h3><p>创建一个遵守Modelable协议的结构体</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyModel</span>: <span class="title">Modelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> _id = <span class="string">""</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> json: <span class="type">JSON</span>) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(<span class="number">_</span> json: JSON)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._id = json[<span class="string">"_id"</span>].stringValue</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">遵守<span class="type">Modelable</span>协议，实现协议的两个方法，在`mapping`方法中描述模型字段的具体解析</span><br></pre></td></tr></table></figure>
<h3 id="3、解析数据"><a href="#3、解析数据" class="headerlink" title="3、解析数据"></a>3、解析数据</h3><h4 id="0x00-请求结果与模型解析"><a href="#0x00-请求结果与模型解析" class="headerlink" title="0x00 请求结果与模型解析"></a>0x00 请求结果与模型解析</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Result</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapResult</span><span class="params">(params: ModelableParamsBlock? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">MoyaMapperResult</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Model</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapObject</span>&lt;T: Modelable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>, modelKey: String? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">T</span></span><br><span class="line"><span class="comment">// Result+Model</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapObjResult</span>&lt;T: Modelable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>, params: ModelableParamsBlock? = <span class="literal">nil</span>)</span></span> -&gt; (<span class="type">MoyaMapperResult</span>, <span class="type">T</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Models</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapArray</span>&lt;T: Modelable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>, modelKey: String? = <span class="literal">nil</span>)</span></span> -&gt; [<span class="type">T</span>]</span><br><span class="line"><span class="comment">// Result+Models</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">mapArrayResult</span>&lt;T: Modelable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>, params: ModelableParamsBlock? = <span class="literal">nil</span>)</span></span> -&gt; (<span class="type">MoyaMapperResult</span>, [<span class="type">T</span>])</span><br></pre></td></tr></table></figure>
<p>上面的五个方法，观其名，知其意，这里就不过多解释了，主要注意两点：</p>
<ul>
<li><p>result</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元祖类型</span></span><br><span class="line"><span class="comment">// 参数1：根据statusCodeKey取出的值与successValue是否相等</span></span><br><span class="line"><span class="comment">// 参数2：根据tipStrKey取出的值</span></span><br><span class="line">result：(<span class="type">Bool</span>, <span class="type">String</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>params</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// params: ModelableParamsBlock? = nil</span></span><br><span class="line"><span class="comment">// 这里只有在特殊场景下才需要使用到。如：项目中需要在某处使用特定接口，但是返回的json格式跟自己项目的不一样，并且只有这么一两处用得着该额外接口，那就需要我们这个参数了，以Block的方式返回解析参数类型。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="0x01、特定解析"><a href="#0x01、特定解析" class="headerlink" title="0x01、特定解析"></a>0x01、特定解析</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Model</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">toJSON</span><span class="params">(modelKey: String? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">JSON</span></span><br><span class="line"><span class="comment">// 获取指定路径的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">fetchJSONString</span><span class="params">(path: String? = <span class="literal">nil</span>, keys: [JSONSubscriptType])</span></span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>这两个方法，如果没有指定路径，默认都是针对modelKey的<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fetchJSONString(keys: &lt;[JSONSubscriptType]&gt;)</span></span><br><span class="line"><span class="number">1</span>、通过 keys 传递数组, 该数组可传入的类型为 <span class="type">Int</span> 和 <span class="type">String</span></span><br><span class="line"><span class="number">2</span>、默认是以 modelKey 所示路径，来获取相应的数值。如果modelKey并非是你所想要使用的解析路径，可以使用下方的重载方法重新指定路径即可</span><br><span class="line"></span><br><span class="line"><span class="comment">// response.fetchJSONString(path: &lt;String?&gt;, keys: &lt;[JSONSubscriptType]&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p><strong>MoyaMapper也提供了Rx子库，为方便RxSwift的流式编程下便捷解析数据</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">MoyaMapper默认只安装Core下的文件</span><br><span class="line">pod <span class="string">'MoyaMapper'</span></span><br><span class="line"></span><br><span class="line">RxSwift拓展</span><br><span class="line">pod <span class="string">'MoyaMapper/Rx'</span></span><br></pre></td></tr></table></figure>
<p>具体使用还不是很明白的同学可以下载并运行<code>Example</code>看看</p>
<p><strong>如果<a href="https://github.com/LinXunFeng/MoyaMapper" target="_blank" rel="noopener">MoyaMapper</a>有什么不足的地方，欢迎提出issues，感谢大家的支持</strong></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>RxSwift</tag>
      </tags>
  </entry>
</search>
